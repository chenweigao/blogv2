# BL3-1

> ARM Trusted Firmware Design [^1]

## Introduction

> The ARM Trusted Firmware implements a subset of the Trusted Board Boot Requirements (TBBR) Platform Design Document (PDD) for ARM reference platforms. The TBB sequence starts when the platform is powered on and runs up to the stage where it hands-off control to firmware running in the normal world in DRAM. This is the cold boot path.

Trusted Board Boot(TBB) 开始于平台上电的时候，直到固件(firmware)到了 norlmal world 阶段，是一个冷启动的路径。

> The ARM Trusted Firmware also implements the Power State Coordination Interface (PSCI) PDD as a runtime service. PSCI is the interface from normal world software to firmware implementing power management use-cases (for example, secondary CPU boot, hotplug and idle). Normal world software can access ARM Trusted Firmware runtime services via the ARM SMC (Secure Monitor Call) instruction. The SMC instruction must be used as mandated by the SMC Calling Convention PDD.

The ARM Trusted Firmware 实现了 PSCI(Power State Coordination Interface) 接口作为运行时服务。

PSCI: 一个接口，这个接口实现了电源管理用例(power management use-cases)，怎么理解这个电源管理用例？举例来说就是 secondary CPU 的启动、hotplug 和 idel 等；注意到这个接口是从 normal world software 到 firmware(关于 firmware 的介绍和理解可以参考下文)。

Normal world software 可以通过 ARM SMC(Secure Monitor Call) 指令来访问 ARM Trusted Firmware 服务，SMC 制定遵循着一些约定。

## Clod Boot

> The cold boot path starts when the platform is physically turned on.

介绍何时启动。

> One of the CPUs released from reset is chosen as the **primary CPU**, and the remaining CPUs are considered **secondary CPUs**. 
> The primary CPU is chosen through platform-specific means.

介绍主 CPU 和 secondray CPUs. 一个 CPU 被选为主 CPU, 剩下的都是 secondray. 怎么选的主 CPU 呢？主要是看平台实现。

> The cold boot path is mainly executed by the primary CPU, other than essential CPU initialization executed by all CPUs. The secondary CPUs are kept in a safe platform-specific state until the primary CPU has performed enough initialization to boot them.

冷启动主要由主 CPU 完成，次 CPU 要等主 CPU 来启动他们。

### Cloud Boot Path

The cold boot path in this implementation of the ARM Trusted Firmware is divided into five steps (in order of execution):

- Boot Loader stage 1 (BL1) AP Trusted ROM
- Boot Loader stage 2 (BL2) Trusted Boot Firmware
- Boot Loader stage 3-1 (BL3-1) EL3 Runtime Firmware
- Boot Loader stage 3-2 (BL3-2) Secure-EL1 Payload (optional)
- Boot Loader stage 3-3 (BL3-3) Non-trusted Firmware

冷启动的路径可以分为上述的步骤，下文将对每一个都进行分析。

> The ARM Fixed Virtual Platforms (FVPs) provide trusted ROM, trusted SRAM and trusted DRAM regions. Each boot loader stage uses one or more of these memories for its code and data.

术语：FVPs 指的是 ARM 固定虚拟平台。

## BL1

### EL0 - EL3

> This stage begins execution from the platform's reset vector in trusted ROM at EL3. BL1 code starts at `0x00000000` (trusted ROM) in the FVP memory map. The BL1 data section is placed at the start of trusted SRAM, `0x04000000`.

开始于 EL3, 我们要了解 EL3 是什么，简单来说就是可信的级别 EL0 ~ EL3, EL3 是最高的[^5]。

![el](./images/el.png)

对于该图的解释如下：
1. EL0：表示用户空间，在 Norlmal World 运行中的应用程序，在 Secure World 中就是 Trust Application.
2. EL1: 运行操作系统。NW 中如 Linux, SW 中如高通 QSEE.
3. EL2: ARM 为了支持虚拟化，设计的虚拟化层，只有在 NW 中有
4. EL3: Secure Moniter 用于 NW 和 SW 的切换；切换的时候发送 SMC 指定，这个后文会研究

### BL1

BL1 的实现主要是以下步骤：

### Determination of boot path

确定启动路径。

> Whenever a CPU is released from reset, BL1 needs to distinguish between a warm boot and a cold boot.
> This is done using a platform-specific mechanism.

CPU 从复位中释放的时候，BL1 需要区分冷启动和热启动。这种区分依赖于特定的平台。

> The ARM FVPs implement a simple power controller at `0x1c100000`.

很好理解。

> The `PSYS` register (0x10) is used to distinguish between a cold and warm boot. This information is contained in the PSYS.WK[25:24] field.


> Additionally, a per-CPU mailbox is maintained in trusted DRAM (0x00600000), to which BL1 writes an entrypoint. Each CPU jumps to this entrypoint upon warm boot.

阐述有一个入口点在，用于热启动。

> During cold boot, BL1 places the secondary CPUs in a safe platform-specific state while the primary CPU executes the remaining cold boot path as described in the following sections.

冷启动的时候把主 CPU 和从 CPUs 放在什么地方或者状态。

通过以上文章，可以分析到，这个启动路径指的就是区分冷热启动，其中涉及到一些寄存器地址，然后就是主 CPU 的相关工作。

### Architectural initialization

BL1 performs minimal architectural initialization as follows.

1. Exception vectors
2. MMU setup
3. Control register setup

接下来分别进行阐述说明。

#### Exception vectors

> BL1 sets up simple exception vectors for both synchronous and asynchronous exceptions. 

BL1 设置了同步和异步的异常向量。

> The default behavior upon receiving an exception is to set a status code.

接受异常的时候会设置异常状态码。

> In the case of the FVP this code is written to the Versatile Express System LED register in the following format:

异常码会写入 LED 寄存器，格式如下所示：

```
SYS_LED[0]   - Security state (Secure=0/Non-Secure=1)
SYS_LED[2:1] - Exception Level (EL3=0x3, EL2=0x2, EL1=0x1, EL0=0x0)
SYS_LED[7:3] - Exception Class (Sync/Async & origin). The values for
               each exception class are:

0x0 : Synchronous exception from Current EL with SP_EL0
0x1 : IRQ exception from Current EL with SP_EL0
0x2 : FIQ exception from Current EL with SP_EL0
0x3 : System Error exception from Current EL with SP_EL0
0x4 : Synchronous exception from Current EL with SP_ELx
0x5 : IRQ exception from Current EL with SP_ELx
0x6 : FIQ exception from Current EL with SP_ELx
0x7 : System Error exception from Current EL with SP_ELx
0x8 : Synchronous exception from Lower EL using aarch64
0x9 : IRQ exception from Lower EL using aarch64
0xa : FIQ exception from Lower EL using aarch64
0xb : System Error exception from Lower EL using aarch64
0xc : Synchronous exception from Lower EL using aarch32
0xd : IRQ exception from Lower EL using aarch32
0xe : FIQ exception from Lower EL using aarch32
0xf : System Error exception from Lower EL using aarch32
```

## About

### Firmware

❓❓❓ 什么是 firmware?

> In computing, firmware is a specific class of computer software that provides the low-level control for a device's specific hardware[^2].

- computer software, 本质是软件；属于计算机软件中特殊的一类
- low-level control 作用于特定的硬件

> Ascher Opler coined the term firmware in a 1967 Datamation article, as an intermediary term between "hardware" and "software". In this article, Opler was referring to a new kind of computer program that had a different practical and psychological purpose from traditional programs from the user's perspective.
> 
> As computers began to increase in complexity, it became clear that various programs needed to first be initiated and run to provide a consistent environment necessary for running more complex programs at the user's discretion. This required programming the computer to run those programs automatically.

介绍了 firmware 的历史，固件的作用就是可以自动运行的、用户不感知的一个程序。

> Firmware, such as the BIOS of a personal computer, may contain basic functions of a device, and may provide hardware abstraction services to higher-level software such as operating systems. 

这句话举例说明了 BIOS 是 firmware 的一种。

> For less complex devices, firmware may act as the device's complete operating system, performing all control, monitoring and data manipulation functions.

对于不太复杂的系统而言，固件可以充当操作系统的角色。

❓❓❓ firmware 和嵌入式软件的关系是什么？

> Typical examples of devices containing firmware are embedded systems (running embedded software), home and personal-use appliances, computers, and computer peripherals[^3].

原文[^2]在举例 firmware 的时候提到了嵌入式系统(embedded systems), 从中我们不难判断，嵌入式系统也属于固件的一种。

> Firmware is held in non-volatile memory devices such as ROM, EPROM, EEPROM, and Flash memory. 

固件保存在非易失性存储器(non-volatile memory)中。

> Updating firmware requires ROM integrated circuits to be physically replaced, or EPROM or flash memory to be reprogrammed through a special procedure.

上段文字提到了固件的更新可以通过：
1. 把焊上去的 ROM 集成电路拆了再焊新的上去，ROM 一旦确定就无法更改。
2. EPROM：通过可擦除的 ROM 来更新。值得一提的是，EPROM 的擦除是通过紫外线的方式，其可擦除的次数一般在 1000 次左右。

:::tip ROM
ROM: Read-only memory[^4], 属于非易失性存储器，常用于固件。
我们现在SOC上用的是不可擦除的 ROM（OnChipRom）和闪存。
> Flash memory (or simply flash) is a modern type of EEPROM invented in 1984. 
Flash 也是 EEPROM 的一种。EEPROM 不同于 EPROM, EEPROM 是通过电擦除的方式来更新的，电擦除的优点在于更新其的时候不需要把这个东西从电脑中移除。
Flash 相比于 EEPROM 拥有更快的擦除重写速度，而且 endurance 在百万次级别。
:::


## Refenence

[^1]: [ARM Trusted Firmware Design](https://chromium.googlesource.com/external/github.com/ARM-software/arm-trusted-firmware/+/v0.4-rc1/docs/firmware-design.md)
[^2]: [Firmware](https://en.wikipedia.org/wiki/Firmware)
[^3]: 直译为计算机外围设备
[^4]: [Read-only memory WiKi](https://en.wikipedia.org/wiki/Read-only_memory)
[^5]: [ARMv8-A Exception Levels](https://blog.csdn.net/longwang155069/article/details/105010182)
