export const data = {
  "key": "v-7c541ea1",
  "path": "/algorithm/binarytree.html",
  "title": "Tree",
  "lang": "en-US",
  "frontmatter": {
    "title": "Tree",
    "summary": "Preorder Traversal 多叉树的前序遍历 多叉树的前序遍历，给定多叉树，用数组表示：root = [1,null,3,2,4,null,5,6], 每个层级之间用 null 进行隔离，根据这个输出这棵树的前序遍历结果。 题目中提到了，递归的方法比较简单，希望我们用迭代的方法进行求解。 题目链接如下：LC589 N 叉树的前序遍历 需要遍历的多叉",
    "head": [
      [
        "meta",
        {
          "property": "og:url",
          "content": "https://vuepress-theme-hope-v2-demo.mrhope.site/algorithm/binarytree.html"
        }
      ],
      [
        "meta",
        {
          "property": "og:site_name",
          "content": "Theme Demo"
        }
      ],
      [
        "meta",
        {
          "property": "og:title",
          "content": "Tree"
        }
      ],
      [
        "meta",
        {
          "property": "og:type",
          "content": "article"
        }
      ],
      [
        "meta",
        {
          "property": "og:locale",
          "content": "en-US"
        }
      ],
      [
        "meta",
        {
          "property": "og:locale:alternate",
          "content": "zh-CN"
        }
      ],
      [
        "meta",
        {
          "property": "article:published_time",
          "content": "2022-02-06T16:00:00.000Z"
        }
      ]
    ]
  },
  "excerpt": "",
  "headers": [
    {
      "level": 2,
      "title": "Preorder Traversal",
      "slug": "preorder-traversal",
      "children": [
        {
          "level": 3,
          "title": "多叉树的前序遍历",
          "slug": "多叉树的前序遍历",
          "children": []
        },
        {
          "level": 3,
          "title": "二叉树的前序遍历",
          "slug": "二叉树的前序遍历",
          "children": []
        }
      ]
    },
    {
      "level": 2,
      "title": "Level Order Traversal",
      "slug": "level-order-traversal",
      "children": [
        {
          "level": 3,
          "title": "二叉树的层次遍历",
          "slug": "二叉树的层次遍历",
          "children": []
        }
      ]
    },
    {
      "level": 2,
      "title": "Inorder Traversal",
      "slug": "inorder-traversal",
      "children": [
        {
          "level": 3,
          "title": "二叉树的中序遍历",
          "slug": "二叉树的中序遍历",
          "children": []
        }
      ]
    },
    {
      "level": 2,
      "title": "Trie 前缀树",
      "slug": "trie-前缀树",
      "children": []
    },
    {
      "level": 2,
      "title": "BST",
      "slug": "bst",
      "children": [
        {
          "level": 3,
          "title": "BST 中序遍历",
          "slug": "bst-中序遍历",
          "children": []
        }
      ]
    },
    {
      "level": 2,
      "title": "二叉树例题",
      "slug": "二叉树例题",
      "children": [
        {
          "level": 3,
          "title": "LC606 根据二叉树创建字符串（前序遍历）",
          "slug": "lc606-根据二叉树创建字符串-前序遍历",
          "children": []
        },
        {
          "level": 3,
          "title": "LC101 对称二叉树",
          "slug": "lc101-对称二叉树",
          "children": []
        },
        {
          "level": 3,
          "title": "LC101 对称二叉树（2刷）",
          "slug": "lc101-对称二叉树-2刷",
          "children": []
        },
        {
          "level": 3,
          "title": "LC111 二叉树的最小深度",
          "slug": "lc111-二叉树的最小深度",
          "children": []
        },
        {
          "level": 3,
          "title": "LC104 二叉树的最大深度",
          "slug": "lc104-二叉树的最大深度",
          "children": []
        },
        {
          "level": 3,
          "title": "LC104 二叉树的最大深度（2刷）",
          "slug": "lc104-二叉树的最大深度-2刷",
          "children": []
        },
        {
          "level": 3,
          "title": "LC102 二叉树的层序遍历",
          "slug": "lc102-二叉树的层序遍历",
          "children": []
        },
        {
          "level": 3,
          "title": "LC107 二叉树的层序遍历II",
          "slug": "lc107-二叉树的层序遍历ii",
          "children": []
        },
        {
          "level": 3,
          "title": "LC103 二叉树的锯齿形层序遍历",
          "slug": "lc103-二叉树的锯齿形层序遍历",
          "children": []
        }
      ]
    }
  ],
  "readingTime": {
    "minutes": 12.11,
    "words": 3634
  },
  "filePathRelative": "algorithm/binarytree.md"
}

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
