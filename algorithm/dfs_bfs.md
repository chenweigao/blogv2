# DFS & DFS

## Abstract

ğŸ“‘ğŸ“‘ğŸ“‘ æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•

ğŸ“‘ğŸ“‘ğŸ“‘ å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•

### æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•

è‹±è¯­ï¼šDepth-First-Searchï¼ŒDFSæ˜¯ä¸€ç§ç”¨äºéå†æˆ–æœç´¢æ ‘æˆ–å›¾çš„ç®—æ³•ã€‚å…¶è¿‡ç¨‹ç®€è¦æ¥è¯´æ˜¯å¯¹æ¯ä¸€ä¸ªå¯èƒ½çš„åˆ†æ”¯è·¯å¾„æ·±å…¥åˆ°ä¸èƒ½å†æ·±å…¥ä¸ºæ­¢ï¼Œè€Œä¸”æ¯ä¸ªç»“ç‚¹åªèƒ½è®¿é—®ä¸€æ¬¡.

å› å‘æ˜ã€Œæ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ã€ï¼Œçº¦ç¿° Â· éœæ™®å…‹æ´›å¤«ç‰¹ä¸ç½—ä¼¯ç‰¹ Â· å¡”æ‰¬åœ¨1986å¹´å…±åŒè·å¾—è®¡ç®—æœºé¢†åŸŸçš„æœ€é«˜å¥–ï¼šå›¾çµå¥–ã€‚


### å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•

Breadth-First Searchï¼Œç¼©å†™ä¸º BFSï¼Œåˆç§°ä¸ºå®½åº¦ä¼˜å…ˆæœç´¢ï¼Œæ˜¯ä¸€ç§å›¾å½¢æœç´¢ç®—æ³•ã€‚ç®€å•çš„è¯´ï¼ŒBFS æ˜¯ä»æ ¹ç»“ç‚¹å¼€å§‹ï¼Œæ²¿ç€æ ‘çš„å®½åº¦éå†æ ‘çš„ç»“ç‚¹ã€‚å¦‚æœæ‰€æœ‰ç»“ç‚¹å‡è¢«è®¿é—®ï¼Œåˆ™ç®—æ³•ä¸­æ­¢ã€‚

å¹¿åº¦ä¼˜å…ˆæœç´¢ä¹Ÿå¹¿æ³›åº”ç”¨åœ¨å›¾è®ºé—®é¢˜ä¸­ã€‚


## DFS

### æ¦‚è§ˆ

1. é‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚ä½•ç¡®å®šå¯ä»¥ä½¿ç”¨ DFS æ±‚è§£ï¼Ÿ
2. ä½¿ç”¨ DFS æ±‚è§£çš„ä¸€èˆ¬å¥—è·¯æ˜¯ä»€ä¹ˆï¼ŸDFS ä¸€èˆ¬ä¼šç”¨åˆ°äº†**é€’å½’**çš„æ¦‚å¿µï¼Œæ‰€ä»¥æˆ‘ä»¬å†™å‡ºæ¥çš„ä»£ç ç»“æ„ä¹Ÿåº”è¯¥æ˜¯é€’å½’çš„ã€‚è€Œå¯¹äºé€’å½’ï¼Œæˆ‘ä»¬æœ‰çš„æ—¶å€™å¯ä»¥é€’å½’å‡½æ•°æœ¬èº«ï¼Œæœ‰çš„æ—¶å€™éœ€è¦å†™è¾…åŠ©å‡½æ•°æ¥è¿›è¡Œé€’å½’ã€‚
3. ä¸Šè¿° DFS æ±‚è§£é—®é¢˜å¯ä»¥æ€»ç»“ä¸º **è‡ªåº•å‘ä¸Šæ–¹æ³•**ã€‚


### LC329 çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„

> ç»™å®šä¸€ä¸ªæ•´æ•°çŸ©é˜µï¼Œæ‰¾å‡ºæœ€é•¿é€’å¢è·¯å¾„çš„é•¿åº¦ã€‚
>
> å¯¹äºæ¯ä¸ªå•å…ƒæ ¼ï¼Œä½ å¯ä»¥å¾€ä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³å››ä¸ªæ–¹å‘ç§»åŠ¨ã€‚ ä½ ä¸èƒ½åœ¨å¯¹è§’çº¿æ–¹å‘ä¸Šç§»åŠ¨æˆ–ç§»åŠ¨åˆ°è¾¹ç•Œå¤–ï¼ˆå³ä¸å…è®¸ç¯ç»•ï¼‰ã€‚

è¿™æ˜¯ä¸€é“è¿·å®«æœç´¢é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ DFS æœç´¢ï¼Œè¿™æ ·å¯ä»¥ç†Ÿæ‚‰ DFS çš„æ­¥éª¤ã€‚å®ç°ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

@[code](../code/dfs.py)

ä½†æ˜¯ä¸å¹¸çš„æ˜¯ï¼Œä¸Šè¿°çš„è§£æ³•ä¼šå¯¼è‡´è¶…æ—¶ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦é…åˆç¼“å­˜ï¼Œæ¥æ±‚è§£è¿™ä¸ªé—®é¢˜ï¼š

@[code](../code/329.py)

### LC841 é’¥åŒ™å’Œæˆ¿é—´

> æœ‰ N ä¸ªæˆ¿é—´ï¼Œå¼€å§‹æ—¶ä½ ä½äº 0 å·æˆ¿é—´ã€‚æ¯ä¸ªæˆ¿é—´æœ‰ä¸åŒçš„å·ç ï¼š0ï¼Œ1ï¼Œ2ï¼Œ...ï¼ŒN-1ï¼Œå¹¶ä¸”æˆ¿é—´é‡Œå¯èƒ½æœ‰ä¸€äº›é’¥åŒ™èƒ½ä½¿ä½ è¿›å…¥ä¸‹ä¸€ä¸ªæˆ¿é—´ã€‚
>
> åœ¨å½¢å¼ä¸Šï¼Œå¯¹äºæ¯ä¸ªæˆ¿é—´ i éƒ½æœ‰ä¸€ä¸ªé’¥åŒ™åˆ—è¡¨ rooms[i]ï¼Œæ¯ä¸ªé’¥åŒ™ rooms[i][j] ç”± [0,1ï¼Œ...ï¼ŒN-1] ä¸­çš„ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºï¼Œå…¶ä¸­ N = rooms.lengthã€‚ é’¥åŒ™ rooms[i][j] = v å¯ä»¥æ‰“å¼€ç¼–å·ä¸º v çš„æˆ¿é—´ã€‚
>
> æœ€åˆï¼Œé™¤ 0 å·æˆ¿é—´å¤–çš„å…¶ä½™æ‰€æœ‰æˆ¿é—´éƒ½è¢«é”ä½ã€‚
>
> ä½ å¯ä»¥è‡ªç”±åœ°åœ¨æˆ¿é—´ä¹‹é—´æ¥å›èµ°åŠ¨ã€‚
>
> å¦‚æœèƒ½è¿›å…¥æ¯ä¸ªæˆ¿é—´è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
>
> æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
> é“¾æ¥ï¼š<https://leetcode-cn.com/problems/keys-and-rooms>
> è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

å…¶ DFS è§£æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        visited = set()
        num = 0

        def dfs(i: int):
            visited.add(i)
            nonlocal num
            num += 1
            for it in rooms[i]:
                if it not in visited:
                    dfs(it)

        dfs(0)
        return num == n
```

å¦‚æœè¿™ä¸ªä¸å¥½ç†è§£ï¼Œå¯ä»¥å‚è€ƒå¦‚ä¸‹ DFS è§£æ³•ï¼š

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = set()
        visited.add(0)
        
        def dfs(i, visited):
            visited.add(i)
            for key in rooms[i]:
                if key not in visited:
                    visited.add(key)
                    dfs(key, visited)
        
        dfs(0, visited)
        return len(visited) == len(rooms)
```

äºŒåˆ·çš„è§£æ³•æ›´åŠ ç®€æ´ï¼š

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = set()
        def dfs(i: int):
            visited.add(i)
            for key in rooms[i]:
                if key not in visited:
                    visited.add(key)
                    dfs(key)
                    
        dfs(0)
        return len(visited) == len(rooms)
```

ä½¿ç”¨ `stack` çš„è§£æ³•å¦‚ä¸‹ï¼š

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = set()
        visited.add(0)
        stack = [0]

        while stack:
            idx = stack.pop()
            for key in rooms[idx]:
                if key not in visited:
                    visited.add(key)
                    stack.append(key)
        return len(rooms) == len(visited)
```

è¿˜æœ‰ BFS è§£æ³•ï¼Œå¯å‚è€ƒä¸‹æ–‡ã€‚

### LC200 å²›å±¿æ•°é‡

> ç»™ä½ ä¸€ä¸ªç”± '1'ï¼ˆé™†åœ°ï¼‰å’Œ '0'ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚
>
> å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚
>
> æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚
>
> 
>
> ç¤ºä¾‹ 1ï¼š
>
> ```
> è¾“å…¥ï¼šgrid = [
> ["1","1","1","1","0"],
> ["1","1","0","1","0"],
> ["1","1","0","0","0"],
> ["0","0","0","0","0"]
> ]
> ```
>
> è¾“å‡ºï¼š1
>
> æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
>
> é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/number-of-islands
>
> è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

DFS è§£æ³•å¦‚ä¸‹ï¼š

```python
class Solution:

    def dfs(self, grid, i, j):
        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#'
        self.dfs(grid, i + 1, j)
        self.dfs(grid, i - 1, j)
        self.dfs(grid, i, j + 1)
        self.dfs(grid, i, j - 1)

    def numIslands(self, grid):
        count = 0

        if not grid:
            return count
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    self.dfs(grid, i, j) # mark the visited
                    count += 1
        return count
```

### LC386 å­—å…¸åºæ’æ•°

> è¾“å…¥ï¼šn = 13
>
> è¾“å‡ºï¼š[1,10,11,12,13,2,3,4,5,6,7,8,9]

<https://leetcode-cn.com/problems/lexicographical-numbers/>

å…¶ DFS çš„é€’å½’è§£æ³•å¦‚ä¸‹ï¼š

```python
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res = []

        def dfs(cur: int):
            if cur > n:
                return
            res.append(cur)
            for _ in range(10):
                dfs(cur * 10 + _)

        for i in range(1, 10):
            dfs(i)
        return res
```

æ³¨æ„åˆ°ä¸Šè¿°ä»£ç ï¼Œæˆ‘ä»¬åœ¨å¤–å±‚å¾ªç¯é€’å½’çš„æ—¶å€™ä» `1` å¼€å§‹è€Œä¸æ˜¯ä» `0` å¼€å§‹ï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦é€’å½’ `0` å¼€å¤´çš„ã€‚

ä½†æ˜¯é¢˜ç›®ä¸­è¦æ±‚äº†ä½ å¿…é¡»è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º `O(n)` ä¸”ä½¿ç”¨ `O(1)` é¢å¤–ç©ºé—´çš„ç®—æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å°è¯•ä½¿ç”¨è¿­ä»£çš„æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

```python
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res = [0] * n
        num = 1
        for i in range(n):
            res[i] = num
            if num * 10 <= n:
                num *= 10
            else:
                while num % 10 == 9 or num + 1 > n:
                    num //= 10
                num += 1
        return res
```

è¿™ç§è§£æ³•çš„æ ¸å¿ƒåœ¨äºåˆ¤æ–­æœ«å°¾æ˜¯å¦å·²ç»æœç´¢å®Œæˆï¼Œæœç´¢å®Œæˆçš„è¯é€€å›ä¸Šä¸€ä½ã€‚

### LC417 å¤ªå¹³æ´‹å¤§è¥¿æ´‹æ°´æµé—®é¢˜

é¢˜ç›®æè¿°è§ <https://leetcode-cn.com/problems/pacific-atlantic-water-flow/>, ç®€å•æ¦‚æ‹¬ä¸€ä¸‹ï¼Œè¿™ä¸ªé¢˜ç›®å°±æ˜¯ç»™ä½ ä¸€ä¸ªäºŒç»´çš„çŸ©é˜µï¼Œç„¶åçœ‹è¿™ä¸ªäºŒç»´çŸ©é˜µä¸­çš„å…ƒç´ æ˜¯ä¸æ˜¯éƒ½å¯ä»¥åˆ°å¤ªå¹³æ´‹å’Œå¤§è¥¿æ´‹ï¼Œå…¶ä¸­å¤ªå¹³æ´‹åœ¨çŸ©é˜µçš„å·¦è¾¹å’Œä¸Šè¾¹ç¯ç»•ï¼Œå¤§è¥¿æ´‹åœ¨çŸ©é˜µçš„å³è¾¹å’Œä¸‹è¾¹ç¯ç»•ã€‚

#### DFS

æˆ‘ä»¬ç»™å‡ºè¿™ä¸ªé—®é¢˜çš„ DFS è§£æ³•ï¼š

```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        # æ°´å¿…é¡»æµè¿›å¤§è¥¿æ´‹ and å¤ªå¹³æ´‹
        m, n = len(heights), len(heights[0])

        def search(starts: List):
            visited = set()

            def dfs(x: int, y: int):
                if (x, y) in visited:
                    return
                visited.add((x, y))
                for nx, ny in ((x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)):
                    if 0 <= nx < m and 0 <= ny < n \
                            and heights[nx][ny] >= heights[x][y]:
                        dfs(nx, ny)

            for x, y in starts:
                dfs(x, y)

            return visited
        # ä»çŸ©é˜µçš„ä¸Šè¾¹ç•Œå’Œå·¦è¾¹ç•Œå¼€å§‹æœç´¢, (0, 0) ä¸é‡å¤åŠ 
        # [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 0), (2, 0), (3, 0), (4, 0)]
        pacific = [(0, i) for i in range(n)] + [(i, 0) for i in range(1, m)]

        # ä»çŸ©é˜µçš„ä¸‹è¾¹ç•Œå’Œå³è¾¹ç•Œå¼€å§‹
        atlantic = [(m - 1, i) for i in range(n)] + [(i, n - 1) for i in range(m - 1)]

        return list(map(list, search(pacific) & search(atlantic)))
```

è¿™ä¸ªé¢˜ç›®ä¸­ç”¨åˆ°äº†ä¸€ç§â€œåå‘æœç´¢â€çš„æ¦‚å¿µï¼Œå…¶å®æœ¬è´¨æ¥è¯´ï¼Œå°±æ˜¯ä»çŸ©é˜µè¾¹ç•Œè¿›è¡Œæœç´¢ã€‚æ ¹ç»é¢˜ç›®å«ä¹‰ï¼Œåå‘æœç´¢çš„æ—¶å€™ï¼Œæ¯æ¬¡åªèƒ½ç§»åŠ¨åˆ°é«˜åº¦ç›¸åŒæˆ–è€…é«˜åº¦æ›´å¤§çš„å•å…ƒæ ¼ã€‚

æ³¨æ„åˆ°æˆ‘ä»¬çš„åˆå§‹åŒ–ï¼Œpacific å’Œ atlantic å‡è¡¨ç¤ºè¾¹ç•Œå…ƒç´ çš„åæ ‡ã€‚

#### BFS

æˆ‘ä»¬ç»™å‡ºè¿™ä¸ªé—®é¢˜çš„ BFS è§£æ³•ï¼š

```python
    def pacificAtlanticBfs(self, heights: List[List[int]]) -> List[List[int]]:
        # æ°´å¿…é¡»æµè¿›å¤§è¥¿æ´‹ and å¤ªå¹³æ´‹
        m, n = len(heights), len(heights[0])

        def bfs(starts: List):
            visited = set(starts)
            q = collections.deque(starts)
            while q:
                x, y = q.popleft()
                for nx, ny in ((x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)):
                    if 0 <= nx < m and 0 <= ny < n \
                            and heights[nx][ny] >= heights[x][y] \
                            and (nx, ny) not in visited:
                        visited.add((nx, ny))
                        q.append((nx, ny))
            return visited

        pacific = [(0, i) for i in range(n)] + [(i, 0) for i in range(1, m)]
        atlantic = [(m - 1, i) for i in range(n)] + [(i, n - 1) for i in range(m - 1)]

        return list(map(list, bfs(pacific) & bfs(atlantic)))
```

#### Testcase

å…¶å¯¹åº”çš„æµ‹è¯•ç”¨ä¾‹å¦‚ä¸‹ï¼š

```python
class Test(unittest.TestCase):
    def setUp(self) -> None:
        self.s = Solution()

    def test01(self):
        heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]
        res = self.s.pacificAtlantic(heights)
        print(res)
        self.assertCountEqual([[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]], res)
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ `self.assertCountEqual` è¡¨ç¤º list çš„é¡ºåºä¸åŒï¼Œä½†æ˜¯å…¶ä¸­çš„å…ƒç´ å‡ºç°ä¸ªæ•°ç›¸ç­‰ã€‚



## BFS

### æ¦‚è§ˆ

:::tip æ¦‚è§ˆ

1. BFS é—®é¢˜çš„æœ¬è´¨å°±æ˜¯è®©ä½ åœ¨ä¸€å‰¯â€œå›¾â€ä¸­æ‰¾åˆ°ä»èµ·ç‚¹ start åˆ°ç»ˆç‚¹ target çš„æœ€è¿‘è·ç¦»ï¼›
2. BFS çš„æ ¸å¿ƒæ•°æ®ç»“æ„æ˜¯é˜Ÿåˆ—ï¼›
3. BFS å¸¸ç”¨ visited ç»“æ„æ¥æ ‡è®°æ˜¯å¦èµ°è¿‡æŸæ®µè·¯ç¨‹ï¼Œé¿å…èµ°å›å¤´è·¯ï¼›
4. BFS åœ¨é˜Ÿåˆ—åˆå§‹åŒ–çš„æ—¶å€™ä¸€èˆ¬ä¼šåŠ å…¥å°†èµ·ç‚¹åŠ å…¥é˜Ÿåˆ—ä¸­ï¼›
5. åœ¨å†™ BFS å‰è¦æ˜ç¡®ç»ˆæ­¢æ¡ä»¶ã€‚

:::


### LC841 é’¥åŒ™å’Œæˆ¿é—´

å¾ˆç»å…¸çš„ä¸€é“é¢˜ç›®ï¼Œä»ä¸¾ä¾‹çœ‹ä¸€ä¸‹è¿™é“é¢˜ç›®ï¼š

> è¾“å…¥ï¼š[[1,3],[3,0,1],[2],[0]]
>
> è¾“å‡ºï¼šfalse
>
> è§£é‡Šï¼šæˆ‘ä»¬ä¸èƒ½è¿›å…¥ 2 å·æˆ¿é—´ã€‚

åˆå§‹çš„æ—¶å€™æ˜¯å¯ä»¥è¿›å…¥ 0 å·æˆ¿é—´çš„ï¼Œç„¶åçœ‹èƒ½ä¸èƒ½æ ¹æ®è¿™ä¸ªæˆ¿é—´çš„é’¥åŒ™æŠŠæ¯ä¸ªæˆ¿é—´éƒ½èµ°äº†ã€‚

ä¸‹é¢æ˜¯ä¸Šè¿°é—®é¢˜çš„ BFS è§£æ³•ï¼š

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        queue = collections.deque([0])
        visited = {0}

        while queue:
            x = queue.popleft()
            for it in rooms[x]:
                if it not in visited:
                    visited.add(it)
                    queue.append(it)
        return len(visited) == n
```

### LC200 å²›å±¿æ•°é‡

> é¢˜ç›®æè¿°è§ DFS æè¿°ã€‚

BFS è§£æ³•å¦‚ä¸‹ï¼š

```python
class Solution:
    def numIslands(self, grid):
        row = len(grid)
        if not row:
            return 0
        col = len(grid[0])
        res = 0
        for r in range(row):
            for c in range(col):
                if grid[r][c] == '1':
                    # å¼€å§‹ BFS
                    res += 1
                    q = collections.deque([(r, c)])
                    while q:
                        nr, nc = q.popleft()
                        for x, y in [(nr - 1, nc), (nr, nc - 1), (nr + 1, nc), (nr, nc + 1)]:
                            if 0 <= x < row and 0 <= y < col and grid[x][y] == '1':
                                q.append((x, y))
                                grid[x][y] = '0'
        return res
```

### LC210 è¯¾ç¨‹è¡¨

[210. è¯¾ç¨‹è¡¨ II](https://leetcode-cn.com/problems/course-schedule-ii/)

> ç°åœ¨ä½ æ€»å…±æœ‰ numCourses é—¨è¯¾éœ€è¦é€‰ï¼Œè®°ä¸º 0 åˆ° numCourses - 1ã€‚ç»™ä½ ä¸€ä¸ªæ•°ç»„ prerequisites ï¼Œå…¶ä¸­ prerequisites[i] = [ai, bi] ï¼Œè¡¨ç¤ºåœ¨é€‰ä¿®è¯¾ç¨‹ ai å‰ å¿…é¡» å…ˆé€‰ä¿® bi ã€‚
>
> ä¾‹å¦‚ï¼Œæƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºï¼š[0,1] ã€‚
>
> è¿”å›ä½ ä¸ºäº†å­¦å®Œæ‰€æœ‰è¯¾ç¨‹æ‰€å®‰æ’çš„å­¦ä¹ é¡ºåºã€‚å¯èƒ½ä¼šæœ‰å¤šä¸ªæ­£ç¡®çš„é¡ºåºï¼Œä½ åªè¦è¿”å› ä»»æ„ä¸€ç§ å°±å¯ä»¥äº†ã€‚å¦‚æœä¸å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹ï¼Œè¿”å› ä¸€ä¸ªç©ºæ•°ç»„ ã€‚
>
> 
>
> **ç¤ºä¾‹ 1**ï¼š
>
> - è¾“å…¥ï¼šnumCourses = 2, prerequisites = [[1,0]]
> - è¾“å‡ºï¼š[0,1]
> - è§£é‡Šï¼šæ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚è¦å­¦ä¹ è¯¾ç¨‹ 1ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 0ã€‚å› æ­¤ï¼Œæ­£ç¡®çš„è¯¾ç¨‹é¡ºåºä¸º [0,1] ã€‚
>
> **ç¤ºä¾‹ 2**ï¼š
>
> - è¾“å…¥ï¼šnumCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
> - è¾“å‡ºï¼š[0,2,1,3]
> - è§£é‡Šï¼šæ€»å…±æœ‰ 4 é—¨è¯¾ç¨‹ã€‚è¦å­¦ä¹ è¯¾ç¨‹ 3ï¼Œä½ åº”è¯¥å…ˆå®Œæˆè¯¾ç¨‹ 1 å’Œè¯¾ç¨‹ 2ã€‚å¹¶ä¸”è¯¾ç¨‹ 1 å’Œè¯¾ç¨‹ 2 éƒ½åº”è¯¥æ’åœ¨è¯¾ç¨‹ 0 ä¹‹åã€‚
>   å› æ­¤ï¼Œä¸€ä¸ªæ­£ç¡®çš„è¯¾ç¨‹é¡ºåºæ˜¯ [0,1,2,3] ã€‚å¦ä¸€ä¸ªæ­£ç¡®çš„æ’åºæ˜¯ [0,2,1,3] ã€‚
>
> æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
> é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/course-schedule-ii
> è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

è¿™é“é¢˜ç›®æ¯”è¾ƒç»¼åˆï¼Œå‡ºçš„è¿˜æ˜¯å¾ˆä¸é”™çš„ï¼Œæˆ‘ä»¬æ•´ç†æ€è·¯å¦‚ä¸‹ï¼š

1. æˆ‘ä»¬åˆå§‹åŒ–æ¯ä¸ªè¯¾ç¨‹ï¼ŒæŒ‰ç…§ index æŠŠèŠ‚ç‚¹çš„å…¥åº¦å…¨éƒ¨åˆå§‹åŒ–ä¸º 0, æ³¨æ„åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦æˆ‘ä»¬éƒ½è®¡ç®—ä¸€ä¸‹ã€‚
2. æˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ª dict, key æ˜¯è¿™ä¸ªèŠ‚ç‚¹ï¼Œvalue æ˜¯å’Œè¿™ä¸ªèŠ‚ç‚¹çš„å‰é©±
3. ç„¶åå¯¹æ•´ä½“ä½¿ç”¨ BFS

æ¯”å¦‚ `[1,0]` è¿™å¯¹æ•°æ®ï¼Œ1 çš„å…¥åº¦è¿™æ—¶å€™éœ€è¦ +1, è€Œåœ¨å­—å…¸ä¸­æˆ‘ä»¬å°† 1 çš„å‰é©± 0 ï¼ˆå¤šä¸ªå‰é©±ç”¨åˆ—è¡¨ä¿å­˜ï¼‰å­˜å‚¨èµ·æ¥ã€‚


```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        res = []
        edges = collections.defaultdict(list)
        # å­˜å‚¨èŠ‚ç‚¹çš„å…¥åº¦
        indeg = [0] * numCourses

        # é€‰ä¿® ai å‰å¿…é¡»å…ˆé€‰ä¿® bi
        for ai, bi in prerequisites:
            indeg[ai] += 1
            edges[bi].append(ai)

        # å°†æ‰€æœ‰å…¥åº¦ä¸º0çš„èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­
        q = collections.deque([_ for _ in range(numCourses) if indeg[_] == 0])

        # bfs
        while q:
            node = q.popleft()
            res.append(node)
            for v in edges[node]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)

        if len(res) != numCourses:
            return list()
        return res
```

### LC977 æ‰¾åˆ°å°é•‡çš„æ³•å®˜

[997. æ‰¾åˆ°å°é•‡çš„æ³•å®˜](https://leetcode-cn.com/problems/find-the-town-judge/)

è¿™é“é¢˜ç›®ä¸LC210 ç±»ä¼¼ï¼Œéƒ½æ˜¯å…³äºå…¥åº¦å’Œå‡ºåº¦çš„ã€‚

> åœ¨ä¸€ä¸ªå°é•‡é‡Œï¼ŒæŒ‰ä» 1 åˆ° n ä¸º n ä¸ªäººè¿›è¡Œç¼–å·ã€‚ä¼ è¨€ç§°ï¼Œè¿™äº›äººä¸­æœ‰ä¸€ä¸ªæ˜¯å°é•‡ä¸Šçš„ç§˜å¯†æ³•å®˜ã€‚
>
> å¦‚æœå°é•‡çš„æ³•å®˜çœŸçš„å­˜åœ¨ï¼Œé‚£ä¹ˆï¼š
>
> å°é•‡çš„æ³•å®˜ä¸ç›¸ä¿¡ä»»ä½•äººã€‚
>
> æ¯ä¸ªäººï¼ˆé™¤äº†å°é•‡æ³•å®˜å¤–ï¼‰éƒ½ä¿¡ä»»å°é•‡çš„æ³•å®˜ã€‚
>
> åªæœ‰ä¸€ä¸ªäººåŒæ—¶æ»¡è¶³æ¡ä»¶ 1 å’Œæ¡ä»¶ 2 ã€‚
>
> ç»™å®šæ•°ç»„ trustï¼Œè¯¥æ•°ç»„ç”±ä¿¡ä»»å¯¹ trust[i] = [a, b] ç»„æˆï¼Œè¡¨ç¤ºç¼–å·ä¸º a çš„äººä¿¡ä»»ç¼–å·ä¸º b çš„äººã€‚
>
> å¦‚æœå°é•‡å­˜åœ¨ç§˜å¯†æ³•å®˜å¹¶ä¸”å¯ä»¥ç¡®å®šä»–çš„èº«ä»½ï¼Œè¯·è¿”å›è¯¥æ³•å®˜çš„ç¼–å·ã€‚å¦åˆ™ï¼Œè¿”å› -1ã€‚
>
> 
>
> ç¤ºä¾‹ 1ï¼š
>
> è¾“å…¥ï¼šn = 2, trust = [[1,2]]
>
> è¾“å‡ºï¼š2
>
> 
>
> ç¤ºä¾‹ 2ï¼š
>
> è¾“å…¥ï¼šn = 3, trust = [[1,3],[2,3]]
>
> è¾“å‡ºï¼š3
>
> æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
> é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/find-the-town-judge
> è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

```python
class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        trust_in = [0] * (n + 1)
        trust_out = [0] * (n + 1)
        for me, other in trust:
            # æˆ‘ä¿¡ä»»äº†åˆ«äºº
            trust_out[me] += 1
            # åˆ«äººä¿¡ä»»äº†æˆ‘
            trust_in[other] += 1

        for i in range(1, n + 1):
            if trust_in[i] == n - 1 and trust_out[i] == 0:
                return i
        return -1
```

### LC752 æ‰“å¼€è½¬ç›˜é”

[752. æ‰“å¼€è½¬ç›˜é”](https://leetcode-cn.com/problems/open-the-lock/)

é—®é¢˜åˆ†æï¼š

- æˆ‘ä»¬å¯ä»¥å®šä¹‰ add, minus æ¥è¡¨ç¤ºè½¬ç›˜å¯†ç  +1 æˆ–è€… -1 çš„æ“ä½œï¼Œæ³¨æ„åˆ° 0ã€9 è¿™äº›è¾¹ç•Œå€¼ï¼Œå°†è¿™ä¸ªæ“ä½œå•ç‹¬æ‹å‡ºæ¥ã€‚

- ä»é¢˜ç›®ä¸­æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œæœ‰ä¸€äº›å¯†ç çš„ç»„åˆæ˜¯ä¸èƒ½è½¬åˆ°çš„ï¼Œä¸ç„¶å°±ç®—å¤±è´¥äº†ï¼Œè€Œä¸ºäº†è¾¾åˆ°ä¸è®¿é—®è¿™äº›ç»„åˆçš„æ•ˆæœï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¿™äº›ç»„åˆå’Œ visited æ•°ç»„æ”¾åˆ°ä¸€èµ·ã€‚
- å¯¹è¿™ä¸ªé—®é¢˜è¿›è¡ŒæŠ½è±¡ï¼Œä¸€ä¸ªé”å…±æœ‰ 4 ä¸ªä½ç½®ï¼Œæ¯ä¸ªä½ç½®éƒ½å¯ä»¥å‘ä¸‹æˆ–è€…å‘ä¸Šè½¬åŠ¨ï¼Œæ‰€ä»¥æ¯ä¸ªä½ç½®éƒ½æœ‰ 2 ç§è½¬åŠ¨çš„å¯èƒ½ï¼Œ4 ä¸ªä½ç½®å…±æœ‰ 8 ä¸ªå¯èƒ½ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œâ€˜xxxxâ€™ è¿™ä¸ªç»„åˆå¯¹åº”ç€ 8 ç§ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼Œ8 ç§ä¸‹ä¸€ä¸ªçŠ¶æ€ä¸­çš„æ¯ä¸€ä¸ªä¹Ÿæ˜¯è¿™æ ·çš„ç»“æ„ï¼Œå¯¹åº” 8 ç§ä¸‹ä¸€ä¸ªçŠ¶æ€â€¦ *è¿™å°±åƒæ˜¯ä¸€å¹…å›¾ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ 8 ä¸ªç›¸é‚»çš„èŠ‚ç‚¹*ã€‚

ç¼–ç ï¼š

1. å…ˆå†™åŸºç¡€çš„ add, minus æ–¹æ³•

   ```python
   def add(num: str):
       return '0' if num == '9' else str(int(num) + 1)
   
   def minus(num: str):
       return '9' if num == '0' else str(int(num) - 1)
   ```

2. é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å†™ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œè®¡ç®—æŸä¸ªçŠ¶æ€åœ¨ä¸€æ¬¡æ‹¨åŠ¨ä»¥åèƒ½åˆ°è¾¾çš„æ‰€æœ‰ä¸‹ä¸€ä¸ªçŠ¶æ€(å‰é¢åˆ†æè¿‡ï¼Œè¿™ä¸ªçŠ¶æ€æœ‰ 8 ä¸ª)ï¼Œå¦‚`0000`å¯ä»¥åˆ°è¾¾çš„ `1000`, `0100`ç­‰ã€‚

   è¿™ä¸ªåœ¨ Python ä¸­æœ‰å¾ˆå¤šå†™æ³•ï¼Œå…¶ä¸­æœ€å®¹æ˜“ç†è§£çš„å†™æ³•ä¸ºï¼š

   ```python
   # ç»™å®šä¸€ä¸ª status, è®¡ç®—å‡ºæ¥ä»–èƒ½æ‹¨åˆ°çš„æ‰€æœ‰ 8 ä¸ª status
   def get_status(status: str) -> List[str]:
       # list æ–¹ä¾¿èµ‹å€¼
       status_list = list(status)
       res = []
       for i in range(4):
           # å­˜å‚¨èµ·æ¥ï¼Œç­‰å¤ä½
           tmp = status_list[i]
           up = add(status[i])
           status_list[i] = up
           res.append(''.join(status_list))
   
           down = minus(status[i])
           status_list[i] = down
           res.append(''.join(status_list))
   
           # å¤ä½
           status_list[i] = tmp
           return res
   ```

   æ¯”è¾ƒé«˜çº§çš„æŠ€å·§æ˜¯ä½¿ç”¨ `yield ` ç”Ÿæˆå™¨ï¼Œåœ¨æ­¤ç»™ä¸ªå‚è€ƒï¼š

   ```python
   def get(status: str):
       status_list = list(status)
       for i in range(4):
           tmp = status_list[i]
           
           status_list[i] = add(tmp)
           yield ''.join(status_list)
           
           status_list[i] = minus(tmp)
           yield ''.join(status_list)
           
           status_list[i] = tmp
   ```

   

3. å¥—ç”¨ BFS æ¡†æ¶ã€‚

   æ ¹æ®é¢˜æ„ï¼Œé”çš„åˆå§‹æ•°å­—ä¸º `'0000'`ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨é˜Ÿåˆ—ä¸­å°†è¿™ä¸ªå…ƒç´ åˆå§‹åŒ–è¿›å»ã€‚

   ::: warning å…³äºé˜Ÿåˆ—åˆå§‹åŒ–çš„åŸºæœ¬è¯­æ³•æŠ€å·§ï¼Œéœ€è¦æ³¨æ„

   Python ä¸­æˆ‘ä»¬ä¸€èˆ¬è¿™ä¹ˆåˆå§‹åŒ–é˜Ÿåˆ—ï¼š`q = collections.deque([1])`

   âŒğŸš«âŒ `q = collections.deque(1)` æ˜¯é”™è¯¯çš„ï¼ä¼šæŠ¥é”™ *TypeError: 'int' object is not iterable.*

   

   è€Œåœ¨æ·»åŠ çš„æ—¶å€™ï¼Œç›´æ¥ä½¿ç”¨ `q.append(2)` å³å¯ï¼Œè¿™æ—¶å€™ç»“æœæ˜¯ `[1,2]`ï¼›

   âŒğŸš«âŒ ä¸¾ä¸ªåä¾‹ï¼Œå¦‚æœè§‰å¾—ä¸€æ¬¡å¯ä»¥æ·»åŠ å¤šä¸ªï¼š`q.append([3,4])`, å°±ä¼šå¾—åˆ°è¿™æ ·çš„ç»“æœï¼š`deque([1, 2, [3, 4]])`!

   

   ä¸€èˆ¬è€Œè¨€ï¼Œæˆ‘ä»¬åœ¨æ±‚è§£ BFS é—®é¢˜çš„æ—¶å€™ï¼Œä¼šç»™æ¯ä¸ªå€™é€‰é¡¹åŠ ä¸Šå…¶å¯¹åº”çš„æ¬¡æ•°ï¼Œæ”¾åœ¨ä¸€ä¸ªå…ƒç»„ä¸­ï¼Œå…¶åˆå§‹åŒ–å°±ç±»ä¼¼äºè¿™æ ·ï¼š`q = collections.deque([('0000', 1)])`, è¿™ç§åšæ³•ä¸åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„é˜Ÿåˆ—ï¼Œç„¶åå°†å…ƒç»„ `('0000', 1)` æ·»åŠ è¿›å»æ˜¯ç›¸åŒçš„æ•ˆæœ(LC111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ ä½¿ç”¨äº†è¿™ä¸ªå†™æ³•)ã€‚

   :::

   ç»“åˆä¸Šé¢çš„åˆ†æï¼Œæˆ‘ä»¬å¥—ç”¨ BFS çš„æ¡†æ¶å¯ä»¥å¾—å‡ºæ±‚è§£è¯¥é¢˜ç›®çš„ä¸»é¢˜æ¡†æ¶ï¼š

   ```python
   q = collections.deque([('0000', 1)])
   visited = {'0000'}
   # å°† deadends è¿™ä¸ª list æ·»åŠ åˆ° visited è¿™ä¸ª set ä¸­
   visited |= set(deadends)
   # è¿™ç§æ–¹æ³•åŒç†
   # visited.update(deadends)
   while q:
       status, step = q.popleft()
       for state in get_status(status):
           if state not in visited:
               if state == target:
                   return step
               visited.add(state)
               q.append((state, step + 1))
               return -1
   ```

   ä¸Šè¿°ä»£ç ä¸­æœ‰å‡ ä¸ªç»†èŠ‚éœ€è¦æ³¨æ„ï¼š

   - åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œæˆ‘ä»¬åˆå§‹åŒ–é˜Ÿåˆ—ä¸º `('0000', 1)`ï¼Œæœ€ç»ˆåœ¨æ‰¾åˆ°ç›®æ ‡åè¿”å›äº† `step`ï¼›å…¶å®æˆ‘ä»¬åˆå§‹åŒ–ä¸º `('0000', 0)`ï¼Œåœ¨æ‰¾åˆ°ç›®æ ‡åè¿”å› `step + 1`ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚

   - â“â“â“ å¦‚ä½•å°†ä¸€ä¸ª list å…¨éƒ¨åŠ å…¥ set ä¸­å‘¢ï¼Ÿæœ‰ä¸¤ç§åšæ³•:

     1. `visited |= set(deadends)`

     2. `visited.update(deadends)`

     

4. ç‰¹æ®Šåœºæ™¯è€ƒè™‘

   é™¤äº†ä¸Šè¿°çš„è§£æ³•ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è€ƒè™‘åˆ°å‡ ç§ç‰¹æ®Šåœºæ™¯çš„ç”¨ä¾‹ï¼š

   ```python
   # å¤„ç†å¼‚å¸¸åœºæ™¯
   if '0000' in deadends:
       return -1
   if target == '0000':
       return 0
   ```

### LC133 å…‹éš†å›¾

[133. å…‹éš†å›¾](https://leetcode-cn.com/problems/clone-graph/)

> ç»™ä½ æ— å‘ **[è¿é€š](https://baike.baidu.com/item/è¿é€šå›¾/6460995?fr=aladdin)** å›¾ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨ï¼Œè¯·ä½ è¿”å›è¯¥å›¾çš„ [**æ·±æ‹·è´**](https://baike.baidu.com/item/æ·±æ‹·è´/22785317?fr=aladdin)ï¼ˆå…‹éš†ï¼‰ã€‚

åˆçœ‹è¿™ä¸ªé¢˜ç›®ï¼Œå¾ˆéš¾å°†å…¶å’Œ BFS å…³è”åˆ°ï¼Œæˆ‘ä»¬è¿›è¡Œåˆ†æï¼š

```txt
è¾“å…¥ï¼šadjList = [[2,4],[1,3],[2,4],[1,3]]

è¾“å‡ºï¼š[[2,4],[1,3],[2,4],[1,3]]
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œé¢˜ç›®æ˜¯ç»™å‡ºäº†é‚»æ¥è¡¨ï¼Œè®©æˆ‘ä»¬æŒ‰ç…§è¿™ä¸ªé‚»æ¥è¡¨å¯¹å›¾è¿›è¡Œæ·±æ‹·è´ã€‚è¿™ä¸ªé‚»æ¥è¡¨çš„å«ä¹‰æ˜¯ï¼š`[2,4]` è¡¨ç¤ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹ `1`çš„é‚»å±…ä¸ºèŠ‚ç‚¹ `2` å’ŒèŠ‚ç‚¹ `4`ï¼ˆèŠ‚ç‚¹ index ä» 1 å¼€å§‹ï¼‰ï¼Œä»¥æ­¤ç±»æ¨ã€‚

ğŸˆğŸˆğŸˆ æ€è€ƒã€‚

ä»è¿™ä¸ªé¢˜ç›®ä¸­ï¼Œæˆ‘ä»¬è¦æ˜ç™½ï¼š**BFS è®¾ç«‹ä¹‹åˆå°±æ˜¯ä¸ºçš„å›¾çš„éå†**ï¼Œè¿™ä¸ªé¢˜ç›®çœŸå¯è°“æ˜¯è¿”ç’å½’çœŸã€‚

é‚£ä¹ˆï¼Œæˆ‘ä»¬è¦æ€ä¹ˆæ·±æ‹·è´è¿™ä¸ªå›¾å‘¢ï¼Ÿ

1. æˆ‘ä»¬è§£æé‚»æ¥è¡¨ï¼Œé‚»æ¥è¡¨çš„ä¸¤ä¸ªæ— å‘è¾¹å¯ä»¥ç¡®å®šä¸€ä¸ªæœ‰å‘è¾¹ã€‚
2. æˆ‘ä»¬çŸ¥é“äº†é‚»æ¥è¡¨ï¼Œä½†æ˜¯å¦‚æœç›´æ¥è§£æï¼Œå¯èƒ½ä¼šè¿›å…¥æ­»å¾ªç¯ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ `visited` æ•°ç»„æ¥è¿›è¡Œæ ‡è®°ã€‚

å¦‚ä½•è®¾è®¡ç®—æ³•ï¼š

1. ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨æ¥è®°å½• visited è¿‡çš„èŠ‚ç‚¹ã€‚å°† key è®¾ç½®ä¸ºåŸå§‹å›¾ä¸­çš„èŠ‚ç‚¹ï¼Œ value è®¾ç½®ä¸ºå…‹éš†å›¾ä¸­å¯¹åº”çš„èŠ‚ç‚¹ã€‚

2. é¢˜ç›®ä¸­ç»™å®šçš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼Œå…‹éš†è¯¥èŠ‚ç‚¹å¹¶ä¸”å­˜å‚¨åˆ°å“ˆå¸Œè¡¨ä¸­ã€‚

```python
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return node

        q = collections.deque([node])
        visited = dict()
        visited[node] = Node(node.val, [])

        while q:
            head = q.popleft()
            for neighbor in head.neighbors:
                if neighbor not in visited.keys():
                    q.append(neighbor)
                    visited[neighbor] = Node(neighbor.val, [])
                visited[head].neighbors.append(visited[neighbor])
        return visited[node]
```

è¿™ä¸ªé¢˜ç›®è¾ƒä¸ºå¤æ‚ï¼Œè¿˜éœ€è¦å¤šå¤šç†è§£ï¼

### LC2039 ç½‘ç»œç©ºé—²çš„æ—¶åˆ»

è¿™ä¸ªé¢˜ç›®[æè¿°](https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/)æ¯”è¾ƒå¤æ‚ï¼Œæ ¸å¿ƒæ€è·¯æ˜¯ä½¿ç”¨ BFS å¯¹å›¾è¿›è¡Œéå†ï¼Œçœ‹ä»£ç ï¼š

```python
class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        n = len(patience)
        g = collections.defaultdict(list)
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)
            
        q = collections.deque([0])
        visited = [True] + [False] * (n-1)
        res = 0
        dist = 1
        while q:
            for _ in range(len(q)):
                u = q.popleft()
                for v in g[u]:
                    if visited[v]:  
                        continue
                    visited[v] = True
                    q.append(v)
                    res = max(res, (dist * 2 - 1) //
                            patience[v] * patience[v] + dist * 2 + 1)
            dist += 1
        return res
```


å…¶å¯¹åº”çš„æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š

```python
class Test(unittest.TestCase):
    def setUp(self):
        self.s = Solution()

    def test(self):
        edges = [[0, 1], [1, 2]]
        patience = [0, 2, 1]
        res = self.s.networkBecomesIdle(edges, patience)
        print(res)

    def test2(self):
        edges = [[5, 7], [15, 18], [12, 6], [5, 1], [11, 17], [3, 9], [6, 11], [14, 7], [19, 13], [13, 3], [
            4, 12], [9, 15], [2, 10], [18, 4], [5, 14], [17, 5], [16, 2], [7, 1], [0, 16], [10, 19], [1, 8]]
        patience = [0, 2, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1]
        res = self.s.networkBecomesIdle(edges, patience)
        self.assertEqual(67, res)
```

### LC365 æ°´å£¶é—®é¢˜

ä¸¤ä¸ªæ°´å£¶ x, y å’Œæ— é™å¤šçš„æ°´ï¼Œèƒ½å¦é€šè¿‡ä½¿ç”¨è¿™ä¸¤ä¸ªæ°´å£¶ï¼Œå¾—åˆ°æ°å¥½ z å®¹é‡çš„æ°´ï¼Ÿ

æˆ‘ä»¬æŠŠè¿™ä¸ªé—®é¢˜ç†è§£ä¸ºä¸€ä¸ª BFS é—®é¢˜ï¼Œå…¶å…³é”®ç‚¹åœ¨äºï¼šçŠ¶æ€çš„è½¬æ¢ã€‚æˆ‘ä»¬è®¾ç½®åˆå§‹çŠ¶æ€ä¸º $(0, 0)$, è€Œç»è¿‡è½¬åŒ–åçš„ä¸­é—´çŠ¶æ€ä¸º $(a, b)$, å…¶çŠ¶æ€ä¸Šé™ä¸º $(x, y)$, æ¯ä¸€æ¬¡é€’å½’çš„çŠ¶æ€éƒ½æ”¾å…¥ BFS çš„é˜Ÿåˆ—ä¸­è¿›è¡Œåˆ¤æ–­ï¼Œè€Œåå‘åæœç´¢ï¼Œå…¶ä»£ç å¦‚ä¸‹ï¼š

```python
class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        if x + y < z:
            return False

        if x > y:
            x, y = y, x

        q = collections.deque([(0, 0)])
        visited = set()
        visited.add((0, 0))

        while q:
            a, b = q.popleft()
            if a + b == z:
                return True

            states = set()

            states.add((a, 0))
            states.add((0, b))
            states.add((x, b))
            states.add((a, y))
            # y -> x
            states.add((min(x, b + a), 0 if a + b < x else b - (x - a)))
            # x -> y
            states.add((0 if a + b < y else a - (y - b), min(a + b, y)))

            for state in states:
                if state in visited:
                    continue
                visited.add(state)
                q.append(state)

        return False
```

åœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æŠŠæ‰€æœ‰çš„çŠ¶æ€è½¬åŒ–ç‚¹éƒ½åˆ—ä¸¾å‡ºæ¥ï¼š

|                          åŠ¨ä½œ                          | çŠ¶æ€                            |      |
| :----------------------------------------------------: | ------------------------------- | ---- |
|                        $(a,b)$                         | åˆå§‹çŠ¶æ€ï¼ˆåé¢ç”¨ a,b æ ‡è¯†å£¶å·ï¼‰ |      |
|                        $(0, b)$                        | a å£¶å€’ç©º                        |      |
|                        $(a, 0)$                        | b å£¶å€’ç©º                        |      |
|                        $(x, b)$                        | a å£¶å€’æ»¡                        |      |
|                        $(a, y)$                        | b å£¶å€’æ»¡                        |      |
| $(min(x, b + a), 0)$ or $(min(x, b + a), b - (x - a))$ | å°† b å£¶å…¨éƒ¨å€’å…¥ a å£¶            |      |
|  $(0, min(a+b, y))$ or $(a - (y - b), min(a + b, y))$  | å°† a å£¶å…¨éƒ¨å€’å…¥ b å£¶            |      |

æˆ‘ä»¬éœ€è¦é‡ç‚¹ç†è§£ä¸€ä¸‹åé¢ä¸¤ç§æƒ…å†µï¼š

1. *å°† b å£¶å€’å…¥ a å£¶*ï¼šæ­¤æ—¶æˆ‘ä»¬å¯ä»¥ç¡®å®šï¼š
   1. å¦‚æœ b å£¶å…¨è¢«å€’ç©ºäº†ã€‚é‚£ä¹ˆè¿™æ—¶å€™æœ‰ä¸¤ç§æƒ…å†µï¼šç¬¬ä¸€ç§æ˜¯æŠŠå…¨éƒ¨çš„ b éƒ½å€’è¿›å»äº†ï¼Œä½†æ˜¯æ²¡æœ‰å€’æ»¡ï¼ˆ$b + a$ï¼‰ï¼›ç¬¬äºŒç§æƒ…å†µæ˜¯åˆ°è¿›å»äº†ï¼Œæ­¤æ—¶æ¯å­çš„å®¹é‡ä¸å¤Ÿäº†($x$)ã€‚
   2. å¦‚æœ b å£¶æ²¡æœ‰è¢«å€’ç©ºã€‚é‚£ä¹ˆæ­¤æ—¶ b å£¶ä¸­åº”è¯¥æ˜¯æœ‰å‰©ä¸‹çš„æ°´çš„ï¼Œä»€ä¹ˆæ—¶å€™ä¼šå‰©ä¸‹å‘¢ï¼Ÿå¦‚æœ $a + b$ çš„å®¹é‡å°äº a å£¶çš„å®¹é‡ $x$ æ—¶å€™ï¼Œè‚¯å®šä¼šæœ‰éƒ¨åˆ†çš„æ°´å‰©ä¸‹åœ¨äº† b å£¶é‡Œé¢ã€‚é‚£ä¹ˆå‰©ä¸‹äº†å¤šå°‘å‘¢ï¼Ÿæˆ‘ä»¬çŸ¥é“ a å£¶å¯ä»¥å€’å…¥ $x - a$ å®¹é‡çš„æ°´ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„æ°´å°±æ˜¯ b å£¶ç°æœ‰çš„æ°´å‡å» a å£¶å¯ä»¥å€’å…¥çš„æ°´ $b - (x -a)$ã€‚
2. *å°† a å£¶å€’å…¥ b å£¶*ï¼šå’Œä¸Šé¢çš„åˆ†æåŒç†ã€‚

### LC433 åŸºå› å˜åŒ–

> ç»™ä½ ä¸¤ä¸ªåŸºå› åºåˆ— start å’Œ end ï¼Œä»¥åŠä¸€ä¸ªåŸºå› åº“ bank ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›èƒ½å¤Ÿä½¿ start å˜åŒ–ä¸º end æ‰€éœ€çš„æœ€å°‘å˜åŒ–æ¬¡æ•°ã€‚å¦‚æœæ— æ³•å®Œæˆæ­¤åŸºå› å˜åŒ–ï¼Œè¿”å› -1 ã€‚
>
> æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
> é“¾æ¥ï¼šhttps://leetcode.cn/problems/minimum-genetic-mutation
> è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

è¿™ä¸ªé¢˜ç›®æè¿°æ¯”è¾ƒé•¿ï¼Œå¯ä»¥å‚è€ƒä¸€ä¸‹åŸé¢˜ç›®çš„æè¿°ï¼Œåœ¨æ­¤å½’çº³ä¸€ä¸‹è¿™ä¸ªé¢˜ç›®çš„ä¸€äº›é‡ç‚¹ï¼š

1. æœ€ç»ˆçš„å˜åŒ–åºåˆ—è¦åœ¨åŸºå› åº“ bank é‡Œé¢ï¼Œå¹¶ä¸”æ¯ä¸€æ¬¡çš„å˜åŒ–ä¹Ÿè¦åœ¨åŸºå› åº“ bank é‡Œé¢æ‰ç®—æ˜¯åˆæ³•çš„å˜åŒ–
2. è¦æ±‚è§£ start â€“> end çš„æœ€å°å˜åŒ–

å¯¹äºè¿™é“é¢˜ç›®ï¼Œæˆ‘ä»¬çš„è§£æ³•å¦‚ä¸‹ï¼š

```python
class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        if start == end:
            return 0
        if end not in bank:
            return -1
        bank = set(bank)
        q = collections.deque([(start, 0)])
        while q:
            gen, step = q.popleft()
            for i, ch in enumerate(gen):
                for y in "ACGT":
                    if ch != y:
                        new_gen = gen[:i] + y + gen[i + 1:]
                        if new_gen in bank:
                            if new_gen == end:
                                return step + 1
                            bank.remove(new_gen)
                            q.append((new_gen, step + 1))
        return -1
```

ä¸Šè¿°ä»£ç æœ‰å‡ ä¸ªå…³é”®ç‚¹æˆ‘ä»¬éœ€è¦æ³¨æ„çš„ï¼Œç°åœ¨é€ä¸€è¯´æ˜ï¼š

1. é¢˜ç›®è¦æ±‚æ˜¯æ±‚æœ€å°å˜åŒ–ï¼Œ**ä¸ºä»€ä¹ˆ BFS æ±‚è§£å‡ºæ¥çš„ç­”æ¡ˆæ˜¯æœ€å°å˜åŒ–**ï¼Ÿ

   å¯¹äºå¹¿åº¦ä¼˜å…ˆæœç´¢è€Œè¨€ï¼Œæˆ‘ä»¬æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹å°±æ˜¯æœ€çŸ­çš„ã€‚å‡è®¾æœ‰ä¸¤ä¸ªåŒå±‚çš„èŠ‚ç‚¹éƒ½èƒ½æŒ‡å‘ end, å› ä¸ºä»–ä»¬ä¸¤ä¸ªæ˜¯åŒå±‚ï¼Œæ‰€ä»¥æœ€ç»ˆçš„ç»“æœä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚

2.  æœ‰æ®µæ—¶é—´æ²¡æœ‰åˆ· leetcode äº†ï¼ŒçŠ¯äº†ä¸€äº›é”™è¯¯ã€‚

   - `gen, step = q.popleft()` æ³¨æ„æ˜¯ `popleft()`, ä¸è¦å†™æˆ `pop()`
   - `new_gen = gen[:i] + y + gen[i + 1:]` è¿™ä¸ªæŒ‰ç…§ i çš„æ€è·¯å¾ˆå¥½ï¼Œæˆ‘æ˜¯æ²¡æœ‰æƒ³åˆ°çš„ï¼Œå¤šå¤šç†è§£ï¼ä¹‹å‰æˆ‘çš„æƒ³æ³•æ˜¯å®šä¹‰ä¸€ä¸ªå…¨å±€çš„ `i`, ç­‰éå†å®Œä»¥åå†æ¢å¤ï¼Œæ˜æ˜¾æ˜¯æ²¡æœ‰è¿™ç§æ–¹å¼å·§å¦™çš„ã€‚

