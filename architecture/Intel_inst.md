---
title: Instructions of Intel(x86)
date: 2025-03-19
---
## 1. 指令类型

### 1.1. 指令占比概览

### 1.2. 指令类型及占比

以下是业务中各类指令的占比情况：

| 指令类别       | 占比 (%) | 指令类别       | 占比 (%) | 指令类别       | 占比 (%) |
|----------------|----------|----------------|----------|----------------|----------|
| 数据传输 (DATAXFER) | 44.00    | 算术运算 (BINARY) | 17.00    | 条件跳转 (COND_BR) | 14.00    |
| 逻辑运算 (LOGICAL)  | 7.00     | 移位操作 (SHIFT)   | 4.00     | 其他 (MISC)        | 3.00     |
| 空操作 (NOP)        | 2.00     | 出栈 (POP)         | 1.00     | 入栈 (PUSH)        | 1.00     |
| 无条件跳转 (UNCOND_BR) | 1.00     | 函数调用 (CALL)    | 1.00     | 函数返回 (RET)     | 1.00     |
| 矢量扩展 (AVX)      | 1.00     | 宽 NOP (WIDENOP)   | 1.00     | 数据预取 (PREFETCH) | 0.00     |
| 条件移动 (CMOV)     | 0.00     | SSE 指令 (SSE)     | 0.00     | 条件设置 (SETCC)   | 0.00     |
| 信号量 (SEMAPHORE)  | 0.00     | 数据转换 (CONVERT) | 0.00     | 字符串操作 (STRINGOP) | 0.00     |
| 浮点逻辑 (LOGICAL_FP) | 0.00    | 文本处理 (STTNI)   | 0.00     | 位操作扩展 (BMI1)  | 0.00     |
| 循环移位 (ROTATE)   | 0.00     | 广播 (BROADCAST)   | 0.00     | 高级矢量扩展 (AVX2) | 0.00     |
| 前导零计数 (LZCNT)  | 0.00     | 位/字节操作 (BITBYTE) | 0.00  | 系统调用 (SYSCALL)  | 0.00     |
| FMA 指令 (VFMA)     | 0.00     | 位操作扩展 (BMI2)  | 0.00     | 掩码寄存器 (KMASK) | 0.00     |
| 随机数生成 (RDRAND) | 0.00     |                  |          |                |          |

### 1.3. 高占比指令

**DATAXFER (44%)** - **数据传输指令**：负责在寄存器、内存和堆栈之间传输数据。

- 典型指令：MOV, LEA, XCHG。

- 高占比表明代码数据移动频繁，可能涉及大量内存访问或寄存器间数据交换。

**BINARY (17%)** - **算术运算指令**：执行整数加法、减法、乘法、除法等操作。

- 典型指令：ADD, SUB, MUL, DIV, INC, DEC。

- 占比较高，说明代码涉及大量数值计算。

**COND_BR (14%)** - **条件跳转指令**：依赖标志寄存器的值决定是否跳转。

- 典型指令：JZ, JNZ, JE, JNE, JA, JB。

- 说明代码逻辑较复杂，可能存在大量 if-else 结构或循环控制。

**LOGICAL (7%)** - **逻辑运算指令**

- 处理位运算，如按位与、或、异或等。

- 典型指令：AND, OR, XOR, NOT, TEST。

- 这些指令常用于位运算优化、布尔逻辑计算、掩码操作等。

**SHIFT (4%)** - **移位指令**：进行算术或逻辑移位，常用于高效乘除法、哈希计算或数据对齐。

- 典型指令：SHL, SHR, SAR, ROL, ROR。

- 表明代码中有一定的位运算优化需求。

**MISC (3%)** - **其他类型指令**：可能包括系统控制、性能测量等特殊指令。

- 典型指令：CPUID, RDTSC, HLT, RDPMC。

- 占比较低，说明这部分功能不是代码核心。

**NOP (2%)** - **空操作指令**：NOP 用于对齐、性能优化、流水线填充等。说明代码可能经过一定程度的指令对齐优化。

**POP (1%) / PUSH (1%)** - **栈操作指令**：PUSH 和 POP 用于函数调用、寄存器保存/恢复。低占比说明代码对栈的依赖较少，可能优化了寄存器使用。

**UNCOND_BR (1%)** - **无条件跳转指令**：直接跳转到指定地址，通常用于循环或异常处理。

- 典型指令：JMP, CALL, RET。

- 低占比表明代码结构较线性，不依赖大量跳转。

**CALL (1%) / RET (1%)** - **函数调用与返回**：CALL 进入子程序，RET 退出子程序。低占比可能说明函数调用层次较少，或者有内联优化。

### 1.4. 极低或未使用指令

**AVX (1%)** - **AVX 指令**

- 先进矢量扩展（Advanced Vector Extensions），用于 SIMD 浮点运算。

- 典型指令：VADDPS, VMULPS。

- 低占比可能说明代码未针对 SIMD 优化，或者 AVX 计算需求较少。

**WIDENOP (1%)** - **宽 NOP 指令**：主要用于对齐和优化指令流水线。

**PREFETCH (0%)** - **数据预取指令**：用于提前加载数据到缓存，提高缓存命中率。

- 典型指令：PREFETCHT0, PREFETCHW。

- 低占比表明代码没有显式使用数据预取优化。

**CMOV (0%)** - **条件移动指令**：避免分支预测失败，提高性能。

- 典型指令：CMOVZ, CMOVNZ。

- 低占比可能说明编译器优化不足，或者代码不依赖分支规避技术。

**SSE (0%)** - **SSE 指令**

- 浮点和 SIMD 计算指令。

- 典型指令：MOVAPS, ADDPS。

- 占比 0% 可能说明代码没有使用 SSE 或者使用了更先进的 AVX。

**SETCC (0%)** - **条件设置指令**

• 依据标志寄存器结果，将寄存器设置为 0 或 1。

• 典型指令：SETZ, SETNZ。

• 占比 0% 可能说明代码逻辑不依赖条件标志位存储。

17. **SEMAPHORE (0%)** - **信号量操作指令**

• 多线程同步控制指令。

• 说明代码基本没有多线程同步需求。

18. **CONVERT (0%)** - **数据转换指令**

• 例如整数与浮点数转换。

• CVTSI2SS, CVTSS2SI。

19. **STRINGOP (0%)** - **字符串操作指令**

• REP MOVSB, REP SCASB。

• 说明代码不涉及大规模字符串处理。

20. **LOGICAL_FP (0%)** - **浮点逻辑指令**

• 处理浮点数的逻辑操作。

21. **STTNI (0%)** - **文本处理指令**

• 主要用于字符串匹配。

22. **BMI1 (0%) / BMI2 (0%)** - **位操作扩展指令**

• 主要用于高效位操作。

• 典型指令：PDEP, PEXT。

23. **ROTATE (0%)** - **循环移位指令**

• 典型指令：ROL, ROR。

• 说明代码不涉及循环移位优化。

24. **BROADCAST (0%)** - **广播指令**

• 用于 SIMD 数据扩展。

• VBROADCASTSS。

25. **AVX2 (0%)** - **AVX2 指令**

• 比 AVX 更高级的 SIMD 指令。

• VPACKSSWB, VPMADDWD。

26. **LZCNT (0%)** - **前导零计数指令**

• 计数最高位前的零位数。

27. **BITBYTE (0%)** - **位和字节操作指令**

• BT, BTS, BTC。

28. **SYSCALL (0%)** - **系统调用指令**

• SYSCALL。

29. **VFMA (0%)** - **FMA 指令**

• VFMADD132PS，用于 fused multiply-add（FMA）计算。

30. **KMASK (0%)** - **掩码寄存器操作**

• 主要用于 AVX-512。

31. **RDRAND (0%)** - **随机数生成指令**

• RDRAND，用于硬件随机数生成。

---

**总结**

• 代码主要是 **数据传输（44%）+ 计算（17%）+ 逻辑判断（14%）**，符合通用计算或控制逻辑密集型应用的特点。

• 几乎没有 **SIMD（AVX/SSE）**，说明未做高性能矢量化优化。

• **无 SYSCALL、多线程同步（SEMAPHORE）**，可能是单线程用户态应用。

• **低 PREFETCH**，说明内存访问优化较少。