---
title: Cache
date: 2022-08-24
category:
 -  Arm
---

## 1. Abstract

ç¼“å­˜ï¼ˆCacheï¼‰æ˜¯è®¡ç®—æœºä½“ç³»ç»“æ„ä¸­ç”¨äºåŠ é€Ÿå†…å­˜è®¿é—®çš„é‡è¦ç»„ä»¶ã€‚æœ¬æ–‡ç³»ç»Ÿåœ°ç ”ç©¶äº†ç¼“å­˜çš„åŸºæœ¬æ¦‚å¿µã€å±€éƒ¨æ€§åŸç†ã€ç¼“å­˜æ˜ å°„æ–¹å¼ã€æ›¿æ¢ç­–ç•¥ã€ç¼“å­˜æœªå‘½ä¸­å¤„ç†æ–¹æ³•åŠå¤šå¤„ç†å™¨ç¯å¢ƒä¸‹çš„ç¼“å­˜ä¸€è‡´æ€§åè®®ã€‚é€šè¿‡åˆ†æä¸åŒç¼“å­˜ç­–ç•¥å¯¹ç³»ç»Ÿæ€§èƒ½çš„å½±å“ï¼Œæˆ‘ä»¬æ¢è®¨äº†å¦‚ä½•ä¼˜åŒ–ç¼“å­˜è®¾è®¡ï¼Œä»¥æé«˜æ•°æ®è®¿é—®æ•ˆç‡ï¼Œé™ä½ç¼“å­˜æœªå‘½ä¸­ç‡ï¼ˆMiss Rateï¼‰ï¼Œä»è€Œæå‡æ•´ä½“è®¡ç®—æœºç³»ç»Ÿçš„æ€§èƒ½ã€‚

## 2. Introduction

###  2.1. ç ”ç©¶èƒŒæ™¯

éšç€è®¡ç®—æœºç¡¬ä»¶æŠ€æœ¯çš„å¿«é€Ÿå‘å±•ï¼Œå¤„ç†å™¨ï¼ˆCPUï¼‰æ€§èƒ½ä¸æ–­æå‡ï¼Œä½†ä¸»å­˜ï¼ˆDRAMï¼‰è®¿é—®é€Ÿåº¦çš„è¿›æ­¥ç›¸å¯¹è¾ƒæ…¢ï¼Œå¯¼è‡´â€œå­˜å‚¨å¢™â€é—®é¢˜ï¼ˆMemory Wallï¼‰ã€‚ä¸ºäº†å¼¥è¡¥ CPU å’Œå†…å­˜ä¹‹é—´çš„é€Ÿåº¦å·®å¼‚ï¼Œç°ä»£è®¡ç®—æœºä½“ç³»ç»“æ„é‡‡ç”¨äº†åˆ†å±‚å­˜å‚¨ç»“æ„ï¼ˆMemory Hierarchyï¼‰ï¼Œå…¶ä¸­ç¼“å­˜ï¼ˆCacheï¼‰ä½œä¸ºé«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨ï¼Œå‡å°‘äº† CPU ç›´æ¥è®¿é—®ä¸»å­˜çš„æ¬¡æ•°ï¼Œæé«˜äº†æ•°æ®è®¿é—®é€Ÿåº¦ã€‚

:::note å“²å­¦å«ä¹‰

ç¨‹åºå‘˜æ€»å¸Œæœ›å­˜å‚¨æ˜¯æ— é™çš„ï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ç³»åˆ—çš„æŠ€æœ¯æ‰‹æ®µè®©ç¨‹åºå‘˜äº§ç”Ÿè¿™ç§é”™è§‰ã€‚

:::

###  2.2. ç ”ç©¶ç›®æ ‡

æœ¬æ–‡ä¸»è¦ç ”ç©¶å­˜å‚¨å±‚æ¬¡ç»“æ„ä¸­çš„ cache ç¯èŠ‚ï¼Œä¸»è¦ç ”ç©¶å†…å®¹åŒ…æ‹¬ï¼š

1. **å±€éƒ¨æ€§åŸç†ï¼ˆPrinciple of Localityï¼‰**ï¼šåˆ†ææ—¶é—´å±€éƒ¨æ€§å’Œç©ºé—´å±€éƒ¨æ€§å¯¹ç¼“å­˜è®¾è®¡çš„å½±å“ã€‚
2. **ç¼“å­˜ç»“æ„**ï¼šæ¢è®¨ç¼“å­˜è¡Œï¼ˆCache Lineï¼‰åŠå…¶å­˜å‚¨ç®¡ç†æ–¹å¼ã€‚
3. **ç¼“å­˜æ˜ å°„æ–¹å¼**ï¼šç ”ç©¶ç›´æ¥æ˜ å°„ã€å…¨ç›¸è”æ˜ å°„å’Œç»„ç›¸è”æ˜ å°„çš„ç‰¹ç‚¹å’Œåº”ç”¨ã€‚
4. **ç¼“å­˜æ›¿æ¢ç­–ç•¥**ï¼šå¯¹æ¯”ä¸åŒçš„ç¼“å­˜æ›¿æ¢ç®—æ³•ï¼Œå¦‚ LRUã€FIFO å’Œéšæœºæ›¿æ¢ç­–ç•¥ã€‚
5. **ç¼“å­˜ä¸€è‡´æ€§åè®®**ï¼šè®¨è®º MESI ä¸€è‡´æ€§åè®®åœ¨å¤šæ ¸ç³»ç»Ÿä¸­çš„åº”ç”¨ã€‚
6. **ç¼“å­˜æ€§èƒ½ä¼˜åŒ–**ï¼šåˆ†æç¼“å­˜æœªå‘½ä¸­çš„å½±å“ï¼Œå¹¶æå‡ºé™ä½ç¼“å­˜æœªå‘½ä¸­ç‡çš„ä¼˜åŒ–æ–¹æ³•ã€‚åŒ…æ‹¬ä¸¤ä¸ªé‡è¦çš„ç®—æ³•å’Œé€šç”¨çš„å¤„ç† cache miss çš„æ–¹æ³•ã€‚

### 2.3. Key Word

| key word              | means  | comments |
| --------------------- | ------ | -------- |
| memory hierarchy      | å†…å­˜å±‚æ¬¡ç»“æ„ |          |
| principle of locality | å±€éƒ¨æ€§åŸç†  |          |
| temporal locality     | æ—¶é—´å±€éƒ¨æ€§  |          |
| spatial locality      | ç©ºé—´å±€éƒ¨æ€§  |          |
| Locality of reference | è®¿é—®å±€éƒ¨æ€§  |          |

## 3. ç¼“å­˜åŸºç¡€çŸ¥è¯†

### 3.1. å±€éƒ¨æ€§åŸç†

ç¼“å­˜çš„é«˜æ•ˆæ€§ä¸»è¦ä¾èµ–äº**å±€éƒ¨æ€§åŸç†Principle of Localityï¼‰**ï¼š

- **æ—¶é—´å±€éƒ¨æ€§ï¼ˆTemporal Localityï¼‰**ï¼šå¦‚æœæŸä¸ªæ•°æ®è¢«è®¿é—®è¿‡ï¼Œå®ƒå¾ˆå¯èƒ½åœ¨ä¸ä¹…çš„å°†æ¥å†æ¬¡è¢«è®¿é—®ã€‚ä¾‹å¦‚ï¼Œå¾ªç¯ä¸­çš„æŒ‡ä»¤é€šå¸¸ä¼šå¤šæ¬¡æ‰§è¡Œã€‚ä»¥ loop ä¸ºä¾‹, è¢«å¼•ç”¨è¿‡ä¸€æ¬¡çš„å­˜å‚¨å™¨ä½ç½®åœ¨æœªæ¥ä¼šè¢«å¤šæ¬¡å¼•ç”¨ã€‚
- **ç©ºé—´å±€éƒ¨æ€§ï¼ˆSpatial Localityï¼‰**ï¼šå¦‚æœæŸä¸ªæ•°æ®è¢«è®¿é—®ï¼Œé‚£ä¹ˆå®ƒå‘¨å›´çš„æ•°æ®å¾ˆå¯èƒ½åœ¨ä¸ä¹…åä¹Ÿè¢«è®¿é—®ã€‚å…¸å‹çš„ä¾‹å­å°±æ˜¯æ•°ç»„ã€‚

æ€»ä½“è€Œè¨€ï¼Œå¯ä»¥å½’çº³ä¸ºè®¿é—®å±€éƒ¨æ€§ï¼Œå…¶å«ä¹‰æ˜¯è®¡ç®—æœºç§‘å­¦é¢†åŸŸçš„åº”ç”¨ç¨‹åºåœ¨è®¿é—®å†…å­˜çš„æ—¶å€™ï¼Œå€¾å‘äºè®¿é—®å†…å­˜ä¸­è¾ƒä¸ºé è¿‘çš„å€¼ã€‚

:::note å­˜å‚¨å±‚æ¬¡ç»“æ„å¦‚ä½•åˆ©ç”¨æ—¶é—´å±€éƒ¨æ€§å’Œç©ºé—´å±€éƒ¨æ€§ï¼Ÿ

ä¸»è¦æ˜¯ 2 ä¸ªï¼šå°†ç»å¸¸è®¿é—®çš„æ•°æ®æ”¾åœ¨è·ç¦»å¤„ç†å™¨æ›´è¿‘çš„åœ°æ–¹ï¼Œå°†å¤šä¸ªè¿ç»­çš„â€œå—â€ç§»åŠ¨åˆ°ä¸Šå±‚å­˜å‚¨ä¸­æ¥åˆ©ç”¨ç©ºé—´å±€éƒ¨æ€§ã€‚

:::

æ¥è¿‘å¤„ç†å™¨çš„å­˜å‚¨æ˜¯æ¯”è¾ƒå°å’Œæ¯”è¾ƒå¿«çš„ï¼Œé™¤äº†æˆæœ¬è€ƒè™‘ä¹‹å¤–ï¼Œæ¥è¿‘å¤„ç†å™¨çš„å­˜å‚¨æ¯”è¾ƒå°çš„è¯ï¼Œå…¶å‘½ä¸­ç‡ä¹Ÿæ›´é«˜ã€‚

- ç†è§£ hit rate, miss rate, hit time, miss penalty

å±€éƒ¨æ€§æ˜¯è®¡ç®—æœºç³»ç»Ÿä¸­çš„ä¸€ç§å¯é¢„æµ‹çš„è¡Œä¸ºï¼Œç³»ç»Ÿçš„è¿™ç§å¼ºè®¿é—®å±€éƒ¨æ€§ï¼Œå¯ä»¥è¢«ç”¨æ¥å¤„ç†å†…æ ¸çš„æŒ‡ä»¤æµæ°´çº¿ä¸­çš„æ€§èƒ½ä¼˜åŒ–ï¼Œå¦‚ç¼“å­˜ã€åˆ†æ”¯é¢„æµ‹ã€å†…å­˜é¢„è¯»å–ç­‰ã€‚

### 3.2. å­˜å‚¨å±‚æ¬¡ç»“æ„

ç°ä»£è®¡ç®—æœºçš„å­˜å‚¨å±‚æ¬¡ç»“æ„é€šå¸¸åŒ…æ‹¬ï¼š

1. **å¯„å­˜å™¨ï¼ˆRegistersï¼‰**ï¼šæœ€å¿«é€Ÿä½†å®¹é‡æœ€å°çš„å­˜å‚¨å™¨ã€‚
2. **L1 ç¼“å­˜**ï¼ˆä¸€çº§ç¼“å­˜ï¼‰ï¼šç›´æ¥é›†æˆåœ¨ CPU å†…éƒ¨ï¼Œè®¿é—®å»¶è¿Ÿæä½ã€‚
3. **L2/L3 ç¼“å­˜**ï¼ˆäºŒ/ä¸‰çº§ç¼“å­˜ï¼‰ï¼šå®¹é‡æ›´å¤§ï¼Œè®¿é—®å»¶è¿Ÿç›¸å¯¹è¾ƒé«˜ã€‚
4. **ä¸»å­˜ï¼ˆMain Memoryï¼‰**ï¼šé€šå¸¸ä¸º DRAMï¼Œè®¿é—®å»¶è¿Ÿè¾ƒé«˜ã€‚
5. **ç£ç›˜å­˜å‚¨ï¼ˆDisk Storageï¼‰**ï¼šå¦‚ SSD æˆ– HDDï¼Œé€Ÿåº¦è¿œä½äºä¸»å­˜ã€‚

```mermaid
graph TD;
  A[CPU å¯„å­˜å™¨] --> B[L1 ç¼“å­˜];
  B --> C[L2 ç¼“å­˜];
  C --> D[L3 ç¼“å­˜];
  D --> E[ä¸»å­˜ RAM];
  E --> F[ç£ç›˜å­˜å‚¨ SSD/HDD]
```



## 4. **ç¼“å­˜æ¶æ„**

### 4.1. ç¼“å­˜è¡Œï¼ˆCache Lineï¼‰

ç¼“å­˜çš„å­˜å‚¨å•å…ƒè¢«ç§°ä¸º**ç¼“å­˜è¡Œï¼ˆCache Lineï¼‰**ï¼Œæ•´ä¸ªcache ç©ºé—´è¢«åˆ†æˆäº† N ä¸ª lineï¼Œline æ˜¯ cache äº¤æ¢çš„æœ€å°å•ä½ï¼Œæ¯ä¸ª cache line é€šå¸¸æ˜¯ 32 byte æˆ–è€… 64 byte, å¯¹äºä¸€ä¸ªå­—èŠ‚æˆ‘ä»¬è¿˜éœ€è¦æ›´åŠ æ³¨æ„ï¼Œé‚£å°±æ˜¯ cache line åŒ…å«çš„å†…å®¹ï¼š

| **å­—æ®µ**       | **æè¿°**                       |
| -------------- | ------------------------------ |
| **Tag**        | ç”¨äºæ ‡è¯†ç¼“å­˜æ•°æ®å¯¹åº”çš„ä¸»å­˜åœ°å€ |
| **Valid Bit**  | æŒ‡ç¤ºç¼“å­˜è¡Œæ˜¯å¦åŒ…å«æœ‰æ•ˆæ•°æ®     |
| **Data Block** | å­˜å‚¨å…·ä½“çš„æ•°æ®                 |

å‚è€ƒ arm å®˜æ–¹çš„ç¤ºæ„å›¾ï¼š

![](https://documentation-service.arm.com/static/5ff5c9fd89a395015c28fc6c?token=)

æœ‰äº›æ—¶å€™ä¹Ÿä¼šç”¨ tag, valid, block è¡¨ç¤ºï¼Œå…¶ä¸­ block è¡¨ç¤º cache ä¸­ç¼“å­˜çš„æ•°æ®ï¼Œtag æ˜¯è¯¥ cache line å¯¹åº”çš„å†…å­˜çš„åœ°å€ï¼Œvalid è¡¨ç¤ºè¯¥ cache line ä¸­çš„æ•°æ®æ˜¯å¦æœ‰æ•ˆã€‚

ä¹Ÿæœ‰å¦‚ä¸‹çš„è¡¨ç¤ºæ–¹æ³•ï¼š

```
+-----------------+----------------------+---------------+
|      Tag        |        Data          |   Control     |
+-----------------+----------------------+---------------+
|      n bits     |        m bytes       |   k bits      |
+-----------------+----------------------+---------------+
```

åœ¨ä¸Šè¿°å›¾ä¸­ï¼Œcache line è¢«è¡¨ç¤ºæˆäº†ä¸‰ä¸ªéƒ¨åˆ†ï¼š

1. **Tag**: identify the memory address associated with the cache entry
2. **Data**: contains the actual data or instructions stored in the cache entry
3. **Control**: contains the control bits used to manage the cache entry, such as indicating whether the entry is **valid** or not, whether it has been **modified**, and whether it is available for use.

é€šè¿‡å¯¹æ¯”è¿™ä¸¤è€…çš„ä¸åŒï¼Œæˆ‘ä»¬æ˜ç™½ï¼Œä¸åŒçš„ä½“ç³»ç»“æ„ä¸­çš„ cacheline è®¾è®¡éƒ½æ˜¯å­˜åœ¨å·®å¼‚çš„ã€‚

ä¸‹é¢ç« èŠ‚è§£é‡Šä¸€ä¸‹ tag å’Œ valid çš„ä½œç”¨[^1]ã€‚



### 4.2. Cache ä½œç”¨



> Caching is perhaps the most important example of the big idea of **prediction**. It relies on the principle of locality to try to find the desired data in the higher levels of the memory hierarchy, and provides mechanisms to ensure that when the prediction is wrong it finds and uses the proper data from the lower levels of the memory hierarchy. The hit rates of the cache prediction on modern computers are often above 95%.

è¿™å¥è¯ä»å®è§‚ç»´åº¦æ€»ç»“äº† cache çš„ä¸€äº›ä½œç”¨ï¼š

- é¢„æµ‹å¤§æ€æƒ³çš„å®Œç¾åº”ç”¨
- ä¾èµ–äº†å±€éƒ¨æ€§åŸç†

å…¶æœ¬è´¨å°±æ˜¯è¯•å›¾åœ¨å­˜å‚¨å±‚æ¬¡ç»“æ„çš„æ›´é«˜å±‚æ¬¡æ‰¾åˆ°æƒ³è¦çš„æ•°æ®ã€‚

### 4.3. Cache ç»“æ„

ä¸‹å›¾æ˜¯ä¸€ä¸ªå…³äº cache ç»“æ„çš„å…¨å±€ç¤ºæ„å›¾ï¼š

![](https://documentation-service.arm.com/static/5ff5c9fd89a395015c28fc72?token=)

### 4.4. way & set

way å’Œ set çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ

> In a cache, a "way" refers to a set of cache entries that have the same index but different tags. ==The number of ways in a cache is **determined by the cache's associativity**==, which is the number of cache entries that can map to the same index. Each way contains a set of cache entries that are grouped together based on their index.
>
> ï¼ˆç¬”è€…ç¿»è¯‘ï¼‰åœ¨ç¼“å­˜ï¼ˆcacheï¼‰ä¸­ï¼Œ**â€œwayâ€ï¼ˆè·¯ï¼‰** æŒ‡çš„æ˜¯ä¸€ç»„å…·æœ‰**ç›¸åŒç´¢å¼•ï¼ˆindexï¼‰** ä½† **ä¸åŒæ ‡è®°ï¼ˆtagï¼‰** çš„ç¼“å­˜æ¡ç›®ï¼ˆcache entriesï¼‰ã€‚ç¼“å­˜çš„ç›¸è”åº¦ï¼ˆassociativityï¼‰å†³å®šäº†ç¼“å­˜çš„ way æ•°é‡ï¼Œå³**å¤šå°‘ä¸ªç¼“å­˜æ¡ç›®å¯ä»¥æ˜ å°„åˆ°ç›¸åŒçš„ç´¢å¼•**ã€‚æ¯ä¸ª way åŒ…å«ä¸€ç»„æŒ‰ç´¢å¼•åˆ†ç»„çš„ç¼“å­˜æ¡ç›®ã€‚
>
> In contrast, a "set" in a cache refers to a group of cache entries that share the same index. A set can contain multiple cache entries, with each entry having a unique tag. The number of sets in a cache is determined by the cache size and block size.
>
> ï¼ˆç¬”è€…ç¿»è¯‘ï¼‰ç›¸æ¯”ä¹‹ä¸‹ï¼Œ**â€œsetâ€ï¼ˆé›†åˆï¼‰** æŒ‡çš„æ˜¯**å…±äº«ç›¸åŒç´¢å¼•**çš„ä¸€ç»„ç¼“å­˜æ¡ç›®ã€‚ä¸€ä¸ªé›†åˆå¯ä»¥åŒ…å«å¤šä¸ªç¼“å­˜æ¡ç›®ï¼Œæ¯ä¸ªæ¡ç›®å…·æœ‰ä¸åŒçš„**æ ‡è®°ï¼ˆtagï¼‰**ã€‚ç¼“å­˜ä¸­çš„é›†åˆæ•°é‡ç”±**ç¼“å­˜å¤§å°ï¼ˆcache sizeï¼‰å’Œå—å¤§å°ï¼ˆblock sizeï¼‰** å†³å®šã€‚

åœ¨ç¼“å­˜ç»“æ„ä¸­ï¼Œ**way å’Œ set æ˜¯ä¸¤ä¸ªå…³é”®æ¦‚å¿µ**ï¼Œå®ƒä»¬å…±åŒå†³å®šäº†ç¼“å­˜å¦‚ä½•å­˜å‚¨å’ŒæŸ¥æ‰¾æ•°æ®ã€‚

-  **Wayï¼ˆè·¯ï¼‰**ï¼šåœ¨ç»„ç›¸è”ï¼ˆset-associativeï¼‰ç¼“å­˜ä¸­ï¼Œå¤šä¸ªç¼“å­˜æ¡ç›®å¯ä»¥æ˜ å°„åˆ°åŒä¸€ä¸ªç´¢å¼•ï¼Œä½†å®ƒä»¬æœ‰ä¸åŒçš„æ ‡è®°ï¼ˆtagï¼‰ã€‚è¿™äº›æ¡ç›®å°±ç»„æˆäº†ç¼“å­˜çš„ **way**ã€‚**ç›¸è”åº¦ï¼ˆassociativityï¼‰** å†³å®šäº†ç¼“å­˜çš„ way æ•°ã€‚ä¾‹å¦‚ï¼Œ**4 è·¯ç»„ç›¸è”ï¼ˆ4-way set-associativeï¼‰** è¯´æ˜**æ¯ä¸ªç´¢å¼•ä¸‹æœ‰ 4 ä¸ªä¸åŒçš„ç¼“å­˜æ¡ç›®**å¯ä¾›å­˜å‚¨æ•°æ®ã€‚å¤„ç†å™¨è®¿é—®æ•°æ®æ—¶ï¼Œä¼šæ£€æŸ¥è¯¥ç´¢å¼•ä¸‹çš„æ‰€æœ‰ waysï¼ŒæŸ¥çœ‹æ˜¯å¦æœ‰åŒ¹é…çš„æ ‡è®°ï¼ˆtagï¼‰ã€‚

- **Setï¼ˆé›†åˆï¼‰**ï¼š**ä¸€ä¸ª set ä»£è¡¨æ‰€æœ‰å…·æœ‰ç›¸åŒç´¢å¼•çš„ç¼“å­˜æ¡ç›®**ï¼Œè€Œæ¯ä¸ªæ¡ç›®éƒ½æœ‰ä¸åŒçš„ tagã€‚**ä¸€ä¸ª set ä¸­çš„ç¼“å­˜æ¡ç›®æ•°é‡** ç”±ç›¸è”åº¦ï¼ˆway æ•°ï¼‰å†³å®šã€‚ä¾‹å¦‚ï¼Œåœ¨ 4 è·¯ç»„ç›¸è”çš„ç¼“å­˜ä¸­ï¼Œæ¯ä¸ª set åŒ…å« **4 ä¸ªç¼“å­˜æ¡ç›®**ã€‚**ç¼“å­˜çš„ set æ•°é‡** ç”±ç¼“å­˜å¤§å°å’Œå—å¤§å°è®¡ç®—å¾—å‡ºï¼Œå†³å®šäº†ç¼“å­˜å¯ä»¥å­˜å‚¨å¤šå°‘ä¸åŒçš„ç´¢å¼•åœ°å€ã€‚

æ€»è€Œè¨€ä¹‹ï¼ŒWay å†³å®šäº†ç¼“å­˜ç›¸è”åº¦ï¼ˆassociativityï¼‰ï¼Œå³æ¯ä¸ªç´¢å¼•ä¸‹å¯ä»¥å­˜æ”¾å¤šå°‘ä¸ªæ¡ç›®ã€‚Set ä»£è¡¨äº†æ‰€æœ‰å…±äº«ç›¸åŒç´¢å¼•çš„ç¼“å­˜æ¡ç›®ï¼Œå…¶æ•°é‡ç”±ç¼“å­˜å¤§å°å’Œå—å¤§å°å†³å®šã€‚æ›´é«˜çš„ way æ•°ï¼ˆå¦‚ 8-way æˆ– 16-wayï¼‰å¯ä»¥å‡å°‘ç¼“å­˜å†²çªï¼ˆconflict missesï¼‰ï¼Œä½†æŸ¥æ‰¾æ•°æ®æ—¶çš„å¼€é”€ï¼ˆå¤æ‚åº¦ï¼‰ä¹Ÿä¼šå¢åŠ ã€‚

å†å‚è€ƒä»¥ä¸‹çš„å¼•æ–‡[^2]ï¼š

> Suppose we have a **4-way set-associative cache** with 8 cache entries and a block size of 64 bytes. This means that the cache has 8 sets, each with 4 ways.
> 
> Here's an example of how the cache might be organized:
> 
> ```
> Set 0:
> Way 0: [Tag 0][Data][Control]
> Way 1: [Tag 1][Data][Control]
> Way 2: [Tag 2][Data][Control]
> Way 3: [Tag 3][Data][Control]
> 
> Set 1:
> Way 0: [Tag 4][Data][Control]
> Way 1: [Tag 5][Data][Control]
> Way 2: [Tag 6][Data][Control]
> Way 3: [Tag 7][Data][Control]
> 
> ...
> 
> Set 7:
> Way 0: [Tag 28][Data][Control]
> Way 1: [Tag 29][Data][Control]
> Way 2: [Tag 30][Data][Control]
> Way 3: [Tag 31][Data][Control]
> ```
> 
> In this example, each set contains 4 ways, and each way contains a cache entry with a unique tag, data, and control bits. When the processor requests data from memory, the cache uses the memory address to determine the index and tag of the requested data. The cache then checks the corresponding set and looks for the requested data in each way of that set until it finds the data or determines that it is not in the cache.

é€šå¸¸è€Œè¨€ï¼Œä¸€ä¸ª way å¤šä¸ª cacheline.

> To add the cache line to the previous text figure, we can modify it as follows:
> 
> ```
> Set 0:
> Way 0: 
>     [Tag 0][Data][Control] 
>     [Tag 1][Data][Control] 
>     [Tag 2][Data][Control] 
>     [Tag 3][Data][Control]
> ```

ä¸Šè¿°çš„ä¾‹å­è¯´æ˜äº†ï¼šä¸€ä¸ª way æ˜¯ç”±å¾ˆå¤šä¸ª cache entries ç»„æˆçš„ï¼ˆè¿™ç‚¹åœ¨ä¸‹é¢çš„å›¾ä¸­ä¹Ÿå¯ä»¥å¾—åˆ°å°è¯ï¼‰

ä»¥ä¸‹æ˜¯å¼•ç”¨ ARM å®˜æ–¹çš„ä¸€ä¸ªä¾‹å­ï¼š

> *here's an example to illustrate the relationship between cache size, way, and set:*
>
> ï¼ˆç¿»è¯‘ï¼Œåæ–‡ç•¥ï¼‰ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œè¯´æ˜ç¼“å­˜å¤§å°ã€ç›¸è”åº¦ï¼ˆwayï¼‰å’Œé›†åˆï¼ˆsetï¼‰ä¹‹é—´çš„å…³ç³»ï¼š
>
> Let's say we have a cache with a total size of 64 KB, a block size of 64 bytes, and a 4-way set-associative mapping.
>
> å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ€»å¤§å°ä¸º 64 KB çš„ç¼“å­˜ï¼Œå—å¤§å°ï¼ˆblock sizeï¼‰ä¸º 64 å­—èŠ‚ï¼Œé‡‡ç”¨ 4 è·¯ï¼ˆ4-wayï¼‰ç»„ç›¸è”ï¼ˆset-associativeï¼‰æ˜ å°„ã€‚
>
> To determine the number of sets in the cache, we can divide the cache size by the product of the block size and the associativity. In this case, we have:
>
> Number of sets = cache size / (block size x associativity)
> Number of sets = 64 KB / (64 bytes x 4)
> Number of sets = 256
>
> This means that the cache has 256 sets. Each set contains four ways, as specified by the 4-way set-associative mapping.
>
> ä¸ºäº†ç¡®å®šç¼“å­˜ä¸­çš„**é›†åˆæ•°ï¼ˆnumber of setsï¼‰**ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç¼“å­˜å¤§å°é™¤ä»¥**å—å¤§å°ä¸ç›¸è”åº¦çš„ä¹˜ç§¯**ã€‚
>
> åœ¨æœ¬ä¾‹ä¸­ï¼šè¿™æ„å‘³ç€è¯¥ç¼“å­˜å…±æœ‰ 256 ä¸ª sets, ç”±äºé‡‡ç”¨ 4 è·¯ç»„ç›¸è”æ˜ å°„ï¼Œæ¯ä¸ªé›†åˆä¸­åŒ…å« 4 ä¸ª wayã€‚
>
> To determine the number of cache entries in the cache, we can multiply the number of sets by the number of ways. In this case, we have:
>
> Number of cache entries = number of sets x number of ways
> Number of cache entries = 256 x 4
> Number of cache entries = 1024
>
> This means that the cache has a total of 1024 cache entries. Each cache entry consists of a block of 64 bytes, as specified by the block size.
>
> ä¸ºäº†ç¡®å®šç¼“å­˜ä¸­çš„**ç¼“å­˜æ¡ç›®æ•°ï¼ˆcache entriesï¼‰**ï¼Œæˆ‘ä»¬å¯ä»¥å°†é›†åˆæ•°ä¹˜ä»¥ç›¸è”åº¦ï¼ˆwayï¼‰ã€‚
>
> åœ¨æœ¬ä¾‹ä¸­ï¼šè¿™æ„å‘³ç€è¯¥ç¼“å­˜å…±æœ‰ **1024 ä¸ªç¼“å­˜æ¡ç›®ï¼ˆcache entriesï¼‰**ã€‚æ¯ä¸ªç¼“å­˜æ¡ç›®åŒ…å« **ä¸€ä¸ª 64 å­—èŠ‚çš„å—**ï¼Œè¿™ç”±å—å¤§å°å†³å®šã€‚
>
> When the processor requests data from memory, the cache uses the memory address to determine the index and tag of the requested data. The cache then checks the corresponding set and looks for the requested data in each of the four ways of that set until it finds the data or determines that it is not in the cache.
>
> å½“å¤„ç†å™¨ä»å†…å­˜è¯·æ±‚æ•°æ®æ—¶ï¼Œç¼“å­˜ä¼šä½¿ç”¨å†…å­˜åœ°å€æ¥ç¡®å®šæ•°æ®æ‰€åœ¨çš„ ç´¢å¼•ï¼ˆindexï¼‰å’Œ æ ‡è®°ï¼ˆtagï¼‰ã€‚ç„¶åï¼Œç¼“å­˜ä¼šæ£€æŸ¥å¯¹åº”çš„é›†åˆï¼Œå¹¶åœ¨è¯¥é›†åˆçš„ 4 ä¸ª way ä¸­æŸ¥æ‰¾è¯·æ±‚çš„æ•°æ®ï¼Œç›´åˆ°æ‰¾åˆ°æ•°æ®æˆ–ç¡®å®šè¯¥æ•°æ®ä¸åœ¨ç¼“å­˜ä¸­ã€‚
>
> Overall, this example illustrates how the cache size, block size, and associativity determine the number of sets, ways, and cache entries in a cache, and how these components work together to efficiently cache frequently accessed data and reduce the time spent waiting for data to be fetched from main memory.
>
> æ€»ä½“è€Œè¨€ï¼Œè¿™ä¸ªç¤ºä¾‹è¯´æ˜äº†**ç¼“å­˜å¤§å°ã€å—å¤§å°å’Œç›¸è”åº¦**å¦‚ä½•å…±åŒå†³å®šç¼“å­˜çš„**é›†åˆæ•°ã€way æ•°é‡ä»¥åŠç¼“å­˜æ¡ç›®æ•°**ï¼Œä»¥åŠè¿™äº›ç»„ä»¶å¦‚ä½•ååŒå·¥ä½œï¼Œä»¥é«˜æ•ˆç¼“å­˜**ç»å¸¸è®¿é—®çš„æ•°æ®**ï¼Œä»è€Œå‡å°‘ä»ä¸»å­˜åŠ è½½æ•°æ®æ‰€èŠ±è´¹çš„æ—¶é—´ã€‚



ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œè¯´æ˜ç¼“å­˜å¤§å°ã€ç›¸è”åº¦ï¼ˆwayï¼‰å’Œé›†åˆï¼ˆsetï¼‰ä¹‹é—´çš„å…³ç³»ã€‚

**ç¼“å­˜å‚æ•°è®¾å®š**ï¼šè¿™é‡Œçš„ç¼“å­˜æ€»å¤§å°ä¸º **64 KB**ï¼Œå—å¤§å°ä¸º **64 å­—èŠ‚**ï¼Œå¹¶ä¸”é‡‡ç”¨ **4 è·¯ç»„ç›¸è”æ˜ å°„**ã€‚

**è®¡ç®—é›†åˆæ•°**ï¼šç”±äºç¼“å­˜é‡‡ç”¨ç»„ç›¸è”ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å¦‚ä¸‹å…¬å¼è®¡ç®—é›†åˆæ•°ï¼š

$\text{é›†åˆæ•°} = \frac{\text{ç¼“å­˜å¤§å°}}{\text{å—å¤§å°} \times \text{ç›¸è”åº¦}}$

$\text{é›†åˆæ•°} = \frac{64 \text{ KB}}{64 \text{ bytes} \times 4} = 256$ 

è¿™æ„å‘³ç€ç¼“å­˜å…±æœ‰ **256 ä¸ªé›†åˆ**ï¼Œæ¯ä¸ªé›†åˆç”± 4 ä¸ª way ç»„æˆã€‚

**è®¡ç®—ç¼“å­˜æ¡ç›®æ•°**ï¼šç”±äºæ¯ä¸ªé›†åˆæœ‰ 4 ä¸ª wayï¼Œå› æ­¤ç¼“å­˜æ€»æ¡ç›®æ•°ä¸ºï¼š$\text{ç¼“å­˜æ¡ç›®æ•°} = \text{é›†åˆæ•°} \times \text{ç›¸è”åº¦} = 256 \times 4 = 1024$ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¯¥ç¼“å­˜å…±æœ‰ **1024 ä¸ªç¼“å­˜æ¡ç›®**ï¼Œæ¯ä¸ªæ¡ç›®å­˜å‚¨ **ä¸€ä¸ª 64 å­—èŠ‚çš„å—**ã€‚

**æ•°æ®è®¿é—®è¿‡ç¨‹**ï¼šå½“ CPU è¯·æ±‚æ•°æ®æ—¶ï¼Œç¼“å­˜ä¼šæ ¹æ®å†…å­˜åœ°å€ç¡®å®šæ•°æ®æ‰€åœ¨çš„ **é›†åˆç´¢å¼•ï¼ˆindexï¼‰** å’Œ **æ ‡è®°ï¼ˆtagï¼‰**ã€‚è®¡ç®—å‡ºçš„ç´¢å¼•å€¼ç”¨äºå®šä½åˆ° **256 ä¸ªé›†åˆä¸­çš„æŸä¸€ä¸ª**ã€‚ç„¶åï¼Œç¼“å­˜ä¼šåœ¨è¯¥é›†åˆçš„ **4 ä¸ª way** ä¸­æŸ¥æ‰¾æ•°æ®ã€‚è‹¥æ•°æ®å‘½ä¸­ï¼Œåˆ™ç›´æ¥è¿”å›ï¼›å¦åˆ™ï¼Œè§¦å‘ç¼“å­˜æœªå‘½ä¸­ï¼Œæ•°æ®éœ€è¦ä»ä¸»å­˜åŠ è½½ã€‚

è¿™ä¸ªä¾‹å­å±•ç¤ºäº†ç¼“å­˜çš„åŸºæœ¬ç»„ç»‡æ–¹å¼ï¼Œå¹¶è¯´æ˜äº†ç¼“å­˜å¤§å°ã€å—å¤§å°å’Œç›¸è”åº¦å¦‚ä½•å†³å®šç¼“å­˜çš„ç»“æ„å‚æ•°ã€‚

::: warning

**é«˜æ•ˆçš„ç¼“å­˜è®¾è®¡å¯ä»¥å‡å°‘ CPU ç­‰å¾…æ•°æ®çš„æ—¶é—´ï¼Œæé«˜æ•´ä½“æ€§èƒ½ã€‚**

:::

é‡åŒ–ç ”ç©¶æ–¹æ³•å¦‚ä¸‹æ‰€æè¿°ï¼š

> The set associative organization has **four sets with two blocks per set**, called two-way set associative.

***(ç¬”è€…ç¿»è¯‘ï¼‰***â€œäºŒè·¯ç»„ç›¸è”â€ï¼ˆtwo-way set associativeï¼‰ç»„ç»‡å½¢å¼æ˜¯ç¼“å­˜ç»„ç»‡çš„ä¸€ç§æ–¹å¼ã€‚åœ¨è¿™æ®µæ–‡å­—ä¸­ï¼Œæè¿°äº†ç¼“å­˜çš„ç»“æ„ç‰¹å¾ï¼šå®ƒåŒ…å«å››ä¸ªé›†åˆï¼ˆsetsï¼‰ï¼Œæ¯ä¸ªé›†åˆæœ‰ä¸¤ä¸ªå—ï¼ˆblocksï¼‰ã€‚äºŒè·¯ç»„ç›¸è”ç¼“å­˜æ˜¯ä»‹äºç›´æ¥æ˜ å°„ç¼“å­˜å’Œå…¨ç›¸è”ç¼“å­˜ä¹‹é—´çš„ä¸€ç§ç»“æ„ã€‚

### 4.5. tag

> Because each cache location can contain the contents of a number of different
> memory locations, how do we know whether the data in the cache corresponds
> to a requested word? That is, how do we know whether a requested word is in the
> cache or not?

ä¸ºäº†è§£å†³ä¸Šè¿°çš„é—®é¢˜ï¼ˆæˆ‘ä»¬è¦è®¿é—®çš„å†…å®¹æ˜¯ä¸æ˜¯åœ¨ cache é‡Œé¢ï¼‰ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† tag è¿™ä¸ªå­—æ®µï¼ŒåŸå§‹çš„å¯¹äº tag çš„å®šä¹‰å¯ä»¥å¦‚ä¸‹æ‰€ç¤ºï¼š

> A field in a table used for a memory hierarchy that contains the address information required to identify whether the associated block in the hierarchy corresponds to a requested word.

å…¶æ„æ€å°±æ˜¯è¯´å¯¹åº”äº†å†…å­˜ä¸­çš„åœ°å€ä¿¡æ¯ã€‚

ï¼ˆâŒâŒ ä¹‹å‰é”™è¯¯çš„ç†è§£ï¼‰ä¸è¿‡æˆ‘ä»¬éœ€è¦æ³¨æ„ä¸€ä¸ªç»†èŠ‚ï¼Œé‚£å°±æ˜¯æˆ‘ä»¬å¦‚æœä½¿ç”¨ direct-mappedï¼ˆç›®å‰çœ‹æ¥æ˜¯è¿™æ ·çš„ï¼Œè¿™ä¸ªä»¥åå†å¥½å¥½æ€è€ƒä¸€ä¸‹ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ª tag å°±æ˜¯ä¸éœ€è¦ä¿å­˜å®Œæ•´çš„åœ°å€ä¿¡æ¯çš„ã€‚

âœ”ï¸âœ”ï¸ å¯¹äºä¸Šè¿°è¯´æ³•çš„æ­£ç¡®ç†è§£æ˜¯ï¼štag æ‰€éœ€è¦ä½¿ç”¨çš„ä½æ•°å¤§å°æ˜¯å–å†³äºå¾®æ¶æ„å®é™…çš„è®¾è®¡çš„ï¼Œå’Œåœ°å€ä¿¡æ¯éå¼ºç›¸å…³ï¼›ä¸ºäº†æ›´å¥½ç†è§£ï¼Œæˆ‘ä»¬åœ¨æ­¤é‡å¤ç ”ç©¶è¿™å¼ å›¾ç‰‡ï¼š

![A real-life example](https://documentation-service.arm.com/static/5ff5c9fd89a395015c28fc35?token=)

ä»å›¾ï¼ˆå¾ˆé‡è¦ï¼Œæ‰€ä»¥åœ¨æœ¬æ–‡ä¸­å‡ºç°å¤šæ¬¡ï¼‰ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬å–äº†è™šæ‹Ÿåœ°å€çš„ 19 ä½ç”¨äº tag çš„åŒ¹é…ï¼›è€Œæˆ‘ä»¬å›¾ä¸­æœ‰ 256 æ¡ cache line, å…¶è®¡ç®—æ–¹å¼æ˜¯æ ¹æ® cache çš„æ€»å¤§å°(32KB/4 set) é™¤ä»¥æ¯æ¡ cacheline çš„å¤§å°(32byte) å¾—åˆ°çš„ã€‚

:::tip tag åŒ¹é…æ—¶éœ€è¦å…¨é‡æ¯”è¾ƒå—ï¼Ÿ

æ³¨æ„æˆ‘ä»¬æ— è®ºä½¿ç”¨ä»€ä¹ˆæ˜ å°„æ–¹å¼ï¼Œè¦ç¡®å®šè¦è®¿é—®çš„å†…å­˜æ˜¯ä¸æ˜¯åœ¨ cache ä¸­ï¼Œå‡æ˜¯é€šè¿‡æ¯”è¾ƒ tag çš„æ–¹å¼æ¥å®ç°çš„ã€‚

è¿™å°±æ„å‘³ç€ï¼šæˆ‘ä»¬**éœ€è¦å’Œæ‰€æœ‰çš„ entry çš„ tag å­—æ®µè¿›è¡Œæ¯”è¾ƒ**ã€‚é€šå¸¸è€Œè¨€ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯æ¯”è¾ƒè€—æ—¶çš„ï¼›ä½†æ˜¯ç¡¬ä»¶è®¾è®¡é€šè¿‡ä¸€äº›ä¼˜åŒ–çš„æ‰‹æ®µï¼Œå¯ä»¥åŠ é€Ÿæˆ–è€…å¹¶è¡Œè¿™ä¸ªæ¯”è¾ƒçš„è¿‡ç¨‹ã€‚

ä»å¦ä¸€ä¸ªæ–¹é¢æ¥è¯´ï¼Œcache è¶Šå¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æ¯”è¾ƒçš„æ¬¡æ•°å°±è¶Šå¤šï¼›ä½†æ˜¯æ›´å°çš„ cache ä¼šå¯¼è‡´æ›´é«˜çš„ miss rate, æœ€ç»ˆå½±å“æ€§èƒ½ã€‚

:::

### 4.6. valid

> We also need a way to recognize that a cache block does not have valid information. For instance, when a processor starts up, the cache does not have good data, and the tag fields will be meaningless.

valid çš„å­˜åœ¨æ˜¯å› ä¸ºæˆ‘ä»¬è¿˜éœ€è¦æ ‡è¯† cache ä¸­çš„ä¿¡æ¯æ˜¯å¦æœ‰æ•ˆï¼Œæ¯”å¦‚è¯´è¿™è¾¹ä¸¾äº†ä¸€ä¸ªä¾‹å­ï¼Œè¯´çš„æ˜¯å¦‚æœå¤„ç†å™¨åˆšåˆšå¯åŠ¨çš„æ—¶å€™ï¼Œç¼“å­˜ä¸­çš„æ•°æ®è‚¯å®šæ˜¯æ— æ•ˆçš„ï¼Œvalid å­—æ®µå°±æ˜¯èµ·åˆ°è¿™æ ·ä¸€ä¸ªä½œç”¨ã€‚

### 4.7. ğŸ’¯data

å‰©ä¸‹çš„æ˜¯ data æˆ–è€… block å—ï¼Œå…¶å®åœ¨å®é™…çš„ cache ä¸­ï¼Œæˆ‘ä»¬é•¿è¿™æ ·ï¼ˆIntrinsity FastMATH data cache ä¸ºä¾‹ï¼‰ï¼š

| valid | tag | block 1 | block 2 | â€¦   | block n |
| ----- | --- | ------- | ------- | --- | ------- |
| 8     | 18  | 32      | 32      | â€¦   | 32      |

åœ¨ä¸Šè¿°çš„ä¾‹å­ä¸­ï¼Œblock æœ‰å¤šä¸ªï¼Œå®é™…æ„æˆäº†æ€»çš„ data,  è€Œæ¯ä¸ª block çš„å®šä½æ˜¯ä¾é åœ°å€ä¸­çš„æŸå‡ ä¸ªå­—èŠ‚åˆ†é…çš„åç§»é‡å†³å®šçš„ï¼Œæ¯”å¦‚æˆ‘ä»¬ä¸€å…±æœ‰ 16 ä¸ª block, åˆ™åœ°å€å­—æ®µéœ€è¦åˆ†é… 4 bit ç”¨äºè¡¨ç¤ºåç§»é‡ï¼Œæœ‰äº›è‹±æ–‡æ–‡æ¡£ä¸­ç§°ä½œ multiplexorï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¯ä¸ª cache line(entry) ä¸­å¯ä»¥ä¿å­˜çš„æ€»çš„æ•°æ®é‡ä¸ºï¼š32 bit * 16ã€‚

æˆ‘ä»¬ä¸¾ä¾‹ä¸€ä¸ªåœ°å€å­—æ®µæ¥è¯´æ˜è¿™ä¸ªï¼š

| 31 .. 14 | 13 .. 6 | 5..2                        | 1..0 |
| -------- | ------- | --------------------------- | ---- |
| tag      | index   | byte offset -> block offset |      |

è¿™ä¸ªä¾‹å­ä¸­çš„ 5..2 bit å°±æ˜¯ç”¨ä½œå®šä½åç§»å¾—çš„ã€‚

> Intrinsity FastMATH data cache  ä½¿ç”¨äº†æ•°æ® cache å’Œ æŒ‡ä»¤ cache åˆ†ç¦»çš„è®¾è®¡ã€‚

ä¸Šè¿°çš„è¯´æ˜å±äºæ¯”è¾ƒä¸“ä¸šçš„è¯´æ³•ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨è¾ƒä¸ºç®€å•çš„æ–¹å¼æ¥è¿›è¡Œç†è§£ï¼ˆå¯èƒ½ä¼šç¼ºå°‘ä¸€äº›ä¸¥è°¨æ€§ï¼‰

è®¿å­˜åœ°å€å¯ä»¥è¢«åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š**å—åœ°å€+å—å†…ä½ç§»**ã€‚å…¶ä¸­å—åœ°å€ç”¨äºæŸ¥æ‰¾è¯¥å—åœ¨ cache ä¸­çš„ä½ç½®ï¼Œå—å†…ä½ç§»ç”¨äºç¡®å®šæ‰€è®¿é—®çš„æ•°æ®åœ¨å—å†…çš„ä½ç½®ã€‚

:::note åˆ†é¡µ VS åˆ†æ®µ

ä¸Šè¿°çš„è®¿å­˜åœ°å€è®¡ç®—çš„æ–¹å¼æ˜¯é€‚ç”¨äº*é¡µè™šæ‹Ÿå­˜å‚¨å™¨*ï¼Œ å¯¹äºæ®µè™šæ‹Ÿå¯„å­˜å™¨ï¼Œå¯ä»¥ç”¨ä¸¤ä¸ªå­—æ¥è¡¨ç¤ºï¼šæ®µå·+æ®µå†…åç§»ã€‚å…³äºè™šæ‹Ÿå†…å­˜å¯ä»¥å‚è€ƒå¦å¤–çš„ä¸€éæ–‡ç« ã€ŠVirtual Memoryã€‹

:::

## 5. cache æ˜ å°„æ–¹å¼

æ˜ å°„æ–¹å¼ä¸»è¦ç”±ä»¥ä¸‹å‡ ç§ï¼š

1. å…¨ç›¸è” cachem, full-associative cache
2. ç›´æ¥æ˜ å°„ cache, direct-mapped cache
3. ç»„ç›¸è” cache, set-associative cache
- å¦‚æœä¸€ä¸ªå—å¯ä»¥æ”¾åœ¨ç¼“å­˜ä¸­çš„ä»»æ„ä½ç½®ï¼Œé‚£ä¹ˆå°±æ˜¯å…¨ç›¸è”çš„ï¼›
- å¦‚æœæ¯ä¸ªå—åªèƒ½å‡ºç°åœ¨ç¼“å†²ä¸­çš„ä¸€ä¸ªä½ç½®ï¼Œå°±è¯´è¯¥ç¼“å­˜æ˜¯ç›´æ¥æ˜ å°„çš„ï¼›æ˜ å°„çš„æ–¹å¼ä¸º **ï¼ˆå—åœ°å€ï¼‰MOD ï¼ˆç¼“å­˜ä¸­çš„å—æ•°ï¼‰**ï¼›
- å¦‚æœä¸€ä¸ªå—å¯ä»¥æ”¾åœ¨ç¼“å­˜ä¸­ç”±æœ‰é™ä¸ªä½ç½®ç»„æˆçš„ç»„ï¼ˆsetï¼‰ä¸­ï¼Œå°±è¯´è¯¥ç¼“å­˜æ˜¯ç»„ç›¸è”çš„ï¼›åœ¨ç»„å†…ï¼Œè¿™ä¸ªå—å¯ä»¥æ”¾åœ¨ä»»æ„ä½ç½®ï¼›å¦‚æœç»„ä¸­ n ä¸ªå—ï¼Œå°±å«åš n è·¯ç»„ç›¸è”ã€‚

### 5.1. full-associative

ä¸»å­˜ä¸­çš„æ¯ä¸ªæ•°æ®å—å¯ä»¥å­˜æ”¾åˆ°ç¼“å­˜çš„ä»»ä½•ä½ç½®ï¼š

- **ä¼˜ç‚¹**ï¼šæœ€å°åŒ–å†²çªæœªå‘½ä¸­ã€‚

- **ç¼ºç‚¹**ï¼šç¡¬ä»¶å®ç°å¤æ‚ï¼Œéœ€è¦å¹¶è¡Œæ¯”è¾ƒæ‰€æœ‰ç¼“å­˜è¡Œã€‚

è¿™ç§æ–¹å¼æœ‰ä¸ªä¼˜ç‚¹å°±æ˜¯å†…å­˜ä¸­çš„æ¯ä¸ª line(æ³¨æ„åˆ°å†…å­˜ä¸­æ˜¯å—å­˜å‚¨çš„ï¼Œä¸ºäº†æ–¹ä¾¿ç†è§£è¿™é‡Œä¹Ÿè¯´å¾— line) å¯ä»¥æ˜ å°„åˆ°ä»»æ„çš„ cache line ä¸­ï¼Œä»è¿™ä¸ªè§’åº¦çœ‹ï¼Œfull-associate æ•ˆç‡æ›´å¥½ï¼Œä½†æ˜¯å…¶æŸ¥æ‰¾è¿‡äºå¤æ‚ã€‚

### 5.2. direct-mapped

ä¸»è¦çš„æ€æƒ³æ˜¯æŠŠå†…å­˜åˆ†ä¸º N ä¸ª page, æ¯ä¸€ä¸ª page çš„å¤§å°å’Œ cache ç›¸åŒï¼Œpage ä¸­çš„ Line 0 åªèƒ½æ˜ å°„åˆ° cache ä¸­çš„ Line 0, ä»¥æ­¤ç±»æ¨ï¼›æ¯ä¸ªä¸»å­˜å—åªèƒ½æ˜ å°„åˆ°ç¼“å­˜ä¸­çš„ä¸€ä¸ªå›ºå®šä½ç½®ï¼š

- **æ˜ å°„æ–¹å¼**ï¼šIndex = (Memory Address) MOD (Cache Size)
- **ä¼˜ç‚¹**ï¼šç¡¬ä»¶å®ç°ç®€å•ã€‚
- **ç¼ºç‚¹**ï¼šå®¹æ˜“äº§ç”Ÿå†²çªæœªå‘½ä¸­ï¼ˆConflict Missï¼‰ã€‚

å…¶ç¤ºæ„å›¾å¦‚ä¸‹æ‰€ç¤ºï¼š

![direct-mapped](https://documentation-service.arm.com/static/5ff5c9fd89a395015c28fc8e?token=)

ç›´æ¥æ˜ å°„æ„å‘³ç€ç¡®å®šçš„æ˜ å°„æ–¹å¼ï¼Œå¦‚å›¾ä¸­çš„ 0x00, 0x40, 0x80 éƒ½åªèƒ½æ˜ å°„åˆ° Line 0 ä¸­ã€‚

### 5.3. set-associative

ç¼“å­˜è¢«åˆ†æˆå¤šä¸ª**ç»„ï¼ˆSetï¼‰**ï¼Œæ¯ä¸ªç»„åŒ…å«å¤šä¸ª**è·¯ï¼ˆWayï¼‰**ï¼š**N è·¯ç»„ç›¸è”ï¼ˆN-Way Set Associativeï¼‰**è¡¨ç¤ºæ¯ä¸ªç»„åŒ…å« N ä¸ªç¼“å­˜è¡Œã€‚

**2 è·¯ç»„ç›¸è”ç¤ºä¾‹**ï¼š

```
Set 0:  | Way 0 | Way 1 |
Set 1:  | Way 0 | Way 1 |
...
```



direvt-mapped çš„æ–¹å¼æ˜¯å¤„ç†å™¨ä¸Šæ¯”è¾ƒå¸¸ç”¨çš„ï¼Œä½†æ˜¯åœ¨æŸäº›ç‰¹å®šçš„æƒ…å†µä¸‹ä¼šå­˜åœ¨å¾ˆå¤§çš„ç¼ºé™·ï¼Œæ‰€ä»¥ç°ä»£çš„å•†ç”¨å¤„ç†å™¨éƒ½æ˜¯ç”¨ set-associative cache æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬è¿™èŠ‚è¦ç ”ç©¶çš„ã€‚

set-associative å°† cache åˆ†æˆäº†å¤šä¸ª way, `direvt-mapped == 1 way set-associative`ï¼Œ ä½¿ç”¨å¤šå°‘ä¸ª cache way ä¹Ÿæ˜¯ä¸€ç§æƒè¡¡çš„ç»“æœã€‚

ä¸¾ä¾‹ï¼Œä»¥ä¸‹æ˜¯å››è·¯ç»„ç›¸è”çš„ç»“æ„ï¼ˆä¸€è·¯æ˜¯ç›´æ¥æ˜ å°„ï¼‰ï¼š

| set | tag   | data  |     | tag   | data  |     | tag   | data  |     | tag   | data  |
|:---:| ----- | ----- | --- | ----- | ----- | --- | ----- | ----- | --- | ----- | ----- |
| 0   | way 0 | way 0 |     | way 1 | way 1 |     | way 2 | way 2 |     | way 3 | way 3 |
| 1   |       |       |     |       |       |     |       |       |     |       |       |
| â€¦   |       |       |     |       |       |     |       |       |     |       |       |
| n   |       |       |     |       |       |     |       |       |     |       |       |

#### 5.3.1. Arm docs: Set associative caches

> With this kind of cache organization, the cache is divided into a number of equally-sized pieces, called *ways*.[^3]

cache è¢«åˆ†å‰²æˆä¸ºäº†ä¸€äº›ç›¸åŒå¤§å°çš„å—ï¼Œç§°ä½œ ways.

> A memory location can then map to a way rather than a line. The index field of the address continues to be used to select a particular line, but now it points to an individual line in each way. Commonly, there are 2- or 4-ways, but some ARM implementations have used higher numbers.

![arm_cache_set_ass](https://documentation-service.arm.com/static/5ff5c9fd89a395015c28fc56?token=)

å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œè¿™æ˜¯ä¸€ä¸ª 2-way cache çš„ç»“æ„ç¤ºæ„å›¾ï¼›åœ¨ä¸Šå›¾ä¸­ï¼šData from address `0x00` (or `0x40`, or `0x80`) might be found in line 0 of either (but not both) of the two cache ways.

#### 5.3.2. Arm docs: A real-life example

![A real-life example](https://documentation-service.arm.com/static/5ff5c9fd89a395015c28fc35?token=)

Figure: a 4-way set associative 32KB data cache, with an 8-word(1 word equals 16 bits) cache line length. This kind of cache structure can be found on the Cortex-A7 or Cortex-A9 processors.

- cache line çš„å¤§å°æ˜¯ 32 bytes(8 word = 8 * 32 bits =32 bytes, æ³¨æ„ä¸€ä¸ª word åœ¨ arm ä¸­æ˜¯ 32bits)

- cache æ€»å¤§å°ä¸º 32KB

- è¿æ¥æ–¹å¼æ˜¯ 4 è·¯ç»„ç›¸è¿

ç”±æ­¤æˆ‘ä»¬å¯ä»¥è®¡ç®—å‡ºæ¥ï¼Œæ¯ä¸ª way çš„ cacheline æ•°é‡ä¸ºï¼š$32KB/4/32=256$, æ‰€ä»¥æˆ‘ä»¬æ¯ä¸ª way ä¼šæœ‰ 256 æ¡ cacheline. è¿™å°±æ„å‘³ç€æˆ‘ä»¬éœ€è¦ 8 bits æ¥åœ¨ way ä¸­ç´¢å¼•ï¼Œåœ¨é€”ä¸­å°±æ˜¯ç”¨ [12:5] æ¥ç´¢å¼•çš„ï¼›é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ [4:2] æ¥ç´¢å¼• cache line ä¸­çš„ 8 ä¸ª word. å‰©ä¸‹çš„ [31:13] ç”¨äº tag.

â¤ï¸ æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå›¾ä¸­å‡ºç°äº† 4 ä¸ª way å åŠ å¤„ç†ï¼Œæ¯ä¸ª way éƒ½æ˜¯ç”± 256 æ¡ cacheline ç»„æˆçš„ï¼›å›¾ä¸­å¹¶æœªä½“ç°å‡ºå¤šä¸ª setï¼Œåªç”»äº†ä¸€ä¸ª set. ç°åœ¨å†ä½“ä¼šä¸€ä¸‹è¿™å¥è¯ï¼šA way is a subset of the cache entries in a set that have the same index but different tags.

:::details Arm åŸæ–‡å‚è€ƒ

> The cache line length is eight words (32 bytes) and you have 4-ways. 32KB divided by 4 (the number of ways), divided by 32 (the number of bytes in each line) gives you a figure of 256 lines in each way. This means that you require eight bits to index a line within a way (bits [12:5]). Here, you must use bits [4:2] of the address to select from the eight words within the line, though the number of bits which are required to index into the line depends on whether you are accessing a word, halfword, or byte. The remaining bits [31:13] in this case will be used as a tag.

:::

#### 5.3.3. QA

1. æˆ‘ä»¬çŸ¥é“ï¼Œcacheline åŒ…æ‹¬ tag, set index å’Œ offset bit, å…¶ä¸­ offset bit ç”¨äºå®šä½æ•°æ®åœ¨ cacheline ä¸­å…·ä½“çš„åç§»ï¼Œé‚£ä¹ˆæ˜¯å¦‚ä½•ä»…æ ¹æ®ä¸€ä¸ª offset å°±èƒ½ç¡®å®šå…·ä½“çš„æ•°æ®è¦å–å¤šå°‘ä¸ª byte å‘¢ï¼Ÿ
   
   è¦è§£ç­”è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“ï¼Œåœ¨ ldr æˆ–è€…å…¶ä»–è®¿å­˜ç±»æŒ‡ä»¤å‘å‡ºä»¥åï¼ŒCPU æ˜¯çŸ¥é“è¿™æ¬¡è®¿é—®éœ€è¦çš„æ•°æ®å¤§å°çš„(byte); æˆ‘ä¹‹å‰æƒ³ä¸æ˜ç™½çš„æ˜¯ï¼Œæ˜¯å¦‚ä½•çŸ¥é“çš„å‘¢ï¼Ÿå…¶å®å¾ˆç®€å•ï¼Œæˆ‘ä»¬åœ¨æŒ‡ä»¤ä¸Šå·²ç»æŒ‡å®šäº†éœ€è¦è®¿é—®çš„æ•°æ®å¤§å°ï¼Œå¦‚ `ldr x1, #234` å°±æ˜¯é€šè¿‡å¯„å­˜å™¨æŒ‡å®šæˆ‘ä»¬éœ€è¦çš„è®¿é—®æ˜¯ 16 å­—èŠ‚ã€‚

### 5.4. Summary

ä¸‰ç§æ–¹å¼çš„å¯¹æ¯”ï¼š

| æœºåˆ¶   | ç»„çš„æ•°é‡              | æ¯ç»„ä¸­å—çš„æ•°é‡     |
|:----:|:-----------------:|:-----------:|
| å…¨ç›¸è”  | 1                 | cache ä¸­å—çš„æ•°é‡ |
| ç›´æ¥æ˜ å°„ | cache ä¸­å—çš„æ•°é‡       | 1           |
| ç»„ç›¸è”  | cache ä¸­å—çš„æ•°é‡ / ç›¸è”åº¦ | ç›¸è”åº¦ï¼ˆé€šå¸¸2~16ï¼‰ |

å¢åŠ ç›¸è”åº¦çš„å¥½å¤„é€šå¸¸æ˜¯é™ä½å¤±æ•ˆç‡ï¼Œå¤±æ•ˆç‡çš„æ”¹è¿›æ¥è‡ªäºå‡å°‘å¯¹äºåŒä¸€ä½ç½®çš„ç«äº‰è€Œäº§ç”Ÿçš„å¤±æ•ˆã€‚

ä¸‰ç§æ–¹å¼è¿›è¡ŒæŸ¥æ‰¾çš„å¯¹æ¯”ï¼š

| æœºåˆ¶   | å®šä½æ–¹æ³•         | éœ€è¦æ¯”è¾ƒçš„æ¬¡æ•°  |
|:----:|:------------:|:--------:|
| å…¨ç›¸è”  | æŸ¥æ‰¾æ‰€æœ‰cache è¡¨é¡¹ | cache å®¹é‡ |
|      | ç‹¬ç«‹çš„æŸ¥æ‰¾è¡¨       | 0        |
| ç›´æ¥æ˜ å°„ | ç´¢å¼•           | 1        |
| ç»„ç›¸è”  | ç´¢å¼•ç»„ï¼Œç»„ä¸­çš„å…ƒç´     | ç›¸è”åº¦      |

## 6. å¤„ç† Cache Miss

cache hit(å‘½ä¸­)ï¼šè¯»å–æ—¶é—´ X ä¸ª cycle

cache missï¼šè¯»å–æ—¶é—´ XX æˆ–è€… XXX ä¸ª cycle

æ‰€ä»¥ hit å’Œ miss æœ‰å¾ˆå¤§çš„æ€§èƒ½å·®è·ã€‚

### 6.1. Why cache miss?

æœ‰ä¸‰ç§æƒ…å†µä¼šå¯¼è‡´ cache misss:

1. **å¼ºåˆ¶æœªå‘½ä¸­ï¼ˆCompulsory Missï¼‰**ï¼šé¦–æ¬¡è®¿é—®æŸæ•°æ®ï¼Œæ— æ³•å‘½ä¸­ç¼“å­˜ã€‚å¿…é¡»çš„ missï¼Œå¦‚ç¬¬ä¸€æ¬¡è®¿é—®ç¨‹åºæˆ–è€…æ•°æ®æ—¶ï¼Œè¿™äº›ç¨‹åºæˆ–è€…æ•°æ®æ²¡æœ‰åœ¨ cache ä¸­ã€‚
1. **å®¹é‡æœªå‘½ä¸­ï¼ˆCapacity Missï¼‰**ï¼šç¼“å­˜ç©ºé—´ä¸è¶³ï¼Œå¯¼è‡´æ•°æ®è¢«æ›¿æ¢ã€‚cache å®¹é‡æ»¡äº†çš„æ—¶å€™ï¼Œæ–°æ•°æ®åˆ°æ¥ï¼Œéœ€è¦é‡æ–°æ¬ç§»ï¼Œå°± miss äº†ï¼›æˆ–è€…è¿˜å­˜åœ¨ä¸€ç§æƒ…å†µæ˜¯ cache æ— æ³•åŒ…å«ç¨‹åºæ‰§è¡ŒæœŸé—´æ‰€éœ€çš„æ‰€æœ‰å—ã€‚
1. **å†²çªæœªå‘½ä¸­ï¼ˆConflict Missï¼‰**ï¼šç›´æ¥æ˜ å°„ç¼“å­˜ä¸­ï¼Œä¸åŒæ•°æ®å—ç«äº‰åŒä¸€ç¼“å­˜è¡Œã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œcache å¯èƒ½è¿˜æœ‰ç©ºé—²ç©ºé—´ï¼Œä½†æ˜¯è¿™ä¸ªåœ°å€å¯¹åº”çš„ cache line å·²ç»è¢«ä½¿ç”¨äº†ï¼Œä¹Ÿä¼šå¯¼è‡´ cache miss.

```mermaid
flowchart LR
    1(3C)
    1.1(Compulsory miss, å¼ºåˆ¶å¤±æ•ˆ)
    1.2(Capacity miss, å®¹é‡å¤±æ•ˆ)
    1.3(Conflict miss, å†²çªå¤±æ•ˆ)
    1 --> 1.1 & 1.2 & 1.3
    1.2.1(å¢åŠ cache)
    1.2 -.- 1.2.1
```

---



### 6.2. å‡å°‘ Miss: ä½¿ç”¨è¾ƒå¤§çš„ block

è¾ƒå¤§çš„ blocks åˆ©ç”¨ç©ºé—´å±€éƒ¨æ€§åŸç†æ¥é™ä½ miss rate, é€šå¸¸è€Œè¨€ï¼Œå¢åŠ å—çš„å¤§å°ä¼šé™ä½ miss rate, ä½†æ˜¯å…¶å­˜åœ¨ä¸€ä¸ªé˜ˆå€¼ï¼Œå¦‚æœ block çš„å¤§å°æˆä¸ºç¼“å­˜å¾ˆå¤§çš„ä¸€éƒ¨åˆ†ï¼Œæœ€ç»ˆ miss rate åè€Œä¼šä¸Šå‡ï¼Œè¿™æ˜¯å› ä¸ºç¼“å­˜ä¸­å¯ä»¥ä¿å­˜çš„å—çš„æ•°é‡å˜å°‘ï¼Œå¯¼è‡´äº†å¾ˆå¤šç«äº‰ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œä½¿ç”¨è¾ƒå¤§çš„ blocks ä¼šé€ æˆ cache æœªå‘½ä¸­çš„æ—¶å€™çš„ä»£ä»·å˜å¤§ï¼Œä¸»è¦æ˜¯ä½“ç°åœ¨ cache åŠ è½½çš„æ—¶å€™(fetch the block), è¿™ä¸ªè¿‡ç¨‹åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼š**the latency to the first word and the transfer**

ğŸ§¡ğŸ§¡ğŸ§¡ æˆ‘ä»¬å¯ä»¥è·å¾—ä¸€ä¸ªå¯å‘ï¼š**å¦‚æœæˆ‘ä»¬å¯ä»¥è®¾è®¡æ–¹æ³•é™ä½è¾ƒå¤§çš„ block çš„ transfer time, é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è¿›ä¸€æ­¥æ”¹å–„ç¼“å­˜çš„æ€§èƒ½ã€‚**

### 6.3. Hide Some Transfer Time

åœ¨ä½¿ç”¨è¾ƒå¤§çš„ block æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡**éšè—ä¸€äº›ä¼ è¾“æ—¶é—´**çš„æ–¹æ³•æ¥å‡å°‘æœªå‘½ä¸­çš„æƒ©ç½šã€‚è¿™ç§ç­–ç•¥çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼Œåœ¨ç¼“å­˜æœªå‘½ä¸­æ—¶ï¼Œå°½å¯èƒ½å‡å°‘ CPU ç­‰å¾…æ•°æ®çš„æ—¶é—´ï¼Œä½¿å¾—æ•°æ®ä¼ è¾“å’Œè®¡ç®—èƒ½å¤Ÿæ›´å¥½åœ°é‡å ï¼Œæé«˜æ•´ä½“æ€§èƒ½ã€‚ä»¥ä¸‹æ˜¯ä¸¤ç§ä¸»è¦çš„å®ç°æ–¹å¼ï¼š

#### 6.3.1. Early Startï¼ˆæå‰å¼€å§‹ï¼‰

åœ¨ä¼ ç»Ÿçš„ç¼“å­˜åŠ è½½è¿‡ç¨‹ä¸­ï¼Œæ•´ä¸ª cache blockï¼ˆå¦‚ 64B æˆ–æ›´å¤§ï¼‰éœ€è¦å®Œå…¨è½½å…¥åï¼Œå¤„ç†å™¨æ‰èƒ½å¼€å§‹ä½¿ç”¨å…¶ä¸­çš„æ•°æ®ã€‚ä½†åœ¨ **early start** æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬åœ¨ block è¿˜æœªå®Œå…¨ä¼ è¾“å®Œæˆæ—¶ï¼Œå°±å¯ä»¥å¼€å§‹å¤„ç†å·²ç»åˆ°è¾¾çš„éƒ¨åˆ†æ•°æ®ã€‚

**åŸç†**ï¼šåœ¨ä»ä¸»å­˜æˆ–æ›´é«˜çº§åˆ«ç¼“å­˜ï¼ˆå¦‚ L2ã€L3ï¼‰åŠ è½½æ•°æ®æ—¶ï¼Œæ•°æ®é€šå¸¸æ˜¯æŒ‰ **burst mode**ï¼ˆçªå‘æ¨¡å¼ï¼‰æˆ–å¤šä¸ªå°å—ä¼ è¾“çš„ã€‚åœ¨æ•°æ®å—çš„ä¸€éƒ¨åˆ†åˆ°è¾¾åï¼Œå¤„ç†å™¨å¯ä»¥ç«‹å³ä½¿ç”¨è¿™äº›æ•°æ®ï¼Œè€Œä¸å¿…ç­‰åˆ°æ•´ä¸ª block å…¨éƒ¨åŠ è½½å®Œæˆã€‚è¿™æ ·å¯ä»¥éšè—ä¸€éƒ¨åˆ†ä¼ è¾“æ—¶é—´ï¼Œä»è€Œå‡å°‘ç¼“å­˜æœªå‘½ä¸­çš„æ€§èƒ½æŸå¤±ã€‚

**ç¤ºä¾‹ï¼š**ï¼šå‡è®¾ CPU éœ€è¦è®¿é—®ä¸€ä¸ª 64B çš„ blockï¼Œä½†è¯¥ block éœ€è¦ 8 ä¸ªæ—¶é’Ÿå‘¨æœŸæ‰èƒ½å®Œå…¨ä¼ è¾“å®Œæˆã€‚å¦‚æœé‡‡ç”¨ **early start**ï¼ŒCPU å¯ä»¥åœ¨ç¬¬ 2 ä¸ªæ—¶é’Ÿå‘¨æœŸæ—¶ï¼Œå°±å¼€å§‹ä½¿ç”¨å·²ç»åˆ°è¾¾çš„ 8B æ•°æ®ï¼Œè€Œä¸å¿…ç­‰åˆ°ç¬¬ 8 ä¸ªæ—¶é’Ÿå‘¨æœŸå†ä½¿ç”¨å®Œæ•´æ•°æ®å—ã€‚

é€‚ç”¨äº **é¡ºåºè®¿é—®** åœºæ™¯ï¼Œä¾‹å¦‚æµå¼å¤„ç†ã€æ•°ç»„éå†ç­‰ï¼›é™¤æ­¤ä¹‹å¤–ï¼Œé€‚ç”¨äº **é¢„å–** æœºåˆ¶ï¼Œä½¿å¾—å¤„ç†å™¨åœ¨ç¼“å­˜æœªå‘½ä¸­æ—¶ï¼Œä»èƒ½å°½æ—©å¼€å§‹æ‰§è¡Œéƒ¨åˆ†è®¡ç®—ã€‚

#### 6.3.2. Requested(Critical) Word First

åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼ŒCPU å®é™…ä¸Šåªéœ€è¦ cache block ä¸­çš„æŸä¸ªç‰¹å®šå­—ï¼Œè€Œä¸æ˜¯æ•´ä¸ª blockã€‚å¦‚æœ CPU èƒ½å¤Ÿ **ä¼˜å…ˆåŠ è½½å…³é”®å­—ï¼ˆCritical Wordï¼‰**ï¼Œé‚£ä¹ˆå°±å¯ä»¥å¤§å¹…å‡å°‘ç¼“å­˜æœªå‘½ä¸­çš„å½±å“ã€‚

**åŸç†**ï¼šä¼ ç»Ÿçš„ç¼“å­˜å¡«å……æ–¹å¼æ˜¯ **whole block fetch**ï¼Œå³æŒ‰ç…§ cache block å¤§å°ï¼ˆå¦‚ 64Bï¼‰é¡ºåºåŠ è½½æ•°æ®ã€‚**Critical Word First** ç­–ç•¥æ”¹å˜äº†è¿™ä¸€æ–¹å¼ï¼Œä½¿å¾— **CPU éœ€è¦çš„é‚£ä¸ªå­—**ï¼ˆcritical wordï¼‰è¢«ä¼˜å…ˆåŠ è½½ï¼Œå¹¶å°½æ—©æä¾›ç»™å¤„ç†å™¨ï¼Œè€Œå…¶ä½™éƒ¨åˆ†å¯ä»¥ç¨åå†å¡«å……ã€‚**Requested Word First** æ˜¯ Critical Word First çš„ä¸€ç§ç‰¹ä¾‹ï¼ŒæŒ‡çš„æ˜¯ä»…åŠ è½½è¯·æ±‚çš„å­—ï¼Œè€Œä¸åŠ è½½æ•´ä¸ª blockã€‚

**ç¤ºä¾‹**ï¼šå‡è®¾ CPU è®¿é—® 64B cache block ä¸­çš„ä¸€ä¸ª 4B å­—ï¼ˆwordï¼‰ï¼Œä½†è¯¥ block å½“å‰ä¸åœ¨ç¼“å­˜ä¸­ï¼š

- **ä¼ ç»Ÿæ–¹å¼ï¼ˆWhole Block Fetchï¼‰**ï¼šä»ä¸»å­˜åŠ è½½æ•´ä¸ª 64B blockï¼ŒCPU éœ€è¦ç­‰æ•´ä¸ªæ•°æ®åˆ°è¾¾åæ‰èƒ½ç»§ç»­æ‰§è¡Œã€‚
- **Critical Word First**ï¼šCPU **ä¼˜å…ˆåŠ è½½æ‰€è¯·æ±‚çš„ 4B å­—**ï¼Œç„¶åå†ç»§ç»­åŠ è½½å‰©ä½™éƒ¨åˆ†ã€‚
- **Requested Word First**ï¼šåªåŠ è½½æ‰€è¯·æ±‚çš„ 4B å­—ï¼Œä¸å¡«å……æ•´ä¸ª blockï¼ˆé€‚ç”¨äºæŸäº›ç‰¹å®šæ¶æ„ï¼‰ã€‚

**é€‚ç”¨åœºæ™¯**

- **éšæœºè®¿é—®** æ¨¡å¼ï¼Œå¦‚æŒ‡é’ˆæ“ä½œã€é“¾è¡¨éå†ç­‰ï¼ŒæŸä¸ª block åªå¯èƒ½ç”¨åˆ°éƒ¨åˆ†æ•°æ®ã€‚
- **å­˜å‚¨å¸¦å®½å—é™** çš„åœºæ™¯ï¼Œå‡å°‘ä¸å¿…è¦çš„æ•°æ®ä¼ è¾“ï¼Œæé«˜ç¼“å­˜å“åº”é€Ÿåº¦ã€‚

**æ€»ç»“**

â€‹	â€¢	**Early Start**ï¼šé€‚ç”¨äºé¡ºåºæ•°æ®è®¿é—®ï¼Œä½¿å¤„ç†å™¨å¯ä»¥å°½æ—©ä½¿ç”¨å·²åˆ°è¾¾çš„æ•°æ®ã€‚

â€‹	â€¢	**Critical Word First / Requested Word First**ï¼šé€‚ç”¨äºéšæœºè®¿é—®ï¼Œä½¿ CPU èƒ½å°½å¿«æ‹¿åˆ°æ‰€éœ€æ•°æ®ï¼Œå‡å°‘ç¼“å­˜æœªå‘½ä¸­æƒ©ç½šã€‚

ä¸¤è€…çš„å…±åŒç›®æ ‡æ˜¯ **å‡å°‘ç¼“å­˜æœªå‘½ä¸­å¸¦æ¥çš„ CPU åœæ»æ—¶é—´ï¼Œæé«˜ç³»ç»Ÿååé‡**ã€‚

### 6.4. Handling cache misses

- ç¼“å­˜å¤„ç†èµ·æ¥ hit çš„å·¥ä½œç›¸æ¯”äº miss æ˜¯å¾®ä¸è¶³é“çš„ã€‚
- cache miss handing éœ€è¦å¤„ç†å™¨æ§åˆ¶å•å…ƒå’Œå•ç‹¬çš„æ§åˆ¶å™¨åˆä½œå®Œæˆï¼Œè¿™ä¸ªå•ç‹¬çš„æ§åˆ¶å™¨å¯åŠ¨å†…å­˜è®¿é—®ã€å¡«å……ç¼“å­˜
- ç¼“å­˜æœªå‘½ä¸­çš„å¤„ç†ä¼šå¯¼è‡´æµæ°´çº¿ stall, æ­¤æ—¶éœ€è¦ä¿å­˜æ‰€æœ‰å¯„å­˜å™¨çš„çŠ¶æ€
- ç¼“å­˜æœªå‘½ä¸­ï¼ˆå¤„ç†æŒ‡ä»¤æœªå‘½ä¸­ã€å¤„ç†æ•°æ®æœªå‘½ä¸­ï¼‰ä¼šå¯¼è‡´æ•´ä¸ªå¤„ç†å™¨æš‚åœï¼Œå†»ç»“ä¸´æ—¶å¯„å­˜å™¨å’Œç¨‹åºå‘˜å¯è§å¯„å­˜å™¨çš„å†…å®¹ï¼ŒåŒæ—¶ç­‰å¾…å†…å­˜ã€‚ï¼ˆæ³¨æ„ä¸€ä¸‹ï¼Œä¹±åºæ‰§è¡Œçš„å¤„ç†å™¨æ­¤æ—¶è¿˜å¯ä»¥å…è®¸æ‰§è¡ŒæŒ‡ä»¤ï¼‰

å¤„ç†ç¼“å­˜ miss çš„æ­¥éª¤å¤§æ¦‚å¯ä»¥æ€»ç»“å¦‚ä¸‹ï¼ˆä¸»è¦ç ”ç©¶æŒ‡ä»¤ missï¼‰ï¼š

1. å‘é€ PC å€¼åˆ°å†…å­˜
   
   Since the program counter is incremented in the first clock cycle of execution, the address of **the instruction that generates an instruction cache miss** is equal to the value of the program counter minus 4.
   
   å¦‚ä½•ç†è§£ the instruction that generates an instruction cache miss? å…¶å®æˆ‘ä»¬åªè¦äº†è§£åˆ°ï¼Œcache miss ä»¥åï¼ŒPC å¯„å­˜å™¨å‘å‰èµ°äº†ï¼Œæ‰€ä»¥è¿™æ—¶å€™æˆ‘ä»¬éœ€è¦å‘åèµ°å»æ‰¾åˆ°è¿™ä¸ª miss çš„æŒ‡ä»¤çš„åœ°å€ï¼Œç„¶åå†å»å†…å­˜ä¸­æ‰¾ï¼Œå°±å¯ä»¥äº†ï¼

2. æ§åˆ¶ä¸»å­˜æ‰§è¡Œè¯»å–ï¼Œå¹¶ç­‰å¾…å†…å­˜å®Œæˆè®¿é—®

3. å†™å…¥ç¼“å­˜ï¼Œå°†å†…å­˜ä¸­çš„æ•°æ®æ”¾å…¥ç¼“å­˜çš„æ•°æ®éƒ¨åˆ†ï¼Œtag å†™å…¥åœ°å€ï¼ˆfrom ALUï¼‰çš„é«˜ä½ï¼Œå¹¶æ‰“å¼€æœ‰æ•ˆä½

4. é‡å¯æŒ‡ä»¤çš„æ‰§è¡Œï¼Œè¿™å°†é‡æ–°è¯»å–æŒ‡ä»¤ï¼Œè¿™æ˜¯åœ¨ç¼“å­˜ä¸­å°±å¯ä»¥æ‰¾åˆ°è¯¥æŒ‡ä»¤

## 7. **ç¼“å­˜æ›¿æ¢ç­–ç•¥**

å½“ç¼“å­˜æ»¡æ—¶ï¼Œéœ€æ›¿æ¢æŸä¸ªæ•°æ®å—ã€‚å¸¸è§ç­–ç•¥åŒ…æ‹¬ï¼š

| **ç­–ç•¥**                | **æè¿°**                 |
| ----------------------- | ------------------------ |
| **LRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰** | æ›¿æ¢æœ€ä¹…æœªè¢«è®¿é—®çš„ç¼“å­˜è¡Œ |
| **FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰**    | æ›¿æ¢æœ€æ—©è¿›å…¥ç¼“å­˜çš„ç¼“å­˜è¡Œ |
| **éšæœºæ›¿æ¢**            | éšæœºé€‰æ‹©ç¼“å­˜è¡Œè¿›è¡Œæ›¿æ¢   |

LRU æˆ‘ä»¬ä½¿ç”¨çš„æœ€å¤šï¼Œå¹¶ä¸”æ€§èƒ½ä¹Ÿæœ€å¥½ã€‚

å…³äºæ›¿æ¢ç­–ç•¥çš„é€‰æ‹©ï¼Œä¹Ÿæœ‰ä¸€äº›è€ƒé‡åœ¨é‡Œé¢ï¼Œå¹¶ä¸æ˜¯ LRU å°±ä¸€å®šæ˜¯æœ€å¥½çš„ï¼Œæˆ‘ä»¬ä¸¾ä¾‹è¯´æ˜ï¼š

- åœ¨ç›¸è”åº¦ä¸ä½ï¼ˆ2ï¼Œ4ï¼‰çš„å±‚æ¬¡ç»“æ„ä¸­å®ç° LRU çš„ä»£ä»·å¤ªé«˜ï¼Œæ‰€ä»¥ä¸€èˆ¬ä½¿ç”¨è¿‘ä¼¼å®ç°
- éšç€ cache å®¹é‡å˜å¤§ï¼Œä¸¤ç§æ›¿æ¢ç­–ç•¥çš„æ€§èƒ½å·®å¼‚ä¹Ÿé€æ¸ç¼©å°
- åœ¨è™šæ‹Ÿå­˜å‚¨ä¸­ï¼Œä½¿ç”¨ LRU æ˜¯å› ä¸ºå¤±æ•ˆä»£ä»·å¾ˆå¤§ï¼Œå¤±æ•ˆç‡çš„å¾®å°é™ä½éƒ½æ˜¾å¾—ååˆ†é‡è¦ï¼›å¹¶ä¸”å…¶å¤±æ•ˆç›¸å¯¹ä¸é‚£ä¹ˆé¢‘ç¹å‘ç”Ÿï¼ŒLRU ä¹Ÿå¯ä»¥ç”±è½¯ä»¶è¿‘ä¼¼å®ç°

## 8. Cache Write

æ‰€è°“ cache å†™ï¼ŒæŒ‡çš„å°±æ˜¯ cpu ä¿®æ”¹äº† cache ä¸­çš„æ•°æ®çš„æ—¶å€™ï¼Œå†…å­˜çš„æ•°æ®ä¹Ÿè¦éšä¹‹æ”¹å˜ã€‚ä¸ºäº†è¾¾åˆ°è¿™ä¸ªç›®çš„ï¼Œcache æä¾›äº†å‡ ç§å†™ç­–ç•¥ï¼š

1. Write through
2. Write buffer
3. Write back

### 8.1. Write through

æ ¸å¿ƒç­–ç•¥ï¼šæ¯æ¬¡ CPU ä¿®æ”¹äº† cache ä¸­çš„å†…å®¹ï¼Œcache ç«‹å³æ›´æ–°ï¼ˆcache æ§åˆ¶å™¨ï¼‰å†…å­˜ä¸­çš„å†…å®¹ã€‚

è¿™ç§æ–¹å¼ä¼šæœ‰å¤§é‡å†™å†…å­˜çš„æ“ä½œï¼Œæ‰€ä»¥æ•ˆç‡è¾ƒä½ã€‚

### 8.2. Write buffer

> A queue that holds data while the data are waiting to be written to memory.

Write buffer ä¸­ä¿å­˜äº†å‡†å¤‡å†™å…¥å†…å­˜çš„æ•°æ®ï¼Œå¤„ç†å™¨åŒæ—¶å†™å…¥ cache å’Œ write buffer, è€Œåœ¨å†™å…¥ä¸»å­˜å®Œæˆåï¼Œwrite buffer ä¸­çš„æ•°æ®å°± free æ‰äº†ã€‚

è¿™ç§æ–¹æ³•çš„ç¼ºç‚¹åœ¨äºï¼Œå¦‚æœè¿™ä¸ª write buffer å·²ç»æ»¡äº†ï¼Œé‚£ä¹ˆå¤„ç†å™¨æ¥å†™è¿™ä¸ªçš„æ—¶å€™å¿…é¡»åœæ­¢ï¼Œç­‰å¾… write buffer ä¸­å‡ºç°æ–°çš„ç©ºä½ã€‚

è¿™ä¸ªä¹‹ä¸­è¿˜æœ‰ä¸€ä¸ªçŸ›ç›¾åœ¨äºï¼Œå¦‚æœå¤„ç†å™¨ç”Ÿæˆå†™å…¥çš„é€Ÿç‡å¤§äºå†…å­˜å¯ä»¥å®Œæˆçš„å†™å…¥é€Ÿç‡ï¼Œé‚£ä¹ˆæ‹¿ä»€ä¹ˆ write buffer éƒ½ä¸ä¼šèµ·ä½œç”¨çš„ã€‚

### 8.3. Write back: dirty

æ ¸å¿ƒç­–ç•¥ï¼šCPU æˆ–è€…å†…æ ¸ä¿®æ”¹äº† cache ä¸­çš„å†…å®¹çš„æ—¶å€™ï¼Œcache ä¸ä¼šç«‹å³æ›´æ–°å†…å­˜å†…å®¹ï¼Œè€Œæ˜¯ç­‰åˆ°è¿™ä¸ª cache line å› ä¸ºæŸç§åŸå› éœ€è¦ä» cache ä¸­ç§»é™¤çš„æ—¶å€™ï¼Œcache æ‰å»æ›´æ–°å†…å­˜ä¸­çš„å†…å®¹ã€‚

cache ä¸ºäº†çŸ¥é“æŸä¸ª line çš„å†…å®¹æœ‰æ²¡æœ‰è¢«ä¿®æ”¹ï¼Œäºæ˜¯å¢åŠ äº†ä¸€ä¸ªæ–°çš„æ ‡å¿—ä½ï¼š**dirty**, å¢åŠ ä»¥åçš„ cache line ç»“æ„å¦‚ä¸‹æ‰€ç¤ºï¼š

| dirty | valid | tag | block |
| ----- | ----- | --- | ----- |

å…·ä½“çš„ dirty çš„ç”¨æ³•å¦‚ä¸‹ï¼š

- dirty ä½ä¸º 1, è¡¨ç¤ºè¿™ä¸ªæ•°æ®å·²ç»è¢«ä¿®æ”¹
- dirty ä½ä¸º 0, è¡¨ç¤ºè¿™ä¸ªæ•°æ®å’Œå†…å­˜ä¸­çš„æ•°æ®æ˜¯ä¸€è‡´çš„

ç¨‹åº cache ä¸éœ€è¦ dirty æ ‡å¿—ä½ï¼Œæ•°æ® cache éœ€è¦ dirty æ ‡å¿—ä½ã€‚

å‡ ä¸ªç‰¹ç‚¹ï¼š

> By comparison, in a write-through cache, writes can always be done in one cycle.

å¾ˆå¤š write back ç­–ç•¥è¿˜åŒ…æ‹¬ç€ write buffer ç”¨äºåœ¨ miss çš„æ—¶å€™å‡å°‘ miss æƒ©ç½šï¼Œæ˜¯è¿™ä¹ˆåšçš„ï¼šä¿®æ”¹åçš„å—è¢«ç§»åŠ¨åˆ° write buffer ä¸­ï¼ŒAssuming another miss does not occur immediately, this technique halves the miss penalty when a dirty block must be replaced.

### 8.4. Write miss

Write miss è¿™ä¸ªç¬¬ä¸€çœ¼çœ‹è¿‡å»ä¼¼ä¹æ˜¯æ¯”è¾ƒå¥‡ç‰¹çš„ï¼Œå†™ä¹Ÿä¼š Miss å—ï¼Ÿå½“ç„¶ä¼šäº†ï¼Œè¿™é‡Œçš„å†™ miss æŒ‡çš„æ˜¯æ²¡æœ‰å†™åœ¨ç¼“å­˜é‡Œé¢ã€‚

è€ƒè™‘ write through åœºæ™¯ä¸‹çš„ä¸€ä¸ª write miss, åœ¨ write through ä¸­ï¼Œæœ‰ä¸¤ç§ç­–ç•¥ï¼š

1. write allocate
   
   åœ¨ç¼“å­˜ä¸­åˆ†é…ä¸€ä¸ª block, ç„¶åç”¨å†…å­˜ä¸­çš„ block è¦†ç›–ä¹‹ã€‚

2. no write allocate
   
   æ›´æ–°å†…å­˜ä¸­çš„ block, ä½†æ˜¯ä¸æ”¾å…¥ cache ä¸­ã€‚è¿™ç§åœºæ™¯å¯èƒ½é€‚ç”¨äºè®¡ç®—æœºæ¸…é›¶æŸä¸€é¡µçš„å†…å®¹è¿™æ ·çš„æƒ…å†µï¼Œæœ‰äº›è®¡ç®—æœºæ˜¯å…è®¸æŒ‰é¡µæ›´æ”¹å†™å…¥åˆ†é…ç­–ç•¥çš„ã€‚

## 9. å¤šå¤„ç†å™¨ç¼“å­˜ä¸€è‡´æ€§

### 9.1. ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜

åœ¨å¤šæ ¸å¤„ç†å™¨ä¸­ï¼Œæ¯ä¸ªæ ¸å¿ƒéƒ½æœ‰ç‹¬ç«‹çš„ç¼“å­˜ï¼Œå¯èƒ½å¯¼è‡´æ•°æ®ä¸ä¸€è‡´ï¼š

    -----------------------------------------
    |       å¤šæ ¸å¤„ç†å™¨                       |
    | -----------------   ----------------  |
    | |     core 0     |  |     core 1    | |
    | |  cache 0(x = 3)|  | cache 1(x = 5)| |
    | ------------------  ----------------- |
    |-------------------------------------- |
    
        ------------------------------
        |     memory (x = 3)          |
        |                             |
        -------------------------------

core 0 å’Œ core 1 ä¸­çš„ x å®¹æ˜“å‡ºç°æ•°æ®ä¸ä¸€è‡´çš„æƒ…å†µï¼Œæ¯”å¦‚ core 0 å°† x è¿›è¡Œäº†ä¿®æ”¹ï¼Œä½†æ˜¯ core 1 ä¸çŸ¥é“ x å·²ç»è¢«ä¿®æ”¹äº†ï¼Œè¿˜åœ¨ä½¿ç”¨æ—§å€¼ï¼Œè¿™æ ·å°±ä¼šå¯¼è‡´æ•°æ®ä¸ä¸€è‡´çš„é—®é¢˜ã€‚

å¤„ç†å™¨æä¾›äº†ä¸¤ä¸ªæ“ä½œæ¥ä¿è¯ cache çš„ä¸€è‡´æ€§ï¼š

1. Wirte invalidate
2. Write update

### 9.2. Write invalidate

ç½®æ— æ•ˆï¼Œå…¶æ ¸å¿ƒæ€æƒ³ä¸ºï¼šå½“ä¸€ä¸ª core ä¿®æ”¹äº†ä¸€ä»½æ•°æ®ï¼Œå…¶ä»– core ä¸Šå¦‚æœæœ‰è¿™ä»½æ•°æ®çš„å¤åˆ¶ï¼Œå°±ç½®ä¸ºæ— æ•ˆã€‚

è¿™ç§æ–¹æ³•çš„ä¼˜ç‚¹åœ¨äºï¼Œæ¯”è¾ƒç®€å•ï¼Œè€Œä¸”æ— æ•ˆæ ‡å¿—ä½ valid åœ¨ cache line ä¸­æœ‰å¯¹åº”çš„å­—æ®µï¼Œè¿™æ„å‘³ç€ç½®æ— æ•ˆå°±æ˜¯æŠŠ cache çš„ä¸€ä¸ª line ç›´æ¥å†™ä¸ºæ— æ•ˆäº†ï¼Œè¿™ä¸ª cache line ä¸­å…¶ä»–æœ‰æ•ˆçš„æ•°æ®ä¹Ÿä¸èƒ½è¢«ä½¿ç”¨äº†ã€‚

å¤§éƒ¨åˆ†å¤„ç†å™¨éƒ½ä½¿ç”¨è¿™ä¸ªæ“ä½œã€‚

### 9.3. Write update

å†™æ›´æ–°ï¼šå½“ä¸€ä¸ªå†…æ ¸ä¿®æ”¹äº†ä¸€ä»½æ•°æ®ï¼Œå…¶ä»–çš„åœ°æ–¹å¦‚æœæœ‰è¿™ä»½æ•°æ®çš„èµ‹å€¼ï¼Œå°±æ›´æ–°åˆ°æœ€æ–°å€¼ã€‚

å…¶ç¼ºç‚¹æ˜¯ä¼šäº§ç”Ÿé¢‘ç¹çš„æ›´æ–°åŠ¨ä½œã€‚

## 10. cache ä¸€è‡´æ€§åè®®

### 10.1. MESI

ä¸»è¦ç ”ç©¶åŸºäº Write invalidate çš„ä¸€è‡´æ€§åè®®ã€‚æ¯”è¾ƒç»å…¸çš„åè®®å°±æ˜¯ MESI åè®®ã€‚

å¤ä¹ ä¸€ä¸‹ï¼šcache line ä¸­æœ‰ä¸¤ä¸ªå­—æ®µæ˜¯ dirty å’Œ valid, åˆ†åˆ«è¡¨ç¤ºæ•°æ®æ˜¯å¦è¢«ä¿®æ”¹å’Œæ•°æ®æ˜¯å¦æœ‰æ•ˆã€‚ä½†æ˜¯åœ¨å¤šæ ¸å¤„ç†å™¨ä¸­ï¼Œå¤šä¸ªæ ¸ä¼šå­˜åœ¨å…±äº«æ•°æ®çš„æƒ…å†µï¼ŒMESI åè®®å°±å¯ä»¥æè¿°è¿™ç§å…±äº«çŠ¶æ€ã€‚

MESI åè®®ä¸­æœ‰ 2 bit ç”¨äº cache line çš„çŠ¶æ€ä½ï¼Œå¦‚ä¸‹è¡¨ï¼š

| çŠ¶æ€  | å…¨ç¨‹        | æè¿°                                     |
| --- | --------- | -------------------------------------- |
| M   | Modified  | è¿™è¡Œæ•°æ®è¢«ä¿®æ”¹äº†ï¼Œå’Œå†…å­˜ä¸­çš„æ•°æ®ä¸ä¸€è‡´                    |
| E   | Exclusive | è¿™è¡Œæ•°æ®æœ‰æ•ˆï¼Œæ•°æ®å’Œå†…å­˜ä¸­ä¸€è‡´ï¼Œæ•°æ®åªå­˜åœ¨äºæœ¬ core çš„ cache ä¸­ |
| S   | Shared    | è¿™è¡Œæ•°æ®æœ‰æ•ˆï¼Œæ•°æ®å’Œå†…å­˜ä¸­ä¸€è‡´ï¼Œæ•°æ®å­˜åœ¨äºå¾ˆå¤š cache ä¸­        |
| I   | Invalid   | è¿™è¡Œæ•°æ®æ— æ•ˆ                                 |

M å’Œ E éœ€è¦é‡ç‚¹ç†è§£ä¸€ä¸‹ï¼Œå¾ˆæ˜æ˜¾è¿™å››ä¸ªçŠ¶æ€æ˜¯äº’æ–¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼š

- çŠ¶æ€ä¸º M çš„æ—¶å€™ï¼Œè¿™è¡Œæ•°æ®æ˜¯ dirty çš„ï¼Œä½†æ˜¯æ•°æ®æ˜¯è¿™ä¸ª cache ç‹¬æœ‰çš„ã€‚é™¤äº†è¿™ä¸ª M æ„å¤–ï¼Œå…¶ä»–çš„çŠ¶æ€ä¸‹æ•°æ®éƒ½æ˜¯ clean çš„ï¼ˆæ— æ•ˆçŠ¶æ€æ˜¯æ— æ•ˆçš„ï¼‰
- çŠ¶æ€ä½ E çš„æ—¶å€™ï¼Œè¿™è¡Œæ•°æ®æ˜¯ clean çš„ï¼Œå¹¶ä¸”æ•°æ®æ˜¯è¿™ä¸ª cache ç‹¬æœ‰çš„
- çŠ¶æ€ä½ S çš„æ—¶å€™ï¼Œè¿™è¡Œæ•°æ®æ˜¯ clean çš„ï¼Œcache å¯ä»¥ä»å…¶ä»– cache å¤„åŒæ­¥æ•°æ®ï¼Œä¹Ÿå¯ä»¥ä»å†…å­˜å¤„åŒæ­¥ï¼Œåè®®å¯¹æ­¤æ²¡æœ‰åšä»»ä½•è¦æ±‚ã€‚

åœ¨ MESI åè®®ä¸­ï¼Œ**cache æ§åˆ¶å™¨**æ˜¯å¯ä»¥ç›‘å¬ snoop å…¶ä»–çš„ cache çš„è¯»å†™æ“ä½œã€‚

### 10.2. Other MESI

AMD æ¼”åŒ–äº† MOESI åè®®ï¼Œå¤šäº†ä¸€ä¸ª O çŠ¶æ€ï¼Œè¿™ä¸ªçŠ¶æ€æ˜¯ S å’Œ M çŠ¶æ€çš„ä¸€ç§åˆä½“ï¼Œè¡¨ç¤ºæœ¬ cache line ä¸­çš„æ•°æ®å’Œå†…å­˜ä¸­çš„æ•°æ®ä¸ä¸€è‡´ï¼Œä¸è¿‡å…¶ä»–çš„æ ¸å¯ä»¥æœ‰è¿™ä»½æ•°æ®çš„å¤åˆ¶ï¼Œå¤åˆ¶äº†è¿™ä»½æ•°æ®çš„æ ¸çš„è¿™è¡Œ cache çš„çŠ¶æ€ä¸º S.

Intel I7 æ¼”åŒ–äº† MESIF åè®®ï¼Œå¤šçš„ F çŠ¶æ€è¡¨ç¤º Forward, å…¶å«ä¹‰æ˜¯å¯ä»¥æŠŠæ•°æ®ç›´æ¥ä¼ ç»™å…¶ä»–å†…æ ¸çš„ cache, è€Œ shared åˆ™ä¸èƒ½ã€‚

MESIX ç»Ÿä¸€éƒ½å¯ä»¥ç§°ä¸ºç›‘å¬åè®®(snoop)ï¼Œç›‘å¬åè®®çš„ç¼ºç‚¹åœ¨äºæ²Ÿé€šæˆæœ¬å¾ˆé«˜ï¼Œæ‰€ä»¥æœ‰ä¸€ç§é›†ä¸­ç®¡ç†çš„ç›®å½•åè®®ï¼Œå¯ä»¥åç»­ç ”ç©¶ã€‚

## 11. ç‰‡å†…å¯å¯»å€å­˜å‚¨å™¨

é€šå¸¸è€Œè¨€ï¼Œcache å¯¹ç”¨æˆ·ï¼ˆç¨‹åºå‘˜ï¼‰æ˜¯é€æ˜çš„ï¼Œä½†æ˜¯åœ¨ DSP ç­‰æ€§èƒ½è¦æ±‚å¾ˆé«˜çš„å¤„ç†å™¨ä¸­ï¼Œå¤„ç†å™¨å­˜å‚¨çš„ä¸€éƒ¨åˆ†ä½œä¸º cache, å¦ä¸€éƒ¨åˆ†ä½œä¸ºå¯å¯»å€å¯„å­˜å™¨ï¼Œç¨‹åºå‘˜å¯ä»¥ç›´æ¥è®¿é—®è¿™éƒ¨åˆ†ç©ºé—´ã€‚

è¿™ç§åœ¨åšæ³•å¯ä»¥æœ‰æ•ˆåœ°æ§åˆ¶ cache miss, æ‰€ä»¥æˆ‘ä»¬ä¹Ÿç§°ç‰‡å†…å¯å¯»å€å¯„å­˜å™¨ä¸ºï¼š**è½¯ä»¶ç®¡ç†çš„ cache**.

ç‰‡å†…å¯å¯»å€å¯„å­˜å™¨çš„åº”ç”¨ï¼šä¸€èˆ¬è€Œè¨€ï¼Œcache æ˜¯ç­‰åˆ° CPU è¦ä½¿ç”¨æ•°æ®çš„æ—¶å€™ï¼Œæ‰ä»å†…å­˜ä¸­å»æ‹¿æ•°æ®çš„ï¼Œç‰‡å†…å¯å¯»å€å¯„å­˜å™¨å¯ä»¥é€šè¿‡è½¯ä»¶æ§åˆ¶ DMAï¼Œå°†ä»¥åéœ€è¦çš„æ•°æ®æå‰æ¬åˆ°å¤„ç†å™¨å†…éƒ¨ï¼Œè¿™å°±èŠ‚çœäº†å¾ˆå¤š CPU çš„ç­‰å¾…æ—¶é—´ã€‚DMA æ˜¯ä¸“é—¨è´Ÿè´£æ•°æ®æ¬ç§»çš„æ¨¡å—ã€‚

ä¸ºä»€ä¹ˆä¼šæ˜¯è½¯ä»¶å»åšè¿™ä»¶äº‹å‘¢ï¼Ÿå› ä¸ºç¨‹åºæ˜¯å¯ä»¥çŸ¥é“ CPU ä»€ä¹ˆæ—¶å€™å°†è¦è®¿é—®æ•°æ®çš„ï¼Œè€Œ cache ä¸çŸ¥é“ã€‚ä½†æ˜¯è¿™ç§æ–¹æ³•å¯¹è½¯ä»¶çš„ç¼–å†™éš¾åº¦é€ æˆäº†å¾ˆå¤§çš„æŒ‘æˆ˜ã€‚

## 12. Bypass

> In addition, some CPU instructions may be explicitly **designed to bypass the cache**. For example, some architectures have special **instructions** that allow the CPU to read or write data directly to main memory **without going through the cache**. These instructions are typically used for low-level system operations that require direct access to the main memory or for performance-critical applications where caching may introduce additional latency or overhead.

åœ¨ ARM ä¸­ï¼Œæ— éœ€è®¿é—® cache ç›´æ¥è·å–æ•°æ®çš„æŒ‡ä»¤æœ‰ï¼š

> the ARM architecture has several special instructions that allow the CPU to bypass the cache and access data directly from the main memory or peripheral devices. Here are a few examples:
> 
> 1. LDM/STM instructions: The Load Multiple (LDM) and Store Multiple (STM) instructions allow the CPU to load or store multiple registers directly to or from the main memory without going through the cache. These instructions are commonly used for low-level system operations such as interrupt handling and context switching.
> 2. LDR/STR instructions with the "B" flag: The Load Register (LDR) and Store Register (STR) instructions have a "B" flag that allows the CPU to bypass the cache and access data directly from the main memory. This flag is typically used for performance-critical applications where caching may introduce additional latency or overhead.
> 3. DMA instructions: The Direct Memory Access (DMA) instructions allow the CPU to bypass the cache and transfer data directly between the main memory and peripheral devices. These instructions are commonly used for high-speed data transfer operations such as video and audio processing.
> 
> Overall, the ARM architecture provides several special instructions that allow the CPU to bypass the cache and access data directly from the main memory or peripheral devices, depending on the specific requirements of the application or system.

## 13. Others

### 13.1. å†…å­˜å¯¹é½

ä¸ºä»€ä¹ˆè¦å†…å­˜å¯¹é½(memory memory)[^1]ï¼š

1. å¹³å°åŸå› ï¼šä¸æ˜¯æ‰€æœ‰çš„ç¡¬ä»¶å¹³å°éƒ½å¯ä»¥è®¿é—®ä»»æ„åœ°å€ä¸Šçš„ä»»æ„æ•°æ®ï¼ŒæŸäº›å¹³å°åªèƒ½åœ¨ç‰¹å®šçš„åœ°å€å¤„å–æŸäº›ç‰¹å®šç±»å‹çš„æ•°æ®ï¼Œå¦åˆ™æŠ›å‡ºç¡¬ä»¶å¼‚å¸¸ã€‚
2. æ€§èƒ½åŸå› ï¼šå¦‚æœè®¿é—®æœªå¯¹é½çš„å†…å­˜ï¼Œå¤„ç†å™¨éœ€è¦ä¸¤æ¬¡è®¿å­˜æ“ä½œï¼›è€Œå¯¹é½çš„å†…å­˜åªéœ€è¦ä¸€æ¬¡è®¿å­˜æ“ä½œã€‚

## 14. Reference

[^1]: Computer Organization and Design_ The Hardware Software Interface_ ARM Edition
[ä¸€æ–‡è½»æ¾ç†è§£å†…å­˜å¯¹é½](https://cloud.tencent.com/developer/article/1727794)

[^2]: [Set associative caches](https://developer.arm.com/documentation/den0013/d/Caches/Cache-architecture/Set-associative-caches)

