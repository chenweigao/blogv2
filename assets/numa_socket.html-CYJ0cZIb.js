import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as a,a as o,b as e,e as r,w as s,r as c,o as l}from"./app-11Vuyqh7.js";const d={};function U(g,t){const n=c("font");return l(),i("div",null,[t[8]||(t[8]=a('<h2 id="_1-gpt" tabindex="-1"><a class="header-anchor" href="#_1-gpt"><span>1. GPT</span></a></h2><h3 id="_1-1-numa-socket" tabindex="-1"><a class="header-anchor" href="#_1-1-numa-socket"><span>1.1. NUMA &amp; Socket</span></a></h3><p>在服务器架构中，NUMA（Non-Uniform Memory Access）和 Socket（CPU 插槽）是紧密相关但又不同的概念：</p><p><strong>1. NUMA 体系结构</strong></p><p>NUMA 是一种内存访问架构，在多处理器系统中，每个 CPU 访问本地内存的速度比访问远程（其他 CPU 连接的）内存更快。NUMA 的关键点：</p><p>• 每个 NUMA 节点（Node）包含一个或多个 CPU 核心及其本地内存。</p><p>• 访问本地 NUMA 节点的内存（Local Memory）速度更快，而访问远程 NUMA 节点的内存（Remote Memory）则会有更高的延迟。</p><p><strong>2. Socket（CPU 插槽）</strong></p><p>Socket 是物理概念，表示主板上可以安装一个物理 CPU（或者多个 Die 组成的 CPU ）。现代服务器通常有多个 CPU Socket。</p><p><strong>3. NUMA 和 Socket 的关系</strong></p>',10)),o("p",null,[t[1]||(t[1]=e("• ")),r(n,{color:"#f79646"},{default:s(()=>t[0]||(t[0]=[e("单 Socket 服务器")])),_:1}),t[2]||(t[2]=e("：如果是单 CPU（单 Socket），那么所有的 CPU 核心共享相同的内存，没有 NUMA 架构，属于 ")),t[3]||(t[3]=o("strong",null,"UMA（Uniform Memory Access）",-1)),t[4]||(t[4]=e("。"))]),o("p",null,[t[6]||(t[6]=e("• ")),r(n,{color:"#f79646"},{default:s(()=>t[5]||(t[5]=[e("双 Socket 或多 Socket 服务器")])),_:1}),t[7]||(t[7]=e("：每个物理 CPU 插槽通常对应一个 NUMA 节点，每个 NUMA 节点有自己的本地 DRAM 控制器。"))]),t[9]||(t[9]=a('<p>• CPU 之间通过 <strong>Infinity Fabric（AMD）或 UPI（Intel）</strong> 互连，访问远程 NUMA 节点的内存。</p><p>例如，在 2 Socket 服务器中：</p><ul><li><p>Socket 0 -&gt; NUMA Node 0 -&gt; 本地 DRAM 0</p></li><li><p>Socket 1 -&gt; NUMA Node 1 -&gt; 本地 DRAM 1</p></li><li><p>Socket 0 访问 NUMA Node 1 的内存会有更高延迟。</p></li></ul><h3 id="_1-2-chiplet-设计下的-numa" tabindex="-1"><a class="header-anchor" href="#_1-2-chiplet-设计下的-numa"><span>1.2. Chiplet 设计下的 NUMA</span></a></h3><p>AMD EPYC 处理器采用 Chiplet（小芯片）架构，一个物理 CPU 内部可能包含多个 CCX（Core Complex） 或 CCD（Core Complex Die），每个 CCD 可能会形成一个 NUMA 节点。</p><p>例如：</p><ul><li><p>64 核 EPYC CPU 可能有 8 个 CCD，每个 CCD 可能是一个 NUMA 节点（NUMA per CCD）。</p></li><li><p>也可以通过 BIOS 配置，将多个 CCD 组合成较少的 NUMA 节点（NUMA per Socket）。</p></li></ul><h3 id="_1-3-总结" tabindex="-1"><a class="header-anchor" href="#_1-3-总结"><span>1.3. 总结</span></a></h3><table><thead><tr><th><strong>术语</strong></th><th><strong>概念</strong></th></tr></thead><tbody><tr><td>Socket</td><td>物理 CPU 插槽，安装一个 CPU</td></tr><tr><td>NUMA</td><td>内存访问架构，优化多 CPU 系统的内存访问</td></tr><tr><td>NUMA Node</td><td>由一个 CPU（或 Chiplet）及其本地内存组成的单元</td></tr><tr><td>多 Socket 服务器</td><td>每个 Socket 可能是一个 NUMA 节点</td></tr></tbody></table><p>不同架构下，NUMA 和 Socket 的映射关系可能有所不同，在优化软件性能时，需要考虑 NUMA 亲和性（NUMA Affinity），合理调度 CPU 线程和内存，以减少远程访问延迟。</p><h2 id="_2-gpt-一个比喻" tabindex="-1"><a class="header-anchor" href="#_2-gpt-一个比喻"><span>2. GPT - 一个比喻</span></a></h2><p>好的，我们用一个形象的比喻来解释 NUMA 和 Socket 的关系，把它想象成一个公司办公楼里的<strong>茶水间</strong>和<strong>员工办公室</strong>。</p><h3 id="_2-1-比喻-办公室-茶水间" tabindex="-1"><a class="header-anchor" href="#_2-1-比喻-办公室-茶水间"><span>2.1. 比喻 ：办公室 &amp; 茶水间</span></a></h3><p><strong>Socket（CPU 插槽）</strong> → <strong>办公楼</strong></p><p>• 服务器上的每个物理 CPU 就像是一座独立的办公楼（Socket）。</p><p>• 一台服务器可能有 1 座、2 座甚至 4 座办公楼（1P、2P 或 4P 服务器）。</p><p><strong>NUMA 节点</strong> → <strong>茶水间</strong></p><p>• 每栋办公楼内部可能有一个或多个茶水间（NUMA 节点），这些茶水间专门供附近的员工（CPU 核心）使用。</p><p>• 在 NUMA 架构下，每个办公楼（CPU Socket）通常有自己的茶水间（本地内存），供楼里的员工（CPU 核心）优先使用。</p><p><strong>本地访问 vs 远程访问</strong></p><p>• 员工（CPU 核心）取水时，最优选择是去<strong>自己楼里的茶水间</strong>（访问本地 NUMA 内存，低延迟）。</p><p>• 如果自己楼里的水不够用了（本地 NUMA 内存不够），只能去<strong>别的楼的茶水间</strong>（访问远程 NUMA 内存，延迟变高）。</p><h3 id="_2-2-单-socket-vs-多-socket" tabindex="-1"><a class="header-anchor" href="#_2-2-单-socket-vs-多-socket"><span>2.2. 单 Socket vs 多 Socket</span></a></h3><p><strong>单 Socket 服务器（UMA 架构）</strong></p><ul><li>只有 <strong>一栋办公楼</strong>，所有人共用一个茶水间。</li><li>访问内存（喝水）很均衡，没有远程访问的概念。</li></ul><p><strong>双 Socket 服务器（NUMA 架构）</strong></p><p>• 现在公司扩建，变成了 <strong>两栋办公楼</strong>，每栋楼有自己的茶水间（NUMA 节点）。</p><p>• 楼 A 里的员工优先用楼 A 的茶水间，楼 B 里的员工优先用楼 B 的茶水间。</p><p>• 但如果 A 楼的水不够了，A 楼的人可以去 B 楼取水（远程 NUMA 访问），但会更耗时。</p><p><strong>AMD EPYC 的 Chiplet 设计</strong></p><ul><li>传统 CPU 是一整块芯片，就像一座楼里有一个大茶水间。</li><li>AMD EPYC 采用 Chiplet 架构，相当于一座办公楼里有多个小茶水间（多个 CCD），不同 CCD 可能是不同的 NUMA 节点。</li><li>员工去最近的小茶水间取水最快，但如果去其他楼层的茶水间，还是会有些延迟。</li></ul><h3 id="_2-3-优化策略" tabindex="-1"><a class="header-anchor" href="#_2-3-优化策略"><span>2.3. 优化策略</span></a></h3><p><strong>合理安排员工（进程调度）</strong>：</p><ul><li>让 A 楼的员工尽量在 A 楼工作，B 楼的员工在 B 楼工作，避免频繁跨楼取水（减少远程 NUMA 访问）。</li><li>这类似于 NUMA 亲和性（NUMA Affinity），确保任务运行在对应 NUMA 节点的 CPU 上，并使用本地内存。</li></ul><p><strong>分配合适的茶水量（内存绑定）</strong>：</p><ul><li>如果知道 A 楼员工喝水需求大，就提前在 A 楼多准备点水（内存分配策略）。</li><li>这类似于 NUMA-aware 内存分配，确保进程分配的内存尽量在本地 NUMA 节点。</li></ul><p><strong>总结</strong></p><p>• Socket 就是物理 CPU，相当于一栋办公楼。</p><p>• NUMA 节点是 CPU 管辖的本地内存，相当于办公楼里的茶水间。</p><p>• CPU 访问本地内存（本楼茶水间）快，访问远程内存（别的楼的茶水间）慢。</p><p>• 优化 NUMA 亲和性，就像合理安排员工，让他们用最方便的茶水间，避免跑远路。</p><p>这样是不是更直观了？ 😃</p><h2 id="_3-deepseek-解答赏析" tabindex="-1"><a class="header-anchor" href="#_3-deepseek-解答赏析"><span>3. DeepSeek - 解答赏析</span></a></h2><p>NUMA（非一致内存访问）架构与 Socket（物理 CPU 插槽）的关系并非固定，而是取决于硬件设计。以下是两者的核心联系与区别：</p><p><strong>基本定义</strong></p><ul><li>Socket：<strong>物理概念</strong>，指主板上的 CPU 插槽，每个插槽可安装<strong>一个</strong>物理 CPU（如 Intel Xeon 或 AMD EPYC）。</li><li>NUMA Node：<strong>逻辑概念</strong>，用于管理 CPU 核心、缓存和本地内存，强调内存访问的非均匀性。每个 NUMA 节点通常包含一组 CPU 核心和直接连接的本地内存，访问本地内存的速度显著高于跨节点访问。</li></ul><p><strong>关系的多样性</strong></p><ul><li>一对一关系：在大多数单芯片设计中（如传统 Intel 至强处理器），一个 Socket 通常对应一个 NUMA 节点。例如，双插槽服务器中，每个 Socket 对应一个 NUMA 节点，本地内存直接连接到该 Socket 的 CPU。</li><li>一对多关系： 在多芯片封装（MCM）设计中（如 AMD EPYC 处理器），一个 Socket 可能包含多个独立芯片（如 4 个 Zeppelin 芯片），每个芯片对应一个 NUMA 节点。此时，单 Socket 可划分为多个 NUMA 节点，每个节点有自己的本地内存和 CPU 核心。</li><li>多对一关系： 某些特殊设计中，多个 Socket 可能共享一个 NUMA 节点（如通过高速互连总线整合内存控制器），但这种情况较少见。</li></ul><p><strong>性能影响</strong></p><ul><li><p>本地访问优势：NUMA 节点内的 CPU 访问本地内存延迟低、带宽高，而跨节点访问（如访问其他 Socket 的内存）延迟显著增加。例如，AMD EPYC 的芯片间通过 Infinity Fabric 互连，跨 NUMA 节点的延迟高于本地访问。</p></li><li><p>操作系统感知：Linux 通过 <code>numactl</code> 或 <code>lscpu</code> 可查看 NUMA 拓扑。例如，<code>numactl -H</code> 会显示节点间的距离矩阵（node distances），数值越大表示访问延迟越高。</p></li></ul><p><strong>命令工具：</strong></p><ul><li><code>lscpu</code>：显示 Socket、NUMA 节点、核心与线程的映射关系。</li><li><code>numactl --hardware</code>：列出 NUMA 节点的 CPU 和内存分配。</li><li><code>/sys/devices/system/node/</code>：查看节点与 CPU 的绑定关系。</li></ul><p>NUMA 与 Socket 的关系并非绝对，需结合具体硬件设计判断。理解两者的映射对优化多核应用性能至关重要，尤其是在虚拟化、高并发计算和网络处理场景中，需通过绑定策略减少跨节点访问开销。</p><h2 id="_4-架构图" tabindex="-1"><a class="header-anchor" href="#_4-架构图"><span>4. 架构图</span></a></h2><p>参考该文章<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>:</p><figure><img src="https://frankdenneman.nl/wp-content/uploads/2016/07/03-01-System_socket_die_core_HT.svg" alt="1" tabindex="0" loading="lazy"><figcaption>1</figcaption></figure><p>在上图中：</p><ol><li>The Intel 2630 v4 is based on the Broadwell microarchitecture and contains <strong>4 memory channels,</strong> with a maximum of 3 DIMMS per channel.</li><li>Each channel is filled with a single 16 GB DDR4 RAM DIMM. <strong>64 GB memory</strong> is available per CPU with a total of 128 GB in the system.</li></ol><figure><img src="https://frankdenneman.nl/wp-content/uploads/2016/07/03-02-NUMA_VM_local_acces_remote_access.svg" alt="2" tabindex="0" loading="lazy"><figcaption>2</figcaption></figure><figure><img src="https://frankdenneman.nl/wp-content/uploads/2016/07/03-05-Broadwell_HCC_Architecture.svg" alt="3" tabindex="0" loading="lazy"><figcaption>3</figcaption></figure><h2 id="_5-reference" tabindex="-1"><a class="header-anchor" href="#_5-reference"><span>5. Reference</span></a></h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p><a href="https://frankdenneman.nl/2016/07/08/numa-deep-dive-part-2-system-architecture/" target="_blank" rel="noopener noreferrer">https://frankdenneman.nl/2016/07/08/numa-deep-dive-part-2-system-architecture/</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li></ol></section>',63))])}const M=p(d,[["render",U]]),h=JSON.parse('{"path":"/architecture/numa_socket.html","title":"Numa and Socket","lang":"zh-CN","frontmatter":{"title":"Numa and Socket","date":"2022-08-25T00:00:00.000Z","category":["Arm","Computer Architecture"],"tags":["cpu"],"description":"1. GPT 1.1. NUMA & Socket 在服务器架构中，NUMA（Non-Uniform Memory Access）和 Socket（CPU 插槽）是紧密相关但又不同的概念： 1. NUMA 体系结构 NUMA 是一种内存访问架构，在多处理器系统中，每个 CPU 访问本地内存的速度比访问远程（其他 CPU 连接的）内存更快。NUMA 的关...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Numa and Socket\\",\\"image\\":[\\"https://frankdenneman.nl/wp-content/uploads/2016/07/03-01-System_socket_die_core_HT.svg\\",\\"https://frankdenneman.nl/wp-content/uploads/2016/07/03-02-NUMA_VM_local_acces_remote_access.svg\\",\\"https://frankdenneman.nl/wp-content/uploads/2016/07/03-05-Broadwell_HCC_Architecture.svg\\"],\\"datePublished\\":\\"2022-08-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-12T08:59:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Someone\\",\\"url\\":\\"https://www.weigao.cc\\"}]}"],["meta",{"property":"og:url","content":"https://vueblog.weigao.cc/architecture/numa_socket.html"}],["meta",{"property":"og:site_name","content":"weigao"}],["meta",{"property":"og:title","content":"Numa and Socket"}],["meta",{"property":"og:description","content":"1. GPT 1.1. NUMA & Socket 在服务器架构中，NUMA（Non-Uniform Memory Access）和 Socket（CPU 插槽）是紧密相关但又不同的概念： 1. NUMA 体系结构 NUMA 是一种内存访问架构，在多处理器系统中，每个 CPU 访问本地内存的速度比访问远程（其他 CPU 连接的）内存更快。NUMA 的关..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://frankdenneman.nl/wp-content/uploads/2016/07/03-01-System_socket_die_core_HT.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-12T08:59:22.000Z"}],["meta",{"property":"article:tag","content":"cpu"}],["meta",{"property":"article:published_time","content":"2022-08-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-12T08:59:22.000Z"}]]},"git":{"createdTime":1741587060000,"updatedTime":1747040362000,"contributors":[{"name":"weigao","username":"weigao","email":"weigao.cwg","commits":2,"url":"https://github.com/weigao"},{"name":"xiaocheng","username":"xiaocheng","email":"weigao.cwg","commits":1,"url":"https://github.com/xiaocheng"}]},"readingTime":{"minutes":7.03,"words":2108},"filePathRelative":"architecture/numa_socket.md","excerpt":"<h2>1. GPT</h2>\\n<h3>1.1. NUMA &amp; Socket</h3>\\n<p>在服务器架构中，NUMA（Non-Uniform Memory Access）和 Socket（CPU 插槽）是紧密相关但又不同的概念：</p>\\n<p><strong>1. NUMA 体系结构</strong></p>\\n<p>NUMA 是一种内存访问架构，在多处理器系统中，每个 CPU 访问本地内存的速度比访问远程（其他 CPU 连接的）内存更快。NUMA 的关键点：</p>\\n<p>• 每个 NUMA 节点（Node）包含一个或多个 CPU 核心及其本地内存。</p>\\n<p>• 访问本地 NUMA 节点的内存（Local Memory）速度更快，而访问远程 NUMA 节点的内存（Remote Memory）则会有更高的延迟。</p>","autoDesc":true}');export{M as comp,h as data};
