import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as a,o as i}from"./app-11Vuyqh7.js";const r="/assets/el-BewLX4iy.png",s={};function n(l,e){return i(),t("div",null,e[0]||(e[0]=[a('<h1 id="bl3-1" tabindex="-1"><a class="header-anchor" href="#bl3-1"><span>BL3-1</span></a></h1><blockquote><p>ARM Trusted Firmware Design <sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></p></blockquote><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><blockquote><p>The ARM Trusted Firmware implements a subset of the Trusted Board Boot Requirements (TBBR) Platform Design Document (PDD) for ARM reference platforms. The TBB sequence starts when the platform is powered on and runs up to the stage where it hands-off control to firmware running in the normal world in DRAM. This is the cold boot path.</p></blockquote><p>Trusted Board Boot(TBB) å¼€å§‹äºå¹³å°ä¸Šç”µçš„æ—¶å€™ï¼Œç›´åˆ°å›ºä»¶(firmware)åˆ°äº† norlmal world é˜¶æ®µï¼Œæ˜¯ä¸€ä¸ªå†·å¯åŠ¨çš„è·¯å¾„ã€‚</p><blockquote><p>The ARM Trusted Firmware also implements the Power State Coordination Interface (PSCI) PDD as a runtime service. PSCI is the interface from normal world software to firmware implementing power management use-cases (for example, secondary CPU boot, hotplug and idle). Normal world software can access ARM Trusted Firmware runtime services via the ARM SMC (Secure Monitor Call) instruction. The SMC instruction must be used as mandated by the SMC Calling Convention PDD.</p></blockquote><p>The ARM Trusted Firmware å®ç°äº† PSCI(Power State Coordination Interface) æ¥å£ä½œä¸ºè¿è¡Œæ—¶æœåŠ¡ã€‚</p><p>PSCI: ä¸€ä¸ªæ¥å£ï¼Œè¿™ä¸ªæ¥å£å®ç°äº†ç”µæºç®¡ç†ç”¨ä¾‹(power management use-cases)ï¼Œæ€ä¹ˆç†è§£è¿™ä¸ªç”µæºç®¡ç†ç”¨ä¾‹ï¼Ÿä¸¾ä¾‹æ¥è¯´å°±æ˜¯ secondary CPU çš„å¯åŠ¨ã€hotplug å’Œ idel ç­‰ï¼›æ³¨æ„åˆ°è¿™ä¸ªæ¥å£æ˜¯ä» normal world software åˆ° firmware(å…³äº firmware çš„ä»‹ç»å’Œç†è§£å¯ä»¥å‚è€ƒä¸‹æ–‡)ã€‚</p><p>Normal world software å¯ä»¥é€šè¿‡ ARM SMC(Secure Monitor Call) æŒ‡ä»¤æ¥è®¿é—® ARM Trusted Firmware æœåŠ¡ï¼ŒSMC åˆ¶å®šéµå¾ªç€ä¸€äº›çº¦å®šã€‚</p><h2 id="clod-boot" tabindex="-1"><a class="header-anchor" href="#clod-boot"><span>Clod Boot</span></a></h2><blockquote><p>The cold boot path starts when the platform is physically turned on.</p></blockquote><p>ä»‹ç»ä½•æ—¶å¯åŠ¨ã€‚</p><blockquote><p>One of the CPUs released from reset is chosen as the <strong>primary CPU</strong>, and the remaining CPUs are considered <strong>secondary CPUs</strong>. The primary CPU is chosen through platform-specific means.</p></blockquote><p>ä»‹ç»ä¸» CPU å’Œ secondray CPUs. ä¸€ä¸ª CPU è¢«é€‰ä¸ºä¸» CPU, å‰©ä¸‹çš„éƒ½æ˜¯ secondray. æ€ä¹ˆé€‰çš„ä¸» CPU å‘¢ï¼Ÿä¸»è¦æ˜¯çœ‹å¹³å°å®ç°ã€‚</p><blockquote><p>The cold boot path is mainly executed by the primary CPU, other than essential CPU initialization executed by all CPUs. The secondary CPUs are kept in a safe platform-specific state until the primary CPU has performed enough initialization to boot them.</p></blockquote><p>å†·å¯åŠ¨ä¸»è¦ç”±ä¸» CPU å®Œæˆï¼Œæ¬¡ CPU è¦ç­‰ä¸» CPU æ¥å¯åŠ¨ä»–ä»¬ã€‚</p><h3 id="cloud-boot-path" tabindex="-1"><a class="header-anchor" href="#cloud-boot-path"><span>Cloud Boot Path</span></a></h3><p>The cold boot path in this implementation of the ARM Trusted Firmware is divided into five steps (in order of execution):</p><ul><li>Boot Loader stage 1 (BL1) AP Trusted ROM</li><li>Boot Loader stage 2 (BL2) Trusted Boot Firmware</li><li>Boot Loader stage 3-1 (BL3-1) EL3 Runtime Firmware</li><li>Boot Loader stage 3-2 (BL3-2) Secure-EL1 Payload (optional)</li><li>Boot Loader stage 3-3 (BL3-3) Non-trusted Firmware</li></ul><p>å†·å¯åŠ¨çš„è·¯å¾„å¯ä»¥åˆ†ä¸ºä¸Šè¿°çš„æ­¥éª¤ï¼Œä¸‹æ–‡å°†å¯¹æ¯ä¸€ä¸ªéƒ½è¿›è¡Œåˆ†æã€‚</p><blockquote><p>The ARM Fixed Virtual Platforms (FVPs) provide trusted ROM, trusted SRAM and trusted DRAM regions. Each boot loader stage uses one or more of these memories for its code and data.</p></blockquote><p>æœ¯è¯­ï¼šFVPs æŒ‡çš„æ˜¯ ARM å›ºå®šè™šæ‹Ÿå¹³å°ã€‚</p><h3 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h3><p>clod boot å¯åŠ¨ç”±ç¡¬ä»¶å®Œæˆï¼Œåœ¨å¯åŠ¨çš„æ—¶å€™é€‰å®šä¸€ä¸ª CPU ä¸ºä¸» CPU, å‰©ä½™çš„ CPU ä¸ºä» CPU, å†·å¯åŠ¨ä¸»è¦ç”±ä¸» CPU å®Œæˆã€‚å…¶ä¸»è¦çš„æ­¥éª¤å¯ä»¥åˆ†ä¸º 5 æ­¥ï¼šBL1, BL2, BL31, BL32, BL33.</p><h2 id="bl1" tabindex="-1"><a class="header-anchor" href="#bl1"><span>BL1</span></a></h2><h3 id="el0-el3" tabindex="-1"><a class="header-anchor" href="#el0-el3"><span>EL0 - EL3</span></a></h3><blockquote><p>This stage begins execution from the platform&#39;s reset vector in trusted ROM at EL3. BL1 code starts at <code>0x00000000</code> (trusted ROM) in the FVP memory map. The BL1 data section is placed at the start of trusted SRAM, <code>0x04000000</code>.</p></blockquote><p>BL1 å¼€å§‹äº EL3, æˆ‘ä»¬è¦äº†è§£ EL3 æ˜¯ä»€ä¹ˆï¼Œç®€å•æ¥è¯´å°±æ˜¯å¯ä¿¡çš„çº§åˆ« EL0 ~ EL3, EL3 æ˜¯æœ€é«˜çš„<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>ã€‚</p><figure><img src="'+r+`" alt="el" tabindex="0" loading="lazy"><figcaption>el</figcaption></figure><p>å¯¹äºè¯¥å›¾çš„è§£é‡Šå¦‚ä¸‹ï¼š</p><ol><li>EL0ï¼šè¡¨ç¤ºç”¨æˆ·ç©ºé—´ï¼Œåœ¨ Norlmal World è¿è¡Œä¸­çš„åº”ç”¨ç¨‹åºï¼Œåœ¨ Secure World ä¸­å°±æ˜¯ Trust Application.</li><li>EL1: è¿è¡Œæ“ä½œç³»ç»Ÿã€‚NW ä¸­å¦‚ Linux, SW ä¸­å¦‚é«˜é€š QSEE.</li><li>EL2: ARM ä¸ºäº†æ”¯æŒè™šæ‹ŸåŒ–ï¼Œè®¾è®¡çš„è™šæ‹ŸåŒ–å±‚ï¼Œåªæœ‰åœ¨ NW ä¸­æœ‰</li><li>EL3: Secure Moniter ç”¨äº NW å’Œ SW çš„åˆ‡æ¢ï¼›åˆ‡æ¢çš„æ—¶å€™å‘é€ SMC æŒ‡å®šï¼Œè¿™ä¸ªåæ–‡ä¼šç ”ç©¶</li></ol><h3 id="bl1-å®ç°" tabindex="-1"><a class="header-anchor" href="#bl1-å®ç°"><span>BL1 å®ç°</span></a></h3><p>BL1 çš„å®ç°ä¸»è¦æ˜¯ä»¥ä¸‹æ­¥éª¤ï¼š</p><h3 id="determination-of-boot-path" tabindex="-1"><a class="header-anchor" href="#determination-of-boot-path"><span>Determination of boot path</span></a></h3><p>ç¡®å®šå¯åŠ¨è·¯å¾„ã€‚</p><blockquote><p>Whenever a CPU is released from reset, BL1 needs to distinguish between a warm boot and a cold boot. This is done using a platform-specific mechanism.</p></blockquote><p>CPU ä»å¤ä½ä¸­é‡Šæ”¾çš„æ—¶å€™ï¼ŒBL1 éœ€è¦åŒºåˆ†å†·å¯åŠ¨å’Œçƒ­å¯åŠ¨ã€‚è¿™ç§åŒºåˆ†ä¾èµ–äºç‰¹å®šçš„å¹³å°ã€‚</p><blockquote><p>The ARM FVPs implement a simple power controller at <code>0x1c100000</code>.</p></blockquote><p>å¾ˆå¥½ç†è§£ã€‚ARM çš„è™šæ‹ŸåŒ–å¹³å°å®ç°äº†ä¸€ä¸ªç”µæºæ§åˆ¶ï¼Œå…¶å¯åŠ¨çš„åœ°å€ä¸º <code>0x1c100000</code>.</p><blockquote><p>The <code>PSYS</code> register (0x10) is used to distinguish between a cold and warm boot. This information is contained in the PSYS.WK[25:24] field.</p></blockquote><p><code>PSYS</code> å¯„å­˜å™¨ç”¨äºåŒºåˆ†æ˜¯å†·å¯åŠ¨è¿˜æ˜¯çƒ­å¯åŠ¨ã€‚</p><blockquote><p>Additionally, a per-CPU mailbox is maintained in trusted DRAM (0x00600000), to which BL1 writes an entrypoint. Each CPU jumps to this entrypoint upon warm boot.</p></blockquote><p>é˜è¿°æœ‰ä¸€ä¸ªå…¥å£ç‚¹åœ¨ï¼Œç”¨äºçƒ­å¯åŠ¨ã€‚âŒğŸ“›âŒ æ¯”è¾ƒéš¾ç†è§£çš„æ˜¯ï¼Œper-CPU mailbox æ˜¯ä¸€ä¸ªä»€ä¹ˆï¼Ÿ</p><blockquote><p>During cold boot, BL1 places the secondary CPUs in a safe platform-specific state while the primary CPU executes the remaining cold boot path as described in the following sections.</p></blockquote><p>å†·å¯åŠ¨çš„æ—¶å€™æŠŠä¸» CPU å’Œä» CPUs æ”¾åœ¨ä»€ä¹ˆåœ°æ–¹æˆ–è€…çŠ¶æ€ã€‚</p><p>é€šè¿‡ä»¥ä¸Šæ–‡ç« ï¼Œå¯ä»¥åˆ†æåˆ°ï¼Œè¿™ä¸ªå¯åŠ¨è·¯å¾„æŒ‡çš„å°±æ˜¯åŒºåˆ†å†·çƒ­å¯åŠ¨ï¼Œå…¶ä¸­æ¶‰åŠåˆ°ä¸€äº›å¯„å­˜å™¨åœ°å€ï¼Œç„¶åå°±æ˜¯ä¸» CPU çš„ç›¸å…³å·¥ä½œã€‚</p><h3 id="architectural-initialization" tabindex="-1"><a class="header-anchor" href="#architectural-initialization"><span>Architectural initialization</span></a></h3><p>BL1 performs minimal architectural initialization as follows.</p><ol><li>Exception vectors</li><li>MMU setup</li><li>Control register setup</li></ol><p>ç»“æ„åˆå§‹åŒ–çš„æ­¥éª¤å¯ä»¥åˆ†ä¸ºä¸‰æ­¥ï¼šå¼‚å¸¸å‘é‡ã€MMU çš„é…ç½®ã€æ§åˆ¶å¯„å­˜å™¨çš„é…ç½®ï¼Œæ¥ä¸‹æ¥åˆ†åˆ«è¿›è¡Œé˜è¿°è¯´æ˜ã€‚</p><h4 id="exception-vectors" tabindex="-1"><a class="header-anchor" href="#exception-vectors"><span>Exception vectors</span></a></h4><blockquote><p>BL1 sets up simple exception vectors for both synchronous and asynchronous exceptions.</p></blockquote><p>BL1 è®¾ç½®äº†åŒæ­¥å’Œå¼‚æ­¥çš„å¼‚å¸¸å‘é‡ã€‚</p><blockquote><p>The default behavior upon receiving an exception is to set a status code.</p></blockquote><p>æ¥å—å¼‚å¸¸çš„æ—¶å€™ä¼šè®¾ç½®å¼‚å¸¸çŠ¶æ€ç ã€‚</p><blockquote><p>In the case of the FVP this code is written to the Versatile Express System LED register in the following format:</p></blockquote><p>å¼‚å¸¸ç ä¼šå†™å…¥ LED å¯„å­˜å™¨ï¼ˆâŒâŒâŒ LED å¯„å­˜å™¨æ˜¯ä»€ä¹ˆï¼Ÿï¼‰ï¼Œæ ¼å¼å¦‚ä¸‹æ‰€ç¤ºï¼š</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span>SYS_LED[0]   - Security state (Secure=0/Non-Secure=1)</span></span>
<span class="line"><span>SYS_LED[2:1] - Exception Level (EL3=0x3, EL2=0x2, EL1=0x1, EL0=0x0)</span></span>
<span class="line"><span>SYS_LED[7:3] - Exception Class (Sync/Async &amp; origin). The values for</span></span>
<span class="line"><span>               each exception class are:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    0x0 : Synchronous exception from Current EL with SP_EL0</span></span>
<span class="line"><span>    0x1 : IRQ exception from Current EL with SP_EL0</span></span>
<span class="line"><span>    0x2 : FIQ exception from Current EL with SP_EL0</span></span>
<span class="line"><span>    0x3 : System Error exception from Current EL with SP_EL0</span></span>
<span class="line"><span>    0x4 : Synchronous exception from Current EL with SP_ELx</span></span>
<span class="line"><span>    0x5 : IRQ exception from Current EL with SP_ELx</span></span>
<span class="line"><span>    0x6 : FIQ exception from Current EL with SP_ELx</span></span>
<span class="line"><span>    0x7 : System Error exception from Current EL with SP_ELx</span></span>
<span class="line"><span>    0x8 : Synchronous exception from Lower EL using aarch64</span></span>
<span class="line"><span>    0x9 : IRQ exception from Lower EL using aarch64</span></span>
<span class="line"><span>    0xa : FIQ exception from Lower EL using aarch64</span></span>
<span class="line"><span>    0xb : System Error exception from Lower EL using aarch64</span></span>
<span class="line"><span>    0xc : Synchronous exception from Lower EL using aarch32</span></span>
<span class="line"><span>    0xd : IRQ exception from Lower EL using aarch32</span></span>
<span class="line"><span>    0xe : FIQ exception from Lower EL using aarch32</span></span>
<span class="line"><span>    0xf : System Error exception from Lower EL using aarch32</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>LED å¯„å­˜å™¨é‡Œé¢æ¶‰åŠåˆ° 3 ä¸ªå–å€¼ï¼š</p><ul><li><code>SYS_LED[0]</code>: å®‰å…¨çŠ¶æ€</li><li><code>SYS_LED[2:1]</code>: EL, å¼‚å¸¸çº§åˆ«ï¼Œå–å€¼æœ‰ EL0 ~ EL3</li><li><code>SYS_LED[7:3]</code>: å¼‚å¸¸ç±»ï¼ŒåŒ…æ‹¬å¾ˆå¤šå–å€¼</li></ul><blockquote><p>A write to the LED register reflects in the System LEDs (S6LED0..7) in the CLCD window of the FVP.</p></blockquote><p>å¯¹ LED å¯„å­˜å™¨çš„å†™å…¥ä¼šåæ˜ åœ¨ FVP ä¸Šé¢ã€‚</p><blockquote><p>This behavior is because this boot loader stage does not expect to receive any exceptions other than the SMC exception.</p></blockquote><p>boot loader é˜¶æ®µé™¤äº† SMC å¼‚å¸¸å¤–ä¸æœŸæœ›æ¥æ”¶ä»»ä½•å¼‚å¸¸ã€‚</p><blockquote><p>For the latter, BL1 installs a simple stub. The stub expects to receive only a single type of SMC (determined by its function ID in the general purpose register X0).</p></blockquote><p>è¿™æ®µè¯è¯´æ˜äº† BL1 æœ‰ä¸€ä¸ª stub, è¯¥ stub ä»…ä»…åªæ¥æ”¶ç®€å•ç±»å‹çš„ SMC.</p><blockquote><p>This SMC is raised by BL2 to make BL1 pass control to BL3-1 (loaded by BL2) at EL3. Any other SMC leads to an assertion failure.</p></blockquote><p>ä¸Šè¿°ä¸­çš„ SMC æ˜¯ç”± BL2 æŠ›å‡ºï¼Œä½¿å¾— BL1 å°†æ§åˆ¶ä¼ é€’ç»™ BL3-1.</p><h4 id="mmu-setup" tabindex="-1"><a class="header-anchor" href="#mmu-setup"><span>MMU Setup</span></a></h4><p>MMU æ˜¯å†…å­˜ç®¡ç†å•å…ƒï¼Œæœ‰æ—¶ä¹Ÿç§°ä¸ºåˆ†é¡µå†…å­˜ç®¡ç†å•å…ƒï¼ˆpaged memory management unitï¼Œç¼©å†™ä¸º PMMUï¼‰ï¼ŒMMU æ¯”è¾ƒé‡è¦ï¼Œæˆ‘ä»¬åœ¨åæ–‡éœ€è¦è¿›è¡Œç ”ç©¶ã€‚@todo</p><blockquote><p>BL1 sets up EL3 memory translation by creating page tables to cover the first 4GB of physical address space. This covers all the memories and peripherals needed by BL1.</p></blockquote><p>BL1 ä¼šåˆ›å»ºä¸€ä¸ªé¡µè¡¨ï¼Œç”¨äºè®¾ç½® EL3 å†…å­˜è½¬æ¢ã€‚</p><h4 id="control-register-setup" tabindex="-1"><a class="header-anchor" href="#control-register-setup"><span>Control Register Setup</span></a></h4><blockquote><p>SCTLR_EL3. Instruction cache is enabled by setting the SCTLR_EL3.I bit. Alignment and stack alignment checking is enabled by setting the SCTLR_EL3.A and SCTLR_EL3.SA bits. Exception endianness is set to little-endian by clearing the SCTLR_EL3.EE bit.</p></blockquote><blockquote><p>CPUECTLR. When the FVP includes a model of a specific ARM processor implementation (for example A57 or A53), then intra-cluster coherency is enabled by setting the CPUECTLR.SMPEN bit. The AEMv8 Base FVP is inherently coherent so does not implement CPUECTLR.</p></blockquote><blockquote><p>SCR. Use of the HVC instruction from EL1 is enabled by setting the SCR.HCE bit. FIQ exceptions are configured to be taken in EL3 by setting the SCR.FIQ bit. The register width of the next lower exception level is set to AArch64 by setting the SCR.RW bit. External Aborts and SError Interrupts are configured to be taken in EL3 by setting the SCR.EA bit.</p></blockquote><blockquote><p>CPTR_EL3. Accesses to the CPACR_EL1 register from EL1 or EL2, or the CPTR_EL2 register from EL2 are configured to not trap to EL3 by clearing the CPTR_EL3.TCPAC bit. Access to the trace functionality is configured not to trap to EL3 by clearing the CPTR_EL3.TTA bit. Instructions that access the registers associated with Floating Point and Advanced SIMD execution are configured to not trap to EL3 by clearing the CPTR_EL3.TFP bit.</p></blockquote><p>å¯„å­˜å™¨çš„ç»†èŠ‚æš‚ä¸å…³æ³¨ã€‚</p><h3 id="platform-initialization" tabindex="-1"><a class="header-anchor" href="#platform-initialization"><span>Platform Initialization</span></a></h3><blockquote><p>BL1 enables issuing of snoop and DVM (Distributed Virtual Memory) requests from the CCI-400 slave interface corresponding to the cluster that includes the primary CPU.</p></blockquote><p>CCU-400<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup> å‚è€ƒ CoreLink CCI-400 æ–‡æ¡£è¿›è¡Œç†è§£ã€‚</p><blockquote><p>BL1 also initializes UART0 (PL011 console), which enables access to the printf family of functions in BL1.</p></blockquote><h3 id="bl2-image-load-and-execution" tabindex="-1"><a class="header-anchor" href="#bl2-image-load-and-execution"><span>BL2 image load and execution</span></a></h3><p>BL1 execution continues as follows:</p><blockquote><p>BL1 determines the amount of free trusted SRAM memory available by calculating the extent of its own data section, which also resides in trusted SRAM. BL1 loads a BL2 raw binary image from platform storage, at a platform-specific base address. If the BL2 image file is not present or if there is not enough free trusted SRAM the following error message is printed: âŒâŒâŒ &quot;Failed to load boot loader stage 2 (BL2) firmware.&quot; If the load is successful, BL1 updates the limits of the remaining free trusted SRAM. It also populates information about the amount of trusted SRAM used by the BL2 image. The exact load location of the image is provided as a base address in the platform header. Further description of the memory layout can be found later in this document.</p></blockquote><p>BL1 é¦–å…ˆè®¡ç®—å¯ç”¨çš„ SRAM ç©ºé—´ç”¨äºåŠ è½½ BL2 çš„äºŒè¿›åˆ¶é•œåƒï¼Œå¦‚æœé•œåƒåŠ è½½æˆåŠŸï¼ŒBL1 æ›´æ–°å‰©ä½™çš„ SRAM ç©ºé—´ï¼Œé•œåƒå…·ä½“çš„åŠ è½½åœ°å€ä¼šä½œä¸ºä¸€ä¸ª base address æä¾›ã€‚</p><p>éœ€è¦æ³¨æ„åˆ°ï¼Œå¦‚æœ BL1 åœ¨åŠ è½½ BL2 é•œåƒçš„æ—¶å€™ï¼Œå¦‚æœ BL2 é•œåƒæ–‡ä»¶ä¸å­˜åœ¨ï¼Œæˆ–è€… SRAM ç©ºé—´ä¸è¶³ï¼Œæ­¤æ—¶å°±ä¼šæŠ¥é”™ã€‚</p><blockquote><p>BL1 prints the following string from the primary CPU to indicate successful execution of the BL1 stage: &quot;Booting trusted firmware boot loader stage 1&quot;</p></blockquote><p>æ‰“å°å‡ºæ¥ <em>&quot;Booting trusted firmware boot loader stage 1&quot;</em> å°±è¯´æ˜ BL1 é˜¶æ®µæˆåŠŸã€‚</p><blockquote><p>BL1 passes control to the BL2 image at Secure EL1, starting from its load address.</p></blockquote><p>BL1 å°†æ§åˆ¶æƒè½¬äº¤ç»™ BL2, å…¶èµ·å§‹åœ°å€å°±æ˜¯ load address.</p><blockquote><p>BL1 also passes information about the amount of trusted SRAM used and available for use. This information is populated at a platform-specific memory address.</p></blockquote><p>å†ä¼ é€’ä¸€ä¸‹å¯ä¿¡ SRAM ç›¸å…³çš„ä¿¡æ¯ã€‚</p><h3 id="summary-1" tabindex="-1"><a class="header-anchor" href="#summary-1"><span>Summary</span></a></h3><p>æ€»ç»“ä¸€ä¸‹ BL1 çš„åŠ è½½è¿‡ç¨‹ï¼ŒæŠ›å¼€å¼‚å¸¸å¤„ç†çš„è¿‡ç¨‹ä¸è°ˆï¼ŒBL1 é¦–å…ˆåˆå§‹åŒ– MMU å’Œç›¸å…³çš„å¯„å­˜å™¨ï¼Œè€Œåå¯¹å¹³å°è¿›è¡Œåˆå§‹åŒ–ï¼Œæœ€åå†åŠ è½½ BL2 çš„é•œåƒå¹¶è½¬æ¥æ§åˆ¶æƒã€‚</p><h2 id="bl2" tabindex="-1"><a class="header-anchor" href="#bl2"><span>BL2</span></a></h2><h3 id="abstract" tabindex="-1"><a class="header-anchor" href="#abstract"><span>Abstract</span></a></h3><blockquote><p>BL1 loads and passes control to BL2 at Secure-EL1.</p></blockquote><p>è¿™å¥è¯è¯´çš„æ˜¯ï¼šåœ¨ Secure-EL1 é˜¶æ®µï¼ŒBL1 åŠ è½½å¹¶ä¸”æŠŠæ§åˆ¶æƒäº¤ç»™äº† BL2!</p><p>ğŸš«ğŸš«ğŸš« æœ‰ä¸€ä¸ªç–‘æƒ‘æˆ–è€…ç†è§£é”™è¯¯ï¼ŒBL1-BL33 ä¸éƒ½æ˜¯ EL3 é˜¶æ®µçš„äº‹æƒ…ä¹ˆï¼Ÿ</p><blockquote><p>BL2 is linked against and loaded at a platform-specific base address (more information can be found later in this document).</p></blockquote><p>BL2 é“¾æ¥äºç‰¹å®šçš„å¹³å° base address ä¸Šï¼Œåæ–‡è¿˜è¦ç»§ç»­é˜è¿°ã€‚</p><p>BL2 å®ç°çš„åŠŸèƒ½å¦‚ä¸‹æ–‡é˜è¿°ã€‚</p><h3 id="architectural-initialization-1" tabindex="-1"><a class="header-anchor" href="#architectural-initialization-1"><span>Architectural initialization</span></a></h3><blockquote><p>BL2 performs minimal architectural initialization required for subsequent stages of the ARM Trusted Firmware and normal world software.</p></blockquote><p>ä½“ç³»ç»“æ„åˆå§‹åŒ–æœ€å°åŒ–ã€‚</p><blockquote><p>It sets up Secure EL1 memory translation by creating page tables to address the first 4GB of the physical address space in a similar way to BL1.</p></blockquote><p>å’Œ BL1 ç›¸ä¼¼çš„æ–¹å¼åˆ›å»ºé¡µè¡¨ã€‚</p><blockquote><p>EL1 and EL0 are given access to Floating Point &amp; Advanced SIMD registers by clearing the CPACR.FPEN bits.</p></blockquote><p>å¯„å­˜å™¨ç›¸å…³çš„ï¼Œç°åœ¨å¯èƒ½å·²ç»æœ‰æ›´æ–°ï¼Œæš‚æ—¶ä¸ç ”ç©¶ã€‚</p><h3 id="platform-initialization-1" tabindex="-1"><a class="header-anchor" href="#platform-initialization-1"><span>Platform initialization</span></a></h3><blockquote><p>BL2 copies the information regarding the trusted SRAM populated by BL1 using a platform-specific mechanism.</p></blockquote><p>BL2 å¤åˆ¶ BL1 å¯ä¿¡ SRAM çš„ä¿¡æ¯ã€‚</p><blockquote><p>It calculates the limits of DRAM (main memory) to determine whether there is enough space to load the BL3-3 image.</p></blockquote><p>è¿˜æ˜¯è®¡ç®—ä¸€ä¸‹èƒ½ä¸èƒ½è¶³å¤ŸåŠ è½½ BL3-3 é•œåƒã€‚</p><blockquote><p>A platform defined base address is used to specify the load address for the BL3-1 image.</p></blockquote><p>BL3-1 é•œåƒåŠ è½½çš„åœ°å€ã€‚</p><blockquote><p>It also defines the extents of memory available for use by the BL3-2 image.</p></blockquote><p>å®šä¹‰äº† BL3-2 é•œåƒå¯ç”¨çš„å†…å­˜èŒƒå›´ã€‚</p><blockquote><p>BL2 also initializes UART0 (PL011 console), which enables access to the printf family of functions in BL2. Platform security is initialized to allow access to access controlled components.</p></blockquote><blockquote><p>On the Base FVP a TrustZone controller (TZC-400) is configured to give full access to the platform DRAM. The storage abstraction layer is initialized which is used to load further bootloader images.</p></blockquote><h3 id="bl3-0-system-control-processor-firmware-image-load" tabindex="-1"><a class="header-anchor" href="#bl3-0-system-control-processor-firmware-image-load"><span>BL3-0 (System Control Processor Firmware) image load</span></a></h3><blockquote><p>Some systems have a separate System Control Processor (SCP) for power, clock, reset and system control.</p></blockquote><p>SCP ç”¨äºå•ç‹¬æ§åˆ¶ç”µæºã€æ—¶é’Ÿç­‰ã€‚</p><blockquote><p>BL2 loads the optional BL3-0 image from platform storage into a platform-specific region of secure memory.</p></blockquote><p>BL2 åŠ è½½å¯é€‰çš„ BL3-0 é•œåƒåˆ°å®‰å…¨å†…å­˜ä¸­ã€‚</p><blockquote><p>The subsequent handling of BL3-0 is platform specific.</p></blockquote><p>BL3-0 çš„åç»­å¤„ç†ä¸å¹³å°æœ‰å…³ã€‚</p><blockquote><p>Typically the image is transferred into SCP memory using a platform-specific protocol. The SCP executes BL3-0 and signals to the Application Processor (AP) for BL2 execution to continue.</p></blockquote><p>é•œåƒä¼ è¾“åˆ° SCP å­˜å‚¨ä¸­ã€‚</p><h3 id="bl3-1-el3-runtime-firmware-image-load" tabindex="-1"><a class="header-anchor" href="#bl3-1-el3-runtime-firmware-image-load"><span>BL3-1 (EL3 Runtime Firmware) image load</span></a></h3><blockquote><p>BL2 loads the BL3-1 image from platform storage into a platform-specific address in trusted SRAM. If there is not enough memory to load the image or image is missing it leads to an assertion failure. If the BL3-1 image loads successfully, <strong>BL2 updates the amount of trusted SRAM used and available for use by BL3-1.</strong> This information is populated at a platform-specific memory address.</p></blockquote><p>è¿™ä¸ªä»‹ç»æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯ EL2 åŠ è½½ BL3-1, æˆåŠŸåæ›´æ–° SRAM çš„æ•°é‡ã€‚</p><h3 id="bl3-2-secure-el1-payload-image-load" tabindex="-1"><a class="header-anchor" href="#bl3-2-secure-el1-payload-image-load"><span>BL3-2 (Secure-EL1 Payload) image load</span></a></h3><blockquote><p>BL2 loads the optional BL3-2 image from platform storage into a platform- specific region of secure memory. The image executes in the secure world. BL2 relies on BL3-1 to pass control to the BL3-2 image, if present. Hence, BL2 populates a platform-specific area of memory with the entrypoint/load-address of the BL3-2 image. The value of the Saved Processor Status Register (SPSR) for entry into BL3-2 is not determined by BL2, it is initialized by the Secure-EL1 Payload Dispatcher (see later) within BL3-1, which is responsible for managing interaction with BL3-2. This information is passed to BL3-1.</p></blockquote><p>æš‚æ—¶ä¸ç ”ç©¶ã€‚</p><h3 id="bl3-3-non-trusted-firmware-image-load" tabindex="-1"><a class="header-anchor" href="#bl3-3-non-trusted-firmware-image-load"><span>BL3-3 (Non-trusted Firmware) image load</span></a></h3><blockquote><p>BL2 loads the BL3-3 image (e.g. UEFI or other test or boot software) from platform storage into non-secure memory as defined by the platform (0x88000000 for FVPs).</p></blockquote><blockquote><p>BL2 relies on BL3-1 to pass control to BL3-3 once secure state initialization is complete. Hence, BL2 populates a platform-specific area of memory with the entrypoint and Saved Program Status Register (SPSR) of the normal world software image. The entrypoint is the load address of the BL3-3 image. The SPSR is determined as specified in Section 5.13 of the [PSCI PDD] PSCI. This information is passed to BL3-1.</p></blockquote><p>å’Œé¢˜ç›®æ ‡é¢˜ä¸€æ ·ï¼Œéå®‰å…¨çš„é•œåƒåŠ è½½ã€‚</p><h2 id="bl3-1-1" tabindex="-1"><a class="header-anchor" href="#bl3-1-1"><span>BL3-1</span></a></h2><p>è¿™ä¸ªç« èŠ‚ç ”ç©¶ BL3-1 é˜¶æ®µæ‰€åšçš„äº‹æƒ…ã€‚</p><blockquote><p>The image for this stage is loaded by BL2 and BL1 passes control to BL3-1 at EL3.</p></blockquote><p>image æ¥æºæ˜¯ BL2, æ§åˆ¶æƒæ¥æºäº BL1.</p><blockquote><p>BL3-1 executes solely in trusted SRAM.</p></blockquote><p>BL3-1 åªåœ¨å—ä¿¡ä»»çš„ SRAM ä¸­æ‰§è¡Œã€‚</p><blockquote><p>BL3-1 is linked against and loaded at a platform-specific base address (more information can be found later in this document).</p></blockquote><p>è¿™å¥è¯è¿˜æ˜¯åœ¨è¯´ base address.</p><h3 id="architectural-initialization-2" tabindex="-1"><a class="header-anchor" href="#architectural-initialization-2"><span>Architectural initialization</span></a></h3><blockquote><p>Currently, BL3-1 performs a similar architectural initialization to BL1 as far as system register settings are concerned.</p></blockquote><p>ç³»ç»Ÿå¯„å­˜å™¨çš„åˆå§‹åŒ–å’Œ BL1 çš„ä½“ç³»ç»“æ„ç±»ä¼¼ã€‚</p><blockquote><p>Since BL1 code resides in ROM, architectural initialization in BL3-1 allows override of any previous initialization done by BL1.</p></blockquote><p>BL1 åœ¨ ROM ä¸­ï¼ŒBL1 åšçš„åˆå§‹åŒ–æ“ä½œéƒ½å¯ä»¥è¢« BL3-1 è¦†ç›–æ‰ã€‚</p><blockquote><p>BL3-1 creates page tables to address the first 4GB of physical address space and initializes the MMU accordingly.</p></blockquote><p>åˆ›å»ºé¡µè¡¨ï¼Œå¹¶åˆå§‹åŒ– MMU.</p><blockquote><p>It replaces the exception vectors populated by BL1 with its own.</p></blockquote><p>BL3-1 ç”¨è‡ªå·±çš„å¼‚å¸¸å‘é‡æ›¿æ¢ BL1 å¡«å……çš„å¼‚å¸¸å‘é‡ã€‚</p><blockquote><p>BL3-1 exception vectors signal error conditions in the same way as BL1 does if an unexpected exception is raised.</p></blockquote><p>Exception Vectors æ˜¯ä¸ BL1 çš„å®ç°ä¸€æ ·çš„ã€‚</p><blockquote><p>They implement more elaborate support for handling SMCs since this is the only mechanism to access the runtime services implemented by BL3-1 (PSCI for example).</p></blockquote><p>They è¿˜æŒ‡çš„æ˜¯ Exception Vectors, elaborate çš„æ„æ€æ˜¯å¤æ‚çš„ã€è¯¦ç»†çš„ï¼›</p><p>å‰åŠå¥è¯è¯´çš„è¯ï¼Œå¼‚å¸¸å‘é‡å®ç°äº†æ›´åŠ è¯¦ç»†çš„ SMCs å¤„ç†(ARM SMC, Secure Monitor Call)ï¼Œå› ä¸º SMC æ˜¯è®¿é—® BL3-1 å®ç°çš„ç³»ç»ŸæœåŠ¡çš„å”¯ä¸€æœºåˆ¶ã€‚</p><p>è¿™ä¸ªç³»ç»ŸæœåŠ¡ä¸¾ä¾‹å°±æ˜¯ PSCI ç”µæºç®¡ç†æ¥å£ã€‚</p><p>ä»è¿™å¥è¯ä¸­æˆ‘ä»¬å¯ä»¥æ¨ç†å‡ºä¸€äº›å…³ç³»ï¼Œ â“â“ ï¼ˆæ€€ç–‘æ˜¯ Exception Vectorsï¼‰å¢å¼ºäº†å¤„ç† SMC çš„æ”¯æŒï¼ŒSMC ç”¨äºè®¿é—® BL3-1 å®ç°çš„è¿è¡Œæ—¶æœåŠ¡ï¼Œæ¯”å¦‚è¯´ PSCI.</p><blockquote><p>BL3-1 checks each SMC for validity as specified by the <strong>SMC calling convention PDD</strong><sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup> before passing control to the required SMC handler routine.</p></blockquote><blockquote><p>BL3-1 programs the CNTFRQ_EL0 register with the clock frequency of the system counter, which is provided by the platform.</p></blockquote><p>æ¯”è¾ƒä¸å¥½ç†è§£ï¼Œéœ€è¦ç»“åˆå‚è€ƒæ–‡çŒ®è¿›è¡Œè§£è¯»ã€‚</p><h3 id="platform-initialization-2" tabindex="-1"><a class="header-anchor" href="#platform-initialization-2"><span>Platform initialization</span></a></h3><blockquote><p>BL3-1 performs detailed platform initialization, which enables normal world software to <strong>function</strong> correctly.</p></blockquote><p>â“â“â“ normal world softwar --&gt; function: è¿™ä¸ª function å¦‚ä½•ç†è§£ï¼Ÿ</p><blockquote><p>It also retrieves entrypoint information for the BL3-3 image loaded by BL2 from the platform defined memory address populated by BL2.</p></blockquote><p>æ£€ç´¢ entrypoint.</p><blockquote><p>BL3-1 also initializes UART0 (PL011 console), which enables access to the printf family of functions in BL3-1.</p></blockquote><p>è¿˜åˆå§‹åŒ–äº† UART0(ç›®å‰æš‚æ— æ¥è§¦)</p><blockquote><p>It enables the system level implementation of the generic timer through the memory mapped interface.</p></blockquote><p>ä½¿ç”¨å†…å­˜æ˜ å°„å®ç°äº†ç³»ç»Ÿçº§åˆ«çš„é€šç”¨è®¡æ•°å™¨ã€‚</p><ul><li>GICv2 initializationï¼š <ul><li>Enable group0 interrupts in the GIC CPU interface.</li><li>Configure group0 interrupts to be asserted as FIQs.</li><li>Disable the legacy interrupt bypass mechanism.</li><li>Configure the priority mask register to allow interrupts of all priorities to be signaled to the CPU interface.</li><li>Mark SGIs 8-15, the secure physical timer interrupt (#29) and the trusted watchdog interrupt (#56) as group0 (secure).</li><li>Target the trusted watchdog interrupt to CPU0.</li><li>Enable these group0 interrupts in the GIC distributor.</li><li>Configure all other interrupts as group1 (non-secure).</li><li>Enable signaling of group0 interrupts in the GIC distributor.</li></ul></li></ul><p>GIC: Generic Interrupt Controller ARM ä¸­æ–­æ§åˆ¶å™¨ã€‚</p><h2 id="about" tabindex="-1"><a class="header-anchor" href="#about"><span>About</span></a></h2><h3 id="firmware" tabindex="-1"><a class="header-anchor" href="#firmware"><span>Firmware</span></a></h3><p>â“â“â“ ä»€ä¹ˆæ˜¯ firmware?</p><blockquote><p>In computing, firmware is a specific class of computer software that provides the low-level control for a device&#39;s specific hardware<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup>.</p></blockquote><ul><li>computer software, æœ¬è´¨æ˜¯è½¯ä»¶ï¼›å±äºè®¡ç®—æœºè½¯ä»¶ä¸­ç‰¹æ®Šçš„ä¸€ç±»</li><li>low-level control ä½œç”¨äºç‰¹å®šçš„ç¡¬ä»¶</li></ul><blockquote><p>Ascher Opler coined the term firmware in a 1967 Datamation article, as an intermediary term between &quot;hardware&quot; and &quot;software&quot;. In this article, Opler was referring to a new kind of computer program that had a different practical and psychological purpose from traditional programs from the user&#39;s perspective.</p><p>As computers began to increase in complexity, it became clear that various programs needed to first be initiated and run to provide a consistent environment necessary for running more complex programs at the user&#39;s discretion. This required programming the computer to run those programs automatically.</p></blockquote><p>ä»‹ç»äº† firmware çš„å†å²ï¼Œå›ºä»¶çš„ä½œç”¨å°±æ˜¯å¯ä»¥è‡ªåŠ¨è¿è¡Œçš„ã€ç”¨æˆ·ä¸æ„ŸçŸ¥çš„ä¸€ä¸ªç¨‹åºã€‚</p><blockquote><p>Firmware, such as the BIOS of a personal computer, may contain basic functions of a device, and may provide hardware abstraction services to higher-level software such as operating systems.</p></blockquote><p>è¿™å¥è¯ä¸¾ä¾‹è¯´æ˜äº† BIOS æ˜¯ firmware çš„ä¸€ç§ã€‚</p><blockquote><p>For less complex devices, firmware may act as the device&#39;s complete operating system, performing all control, monitoring and data manipulation functions.</p></blockquote><p>å¯¹äºä¸å¤ªå¤æ‚çš„ç³»ç»Ÿè€Œè¨€ï¼Œå›ºä»¶å¯ä»¥å……å½“æ“ä½œç³»ç»Ÿçš„è§’è‰²ã€‚</p><p>â“â“â“ firmware å’ŒåµŒå…¥å¼è½¯ä»¶çš„å…³ç³»æ˜¯ä»€ä¹ˆï¼Ÿ</p><blockquote><p>Typical examples of devices containing firmware are embedded systems (running embedded software), home and personal-use appliances, computers, and computer peripherals<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup>.</p></blockquote><p>åŸæ–‡<sup class="footnote-ref"><a href="#footnote5">[5:1]</a><a class="footnote-anchor" id="footnote-ref5:1"></a></sup>åœ¨ä¸¾ä¾‹ firmware çš„æ—¶å€™æåˆ°äº†åµŒå…¥å¼ç³»ç»Ÿ(embedded systems), ä»ä¸­æˆ‘ä»¬ä¸éš¾åˆ¤æ–­ï¼ŒåµŒå…¥å¼ç³»ç»Ÿä¹Ÿå±äºå›ºä»¶çš„ä¸€ç§ã€‚</p><blockquote><p>Firmware is held in non-volatile memory devices such as ROM, EPROM, EEPROM, and Flash memory.</p></blockquote><p>å›ºä»¶ä¿å­˜åœ¨éæ˜“å¤±æ€§å­˜å‚¨å™¨(non-volatile memory)ä¸­ã€‚</p><blockquote><p>Updating firmware requires ROM integrated circuits to be physically replaced, or EPROM or flash memory to be reprogrammed through a special procedure.</p></blockquote><p>ä¸Šæ®µæ–‡å­—æåˆ°äº†å›ºä»¶çš„æ›´æ–°å¯ä»¥é€šè¿‡ï¼š</p><ol><li>æŠŠç„Šä¸Šå»çš„ ROM é›†æˆç”µè·¯æ‹†äº†å†ç„Šæ–°çš„ä¸Šå»ï¼ŒROM ä¸€æ—¦ç¡®å®šå°±æ— æ³•æ›´æ”¹ã€‚</li><li>EPROMï¼šé€šè¿‡å¯æ“¦é™¤çš„ ROM æ¥æ›´æ–°ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒEPROM çš„æ“¦é™¤æ˜¯é€šè¿‡ç´«å¤–çº¿çš„æ–¹å¼ï¼Œå…¶å¯æ“¦é™¤çš„æ¬¡æ•°ä¸€èˆ¬åœ¨ 1000 æ¬¡å·¦å³ã€‚</li></ol><div class="hint-container tip"><p class="hint-container-title">ROM</p><p>ROM: Read-only memory<sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup>, å±äºéæ˜“å¤±æ€§å­˜å‚¨å™¨ï¼Œå¸¸ç”¨äºå›ºä»¶ã€‚</p><p>æˆ‘ä»¬ç°åœ¨SOCä¸Šç”¨çš„æ˜¯ä¸å¯æ“¦é™¤çš„ ROMï¼ˆOnChipRomï¼‰å’Œé—ªå­˜ã€‚</p><blockquote><p>Flash memory (or simply flash) is a modern type of EEPROM invented in 1984.</p></blockquote><p>Flash ä¹Ÿæ˜¯ EEPROM çš„ä¸€ç§ã€‚EEPROM ä¸åŒäº EPROM, EEPROM æ˜¯é€šè¿‡ç”µæ“¦é™¤çš„æ–¹å¼æ¥æ›´æ–°çš„ï¼Œç”µæ“¦é™¤çš„ä¼˜ç‚¹åœ¨äºæ›´æ–°å…¶çš„æ—¶å€™ä¸éœ€è¦æŠŠè¿™ä¸ªä¸œè¥¿ä»ç”µè„‘ä¸­ç§»é™¤ã€‚</p><p>Flash ç›¸æ¯”äº EEPROM æ‹¥æœ‰æ›´å¿«çš„æ“¦é™¤é‡å†™é€Ÿåº¦ï¼Œè€Œä¸” endurance åœ¨ç™¾ä¸‡æ¬¡çº§åˆ«ã€‚</p></div><h2 id="refenence" tabindex="-1"><a class="header-anchor" href="#refenence"><span>Refenence</span></a></h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p><a href="https://chromium.googlesource.com/external/github.com/ARM-software/arm-trusted-firmware/+/v0.4-rc1/docs/firmware-design.md" target="_blank" rel="noopener noreferrer">ARM Trusted Firmware Design</a> <a href="#footnote-ref1" class="footnote-backref">â†©ï¸</a></p></li><li id="footnote2" class="footnote-item"><p><a href="https://blog.csdn.net/longwang155069/article/details/105010182" target="_blank" rel="noopener noreferrer">ARMv8-A Exception Levels</a> <a href="#footnote-ref2" class="footnote-backref">â†©ï¸</a></p></li><li id="footnote3" class="footnote-item"><p><a href="https://developer.arm.com/Processors/CoreLink%20CCI-400" target="_blank" rel="noopener noreferrer">CoreLink CCI-400</a> <a href="#footnote-ref3" class="footnote-backref">â†©ï¸</a></p></li><li id="footnote4" class="footnote-item"><p><a href="https://developer.arm.com/documentation/den0028/a/" target="_blank" rel="noopener noreferrer">SMC calling convention PDD</a> <a href="#footnote-ref4" class="footnote-backref">â†©ï¸</a></p></li><li id="footnote5" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Firmware" target="_blank" rel="noopener noreferrer">Firmware</a> <a href="#footnote-ref5" class="footnote-backref">â†©ï¸</a> <a href="#footnote-ref5:1" class="footnote-backref">â†©ï¸</a></p></li><li id="footnote6" class="footnote-item"><p>ç›´è¯‘ä¸ºè®¡ç®—æœºå¤–å›´è®¾å¤‡ <a href="#footnote-ref6" class="footnote-backref">â†©ï¸</a></p></li><li id="footnote7" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Read-only_memory" target="_blank" rel="noopener noreferrer">Read-only memory WiKi</a> <a href="#footnote-ref7" class="footnote-backref">â†©ï¸</a></p></li></ol></section>`,201)]))}const d=o(s,[["render",n]]),h=JSON.parse('{"path":"/linux/kernel/BL31.html","title":"BL3-1","lang":"zh-CN","frontmatter":{"description":"BL3-1 ARM Trusted Firmware Design [1] Introduction The ARM Trusted Firmware implements a subset of the Trusted Board Boot Requirements (TBBR) Platform Design Document (PDD) for ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"BL3-1\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-28T13:50:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Someone\\",\\"url\\":\\"https://www.weigao.cc\\"}]}"],["meta",{"property":"og:url","content":"https://vueblog.weigao.cc/linux/kernel/BL31.html"}],["meta",{"property":"og:site_name","content":"weigao"}],["meta",{"property":"og:title","content":"BL3-1"}],["meta",{"property":"og:description","content":"BL3-1 ARM Trusted Firmware Design [1] Introduction The ARM Trusted Firmware implements a subset of the Trusted Board Boot Requirements (TBBR) Platform Design Document (PDD) for ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T13:50:57.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-28T13:50:57.000Z"}]]},"git":{"createdTime":1650183152000,"updatedTime":1677592257000,"contributors":[{"name":"chenweigao","username":"chenweigao","email":"297859260@qq.com","commits":4,"url":"https://github.com/chenweigao"},{"name":"weigao chen","username":"","email":"weigao_1995@yeah.net","commits":4}]},"readingTime":{"minutes":15.92,"words":4775},"filePathRelative":"linux/kernel/BL31.md","excerpt":"\\n<blockquote>\\n<p>ARM Trusted Firmware Design <sup class=\\"footnote-ref\\"><a href=\\"#footnote1\\">[1]</a><a class=\\"footnote-anchor\\" id=\\"footnote-ref1\\"></a></sup></p>\\n</blockquote>\\n<h2>Introduction</h2>\\n<blockquote>\\n<p>The ARM Trusted Firmware implements a subset of the Trusted Board Boot Requirements (TBBR) Platform Design Document (PDD) for ARM reference platforms. The TBB sequence starts when the platform is powered on and runs up to the stage where it hands-off control to firmware running in the normal world in DRAM. This is the cold boot path.</p>\\n</blockquote>","autoDesc":true}');export{d as comp,h as data};
