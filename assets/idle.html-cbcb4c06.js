import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as i,c as l,d as a,a as n,b as s,f as e}from"./app-22cda79c.js";const u={},d=n("h2",{id:"abstract",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#abstract","aria-hidden":"true"},"#"),s(" Abstract")],-1),r=n("p",null,"本文主要研究 kernel 中的 idle 机制以及代码实现。",-1),k=n("h2",{id:"function-flow",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#function-flow","aria-hidden":"true"},"#"),s(" Function Flow")],-1),v=n("p",null,"我们先对大体上的函数调用栈进行一个简单的示意图总结：",-1),_=e(`<p>cpuidle_enter_state() 之后的流程可以参考 tick_broadcast_oneshot_control() 的分析。</p><h2 id="cpu-startup-entry" tabindex="-1"><a class="header-anchor" href="#cpu-startup-entry" aria-hidden="true">#</a> cpu_startup_entry</h2><p>笔者在实际的业务场景中抓取过 idle 函数的调用栈，大概如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[] [pid:0,cpu6,swapper/6,0] show_stack+0x14/0x1c
[] [pid:0,cpu6,swapper/6,1] dump_stack_lvl+0xb8/0x108
[] [pid:0,cpu6,swapper/6,2] dump_stack+0x14/0x1c
[] [pid:0,cpu6,swapper/6,3] cpuidle_select+0x20/0x54
[] [pid:0,cpu6,swapper/6,4] 0xffffffe55f4d072c
[] [pid:0,cpu6,swapper/6,5] cpu_startup_entry+0x20/0x24
[] [pid:0,cpu6,swapper/6,6] secondary_start_kernel+0x1e8/0x208
[] [pid:0,cpu6,swapper/6,7]CPU: 6 PID: 0 Comm: swapper/6 VIP: 00
[] [pid:0,cpu6,swapper/6,8]TGID: 0 Comm: swapper/6
[] [pid:0,cpu6,swapper/6,9]Hardware name: xxx (DT)
</code></pre><div class="highlight-lines"><br><br><br><div class="highlight-line"> </div><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一个很关键的调用栈，我们可以看到 <code>cpu_startup_entry</code> 会调用到 <code>cpuidle_select</code>, 在图中进行了高亮。</p><p><code>start_kernel</code> → <code>rest_init</code> → <code>cpu_startup_entry</code>, 基本的调用关系可以如此理解，看 <code>cpu_startup_entry</code> 的实现：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token comment">// in kernel/linux-5.10/kernel/sched/idle.c</span>
<span class="token keyword">void</span> <span class="token function">cpu_startup_entry</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">cpuhp_state</span> state<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">arch_cpu_idle_prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cpuhp_online_idle</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token function">do_idle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="hint-container note"><p class="hint-container-title">cpu_startup_entry 流程</p><ul><li><code>void cpu_startup_entry(enum cpuhp_state state)</code><ul><li><code>arch_cpu_idle_prepare()</code>，进行 idle 前的准备工作，ARM64 中没有实现 <ul><li>cpu idle loop: 进入 cpuidle 的主循环；在上面代码中体现为 while loop <ul><li>…</li><li><em>下面的流程见 <code>do_idle()</code></em></li></ul></li></ul></li></ul></li></ul></div><p>也就是说，idle 线程执行的时候，是一直在运行这个 <code>do_idle()</code> 的。</p><h2 id="do-idle" tabindex="-1"><a class="header-anchor" href="#do-idle" aria-hidden="true">#</a> do_idle</h2><p><code>do_idle()</code> 会执行 CPU idle 的主要操作。</p><div class="hint-container note"><p class="hint-container-title">cpu_idle_loop 调用流程 static void do_idle(void)</p><ul><li><p><code>__current_set_polling()</code>: 后续研究</p></li><li><p><code>tick_nohz_idle_enter()</code>: 后续研究</p></li><li><p>如果系统当前不需要调度（<code>while (!need_resched())</code>），执行后续的动作</p><ul><li><p>local_irq_disable()，关闭 irq 中断</p></li><li><p>arch_cpu_idle_enter()，arch 相关的 cpuidle enter，ARM64 中没有实现</p></li><li><p><strong>cpuidle_idle_call()</strong>，main idle function</p><ul><li>cpuidle_select，通过 cpuidle governor，选择一个 cpuidle state</li><li>cpuidle_enter，通过 cpuidle state，进入该 idle 状态</li><li>…</li><li>中断产生，idle 返回（注意，此时irq是被禁止的，因此CPU不能响应产生中断的事件）</li><li>cpuidle_reflect，通知 cpuidle governor，更新状态</li><li>local_irq_enable，使能中断，响应中断事件，跳转到对应的中断处理函数</li><li>…</li></ul></li></ul></li><li><p>arch_cpu_idle_exit，和 enter 类似，ARM64没有实现</p></li></ul></div><h2 id="local-irq-dis-en-able" tabindex="-1"><a class="header-anchor" href="#local-irq-dis-en-able" aria-hidden="true">#</a> local_irq_dis(en)able</h2><p>这个函数涉及到中断处理的相关操作，<code>local_irq_disable()</code> 会禁止本地中断的传递，在这个地方有 4 个相似的接口，可以加以区分便于使用：</p><table><thead><tr><th style="text-align:center;">函数</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">local_irq_disable()</td><td style="text-align:center;">禁止本地中断传递</td></tr><tr><td style="text-align:center;">local_irq_enable()</td><td style="text-align:center;">激活本地中断传递（无条件激活中断）</td></tr><tr><td style="text-align:center;">local_irq_save()</td><td style="text-align:center;">保存本地中断传递的当前状态，然后禁止本地中断传递</td></tr><tr><td style="text-align:center;">local_irq_restore()</td><td style="text-align:center;">恢复本地中断传递到更定的状态</td></tr></tbody></table><p>通常而言，我们会使用 <code>local_irq_save()</code> 和 <code>local_irq_restore()</code> 配合使用，这样做的好处在于：我们在此之前并不知道本地中断是开启还是关闭的，如果要使我们的代码对中断的原始状态不做过多的影响，用这两个接口是非常合适的。再多说一些，<code>local_irq_enable()</code> 是会无条件激活中断的，尽管这个中断可能在开始时就是关闭的。</p><p>再回到禁止中断这个事情本身，通过禁止中断，可以确保某个中断处理程序不会抢占当前的代码；此外，禁止中断还可以禁止内核抢占。但是需要注意的是，禁止中断并不能避免来自其他处理器的并发访问（使用锁来防止并发访问，或者使用核独占的数据结构）。</p><p>实现禁止中断只需要使用一条汇编指令即可，在 arm64 中使用的是 <code>msr daifclr, #2</code> 来禁止中断。</p><h2 id="cpuidle-idle-call" tabindex="-1"><a class="header-anchor" href="#cpuidle-idle-call" aria-hidden="true">#</a> cpuidle_idle_call</h2><p>在外围对是否进入该函数有一个判断：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>cpu_idle_force_poll <span class="token operator">||</span> <span class="token function">tick_check_broadcast_expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">tick_nohz_idle_restart_tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cpu_idle_poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">cpuidle_idle_call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>cpu_idle_force_poll</code> 表示是否开启强制轮询模式，关于 idle polling 可以见下面章节的描述；</p><p><code>tick_check_broadcast_expired</code> 表示 tick 是否过期需要重新开始以免进入深度睡眠。</p><p>在进入 cpuidle_idle_call 之后，会有一段较长的逻辑：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cpuidle_idle_call</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// ...</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpuidle_not_available</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">tick_nohz_idle_stop_tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token function">default_idle_call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">goto</span> exit_idle<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">idle_should_enter_s2idle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> dev<span class="token operator">-&gt;</span>forced_idle_latency_limit_ns<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// ...</span>
		<span class="token function">call_cpuidle</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> next_state<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		next_state <span class="token operator">=</span> <span class="token function">cpuidle_select</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stop_tick<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>stop_tick <span class="token operator">||</span> <span class="token function">tick_nohz_tick_stopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token function">tick_nohz_idle_stop_tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token function">tick_nohz_idle_retain_tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		entered_state <span class="token operator">=</span> <span class="token function">call_cpuidle</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> next_state<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token function">cpuidle_reflect</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> entered_state<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

exit_idle<span class="token operator">:</span>
	<span class="token function">__current_set_polling</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们去除了一些复杂细节，专注于我们的主体流程研究。</p><p>cpuidle_idle_call 函数刚开始，先是两个判断：</p><ol><li>need_resched(): 是否有任务过来需要调度？</li><li>cpuidle_not_available(drv, dev): 驱动是否支持？</li></ol><p>这两个判断的结果比较明显，分支预测准确的概览也较大。</p><p>接下来的流程就是进行判断，根据策略的不同走不同的分支，最终都会调用到函数 call_cpuidle.</p><h2 id="call-cpuidle" tabindex="-1"><a class="header-anchor" href="#call-cpuidle" aria-hidden="true">#</a> call_cpuidle</h2><p>该函数的逻辑比较简单，就是一些特殊情况的判断，而后进行 <strong>cpuidle_enter</strong> 函数的调用：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">call_cpuidle</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cpuidle_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">cpuidle_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>
		      <span class="token keyword">int</span> next_state<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">current_clr_polling_and_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// ...</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token function">cpuidle_enter</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> next_state<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cpuidle_enter 的逻辑也是非常简单，进行一个判断：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">cpuidle_enter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cpuidle_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">cpuidle_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>
		  <span class="token keyword">int</span> index<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpuidle_state_is_coupled</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span>
		ret <span class="token operator">=</span> <span class="token function">cpuidle_enter_state_coupled</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> drv<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		ret <span class="token operator">=</span> <span class="token function">cpuidle_enter_state</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> drv<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token comment">// ...</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><div class="highlight-line"> </div><br><div class="highlight-line"> </div><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论哪种情况，都是会进行 cpuidle_enter_state 函数的调用。</p><h2 id="cpuidle-enter-state" tabindex="-1"><a class="header-anchor" href="#cpuidle-enter-state" aria-hidden="true">#</a> cpuidle_enter_state()</h2><blockquote><p>函数位置：kernel/linux-5.10/drivers/cpuidle/cpuidle.c</p></blockquote><p>为了方便我们理解记忆，将该函数进行分解：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">cpuidle_enter_state</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cpuidle_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">cpuidle_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">,</span>
			<span class="token keyword">int</span> index<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> index<span class="token punctuation">;</span>

	broadcast <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>target_state<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CPUIDLE_FLAG_TIMER_STOP<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>broadcast <span class="token operator">&amp;&amp;</span> <span class="token function">tick_broadcast_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// maybe return</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>target_state<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CPUIDLE_FLAG_TLB_FLUSHED<span class="token punctuation">)</span>
		<span class="token function">leave_mm</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>target_state<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CPUIDLE_FLAG_RCU_IDLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">rcu_idle_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	entered_state <span class="token operator">=</span> target_state<span class="token operator">-&gt;</span><span class="token function">enter</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> drv<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>target_state<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CPUIDLE_FLAG_RCU_IDLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">rcu_idle_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* The cpu is no longer idle or about to enter idle. */</span>
	<span class="token function">sched_idle_set_state</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>broadcast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cpuidle_state_is_coupled</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>entered_state <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> entered_state<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数核心的逻辑是进入给定 index 的 idle 状态 <code>target_state-&gt;enter(dev, drv, index);</code>, 然后将这个状态返回；但是在实际的实现中，因为涉及到中断、tick、配置等逻辑，所以比较复杂。</p><p>下文是对代码中细节和原理的研究：</p><h3 id="broadcast" tabindex="-1"><a class="header-anchor" href="#broadcast" aria-hidden="true">#</a> broadcast</h3><div class="language-c" data-ext="c"><pre class="language-c"><code>broadcast <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>target_state<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CPUIDLE_FLAG_TIMER_STOP<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这行代码的作用是设置一个广播标志，判断是否需要停止定时器。其中，target_state 是一个指向 cpuidle_state 结构体的指针，该结构体描述了 CPU 的空闲状态，包括状态标识、所需的底层硬件支持、进入和退出该状态所需的操作等信息。</p><p>具体来说，target_state-&gt;flags 是一个位掩码，用于描述该空闲状态标识的一些特定属性。&amp;运算符将该位掩码与 CPUIDLE_FLAG_TIMER_STOP 逐位进行 AND 运算，结果非零则表示 target_state 的 flags 属性中存在 CPUIDLE_FLAG_TIMER_STOP 标志，即需要停止定时器。<em>!!</em> 运算符则将结果转换为布尔类型，确保在任何情况下返回的都是 0 或 1 的布尔值，而不是整型数值（双重否定表示肯定）。</p><p>因此，这行代码最终会将广播标志设置为 true 或 false，表示需要或不需要停止定时器。在 CPU 进入空闲状态之前，内核会根据广播标志来决定是否向其他 CPU 广播空闲状态，并通知它们停止当前正在运行的定时器。</p><p>简单来说，如果 local timer 关闭的话（进入更深层次的 idle 状态），就需要使用 broadcast.</p><h3 id="cpuidle-flag-tlb-flushed" tabindex="-1"><a class="header-anchor" href="#cpuidle-flag-tlb-flushed" aria-hidden="true">#</a> CPUIDLE_FLAG_TLB_FLUSHED</h3><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>target_state<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CPUIDLE_FLAG_TLB_FLUSHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">leave_mm</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码的作用是，<strong>在CPU进入指定的空闲状态之前检查该状态是否需要刷新TLB</strong>，并在必要时执行离开当前进程的操作。（从实测的数据来看，基本上没有刷新 TLB 的操作，这段逻辑很少被执行）</p><p>其中，target_state 是一个指向 cpuidle_state 结构体的指针，描述了要进入的空闲状态，包括状态标识、所需的底层硬件支持和进入该状态所需的操作等信息。flags 字段表示该状态的一些特殊属性，如 CPUIDLE_FLAG_TLB_FLUSHED，表示在进入该状态前需要刷新 TLB（Translation Lookaside Buffer）。</p><p>如果检测到目标状态需要刷新 TLB，则调用 <code>leave_mm(dev-&gt;cpu)</code> 函数执行离开当前进程的操作。该函数的作用是在该 CPU 上的所有进程中暂停当前进程，并切换到空闲进程，以便操作系统在进入空闲状态之前刷新 TLB 高速缓存。</p><p>总之，这段代码的作用是确保在进入特定的空闲状态之前清除 TLB 以避免任何不必要的冲突，同时保证进程能够正确地切换。</p><h3 id="sched-idle-set-state" tabindex="-1"><a class="header-anchor" href="#sched-idle-set-state" aria-hidden="true">#</a> sched_idle_set_state</h3><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Take note of the planned idle state. */</span>
<span class="token function">sched_idle_set_state</span><span class="token punctuation">(</span>target_state<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 其实现如下：</span>
<span class="token keyword">void</span> <span class="token function">sched_idle_set_state</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cpuidle_state</span> <span class="token operator">*</span>idle_state<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">idle_set_state</span><span class="token punctuation">(</span><span class="token function">this_rq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> idle_state<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码的作用是将当前 CPU 切换到指定的空闲状态，也就是进入一种较低功耗的状态以进行省电。注意到在我们的 cpuidle_enter_state 流程中，这个 sched_idle_set_state 函数被两次调用：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Take note of the planned idle state. */</span>
<span class="token function">sched_idle_set_state</span><span class="token punctuation">(</span>target_state<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>

<span class="token comment">/* The cpu is no longer idle or about to enter idle. */</span>
<span class="token function">sched_idle_set_state</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>sched_idle_set_state</code> 是一个内核函数，用于设置当前 CPU 的空闲状态，并让 CPU 进入相应的空闲状态。target_state 是一个指向 cpuidle_state 结构体的指针，描述了要进入的空闲状态，包括状态标识、所需的底层硬件支持和进入该状态所需的操作等信息。</p><p><code>this_rq()</code> 表示<em>当前 CPU 所在的 CPU 运行队列</em>（runqueue），它的返回值是一个指向 <code>struct rq</code> 结构体的指针，该结构体描述了 CPU 调度器的运作情况和统计信息。</p><p>在调用该函数之前，内核通常会执行一些准备工作，如停止定时器、暂停当前进程、刷新 TLB 等。接着，调用该函数将当前 CPU 切换到目标状态，并执行目标状态所需的操作，如关闭某些设备、降低 CPU 主频等。</p><p>整个过程是由内核负责管理和控制的，程序员无法直接控制。当系统需要重新唤醒 CPU 时，内核会根据 CPU 的中断或事件触发来驱动 CPU 从空闲状态中返回，并恢复相关的设备和资源。</p><h3 id="rcu-idle-enter" tabindex="-1"><a class="header-anchor" href="#rcu-idle-enter" aria-hidden="true">#</a> rcu_idle_enter</h3><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>target_state<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CPUIDLE_FLAG_RCU_IDLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">rcu_idle_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码用于判断当前进入空闲状态的目标状态是否需要进行<strong>RCU（Read-Copy-Update）空闲处理</strong>，如果需要，则调用 <code>rcu_idle_enter</code> 函数进行 RCU 空闲处理。</p><p>在Linux内核中，RCU是一种无锁机制，用于在多个进程间共享数据。当一个进程需要修改共享数据时，该进程会先创建出一个新的副本，对其进行修改，然后将新副本加入到RCU保护区中。此时，其他进程仍然可以访问旧的副本，不会受到影响。当所有对旧副本的访问都结束后，RCU保护区才会被清空，新副本才会变成有效的数据。</p><p>在进入空闲状态时，如果当前CPU正在进行RCU更新操作，就需要进行RCU空闲处理，即等待所有正在使用旧副本的进程完成访问后，再进行新副本的更新。这样一来，就可以避免数据的冲突和不一致性。</p><p>rcu_idle_enter函数用于启动RCU空闲处理，并进入RCU空闲状态。该函数会将当前CPU所在的调度器的状态设置为RCU空闲状态，然后等待所有正在使用旧副本的进程访问完毕，直到RCU保护区被清空。在此期间，该CPU不会执行任何其他任务，以避免对正在访问旧副本的进程产生干扰。</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">rcu_idle_enter</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">lockdep_assert_irqs_disabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">rcu_eqs_enter</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>rcu_idle_enter</code> 函数是用于启动RCU空闲处理并进入RCU空闲状态的函数。</p><p>其中，<code>lockdep_assert_irqs_disabled</code> 函数用于断言<strong>当前中断已经被禁止</strong>，在RCU空闲处理期间不会被重新打开。该函数会在执行时检查当前是否处于内核锁定状态，并通过锁依赖机制确保锁的正确性。如果当前存在锁冲突，则会抛出一个警告信息。</p><p><code>rcu_eqs_enter</code> 函数则用于进入RCU空闲状态并等待所有正在使用旧副本的进程访问完毕。其中，参数false表示<em>不需要检查是否处于内核软件调试状态</em>（KDB或KGDB）。在该函数中，会调用rcu_prepare_for_idle函数进行RCU更新准备工作，并将当前CPU所在的调度器状态设置为RCU空闲状态。然后，该函数会启动一个RCU处理线程，在其中等待所有正在使用旧副本的进程访问完毕并结束。❓❓ 待处理线程结束之后，该函数会将当前CPU所在调度器状态设置为正常运行状态，并返回。</p><h3 id="enter" tabindex="-1"><a class="header-anchor" href="#enter" aria-hidden="true">#</a> enter</h3><div class="language-c" data-ext="c"><pre class="language-c"><code>entered_state <span class="token operator">=</span> target_state<span class="token operator">-&gt;</span><span class="token function">enter</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> drv<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>进入 state, 待深入研究。❌❌❌</p><h3 id="rcu-idle-exit" tabindex="-1"><a class="header-anchor" href="#rcu-idle-exit" aria-hidden="true">#</a> rcu_idle_exit</h3><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>target_state<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CPUIDLE_FLAG_RCU_IDLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">rcu_idle_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码用于判断目标状态是否为RCU空闲状态，并在不是RCU空闲状态时退出RCU空闲处理。</p><p>如果目标状态的flags字段中包含CPUIDLE_FLAG_RCU_IDLE标志，说明此时需要进入RCU空闲状态，即需要等待所有正在访问旧副本的进程结束后再进行新副本的更新。此时，不需要退出RCU空闲处理，代码直接跳过。</p><p>但如果目标状态的flags字段中不包含CPUIDLE_FLAG_RCU_IDLE标志，则代表当前并不需要进行RCU空闲处理。此时，需要通过rcu_idle_exit函数退出RCU空闲处理。该函数会将当前CPU所在的调度器状态设置为正常运行状态，并唤醒所有等待RCU更新的进程（如等待RCU更新的进程队列等）。这样一来，RCU更新操作就可以继续进行，而不会被阻塞在RCU空闲状态中。</p><p>需要注意的是，只有在完成了RCU更新操作之后，才能调用rcu_idle_exit函数退出RCU空闲状态。否则，会引起数据访问冲突和不一致性，导致系统出现异常。因此，在使用该函数时，需要保证系统支持RCU机制，并遵循相关的使用原则和规范。</p><h3 id="critical-timings" tabindex="-1"><a class="header-anchor" href="#critical-timings" aria-hidden="true">#</a> critical_timings</h3><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token function">stop_critical_timings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token function">start_critical_timings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>stop_critical_timings</code> 用于停止内核关键代码段的性能计数和统计，以便进行性能分析和优化。该函数通常在内核调试、性能测试等场景下使用，以了解内核关键代码段的耗时和执行情况，从而进行优化。</p><p>该函数会将内核当前的性能计数器（如TSC、APIC计数器等）停止，并记录下停止时的值，然后将所有的性能计数器状态都设置为暂停。这样一来，在停止之前和停止之后，所有关键代码段的执行时间就可以计算出来了。</p><p><code>start_critical_timings</code> 的作用正好相反，就不过多赘述了。</p><h2 id="idle-polling" tabindex="-1"><a class="header-anchor" href="#idle-polling" aria-hidden="true">#</a> idle polling</h2><p>idle polling 是一个空闲轮询机制。</p><p>我们来看代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_GENERIC_IDLE_POLL_SETUP</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">cpu_idle_poll_setup</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>__unused<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cpu_idle_force_poll <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">__setup</span><span class="token punctuation">(</span><span class="token string">&quot;nohlt&quot;</span><span class="token punctuation">,</span> cpu_idle_poll_setup<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">cpu_idle_nopoll_setup</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>__unused<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cpu_idle_force_poll <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">__setup</span><span class="token punctuation">(</span><span class="token string">&quot;hlt&quot;</span><span class="token punctuation">,</span> cpu_idle_nopoll_setup<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>cpu_idle_poll_ctrl</code>可以作为一个调度器选项，对空闲轮询机制进行控制。其具体做法是：</p><ul><li><p>当<code>cpu_idle_poll_ctrl=1</code>时，空闲轮询机制被启用，调度器会直接检查是否有可运行的进程；</p></li><li><p>当<code>cpu_idle_poll_ctrl=0</code>时，空闲轮询机制被禁用，CPU会挂起或执行某些简单指令以等待其他事件的发生。</p></li></ul><p>在传统的CPU调度方案中，当CPU处于空闲状态时，调度器通常会挂起CPU或让CPU执行一些简单的指令，以避免CPU浪费过多的时间。而在空闲轮询机制下，调度器会在CPU空闲时，立即检查系统中是否有可运行的进程，如果有，则立即唤醒该进程并将CPU分配给它。</p><p>具体的 polling 实现可能会分成很多种，如 busy-waiting, 表示如果没有可以运行的进程的话，则调度器会继续等待下一次轮询；如 sleep, 当 CPU 空闲时，会将整个 CPU 设置为休眠状态，以节能。</p><h2 id="define-per-cpu" tabindex="-1"><a class="header-anchor" href="#define-per-cpu" aria-hidden="true">#</a> DEFINE_PER_CPU</h2><p><code>DEFINE_PER_CPU</code> 是一个宏，用于定义一种特殊的变量类型，称为 &quot;per-cpu 变量&quot;。这种变量在 Linux 内核中广泛使用，用于跨多个 CPU 核心共享数据时保证数据的一致性。</p><p>使用 <code>DEFINE_PER_CPU</code> 宏定义的变量，会在每个 CPU 核心上都创建一个独立的副本，并通过内核提供的函数接口进行同步和访问。这样，在多核系统中，不同 CPU 核心上的代码可以同时访问该变量，而不会出现数据竞争或者锁竞争等问题。</p><p>具体来说，<code>DEFINE_PER_CPU</code> 宏的语法如下：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token function">DEFINE_PER_CPU</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> var<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>其中，<code>type</code> 指定了变量的类型，<code>var</code> 是变量名。例如：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token function">DEFINE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> my_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上述代码定义了一个名为 <code>my_var</code> 的 per-cpu 整型变量。在汇编层面，编译器会自动生成对应的代码，以便为每个 CPU 核心上创建一个独立的 <code>int</code> 类型的变量，并对其进行初始化和管理。在 C 代码层面，程序员可以通过 <code>get_cpu_var()</code> 和 <code>put_cpu_var()</code> 等函数来访问和修改 per-cpu 变量的值，例如：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token function">get_cpu_var</span><span class="token punctuation">(</span>my_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">put_cpu_var</span><span class="token punctuation">(</span>my_var<span class="token punctuation">,</span> val<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>需要注意的是，per-cpu 变量仅适用于每个 CPU 核心独立使用的数据，并不适用于需要全局同步的数据结构。此外，需要注意内存分配和访问的开销，以避免影响系统的性能。</p><h2 id="idle-data-struct" tabindex="-1"><a class="header-anchor" href="#idle-data-struct" aria-hidden="true">#</a> Idle Data Struct</h2><h3 id="abstract-1" tabindex="-1"><a class="header-anchor" href="#abstract-1" aria-hidden="true">#</a> Abstract</h3><p>本章节主要针对性分析 Idle 中的数据结构。在 kernel 中的 cpuidle framework 主体包括三个模块：cpuidle core, cpudile governors 和 cpuidle drivers.</p><p><strong>cpuidle core</strong>: 负责整体框架，对接 sched 模块，调度器发现没有任务在执行的时候，就切换到 idle 进程，通知就会给 cpuidle core; cpuidle core 负责向 cpuidle driver/governors 模块提供统一的注册和管理接口，向用户空间提供 governor 选择的接口。</p><p><strong>cpuidle governors</strong>: 在该模块进行 cpuidle 的选择；</p><p><strong>cpuidle driver</strong>: 负责具体 idle 机制的实现。</p><p>总的来说，这几个的关系大致如下图所示：</p>`,111),b=e('<h3 id="cpuidle-core" tabindex="-1"><a class="header-anchor" href="#cpuidle-core" aria-hidden="true">#</a> cpuidle core</h3><p>cpuidle core 是 cpuidle framework 的核心模块，负责抽象出 cpuidle device、cpuidle driver 和 cpuidle governor三个实体。</p><p>其负责的功能有：</p><ol><li>（如上阐述）向底层的 cpuidle driver 模块提供 cpudile devic e和 cpuidle driver 的注册/注销接口；</li><li>（如上阐述）向 cpuidle governors 提供 governor 的注册接口；</li><li>提供全局的 puidle 机制的开、关、暂停、恢复等功能；</li><li>（如上阐述）向用户空间程序提供 governor 选择的接口；</li><li>向 kernel sched 中的 cpuidle entry 提供 cpuidle 的级别选择、进入等接口，以方便调用。</li></ol><h3 id="cpuidle-device" tabindex="-1"><a class="header-anchor" href="#cpuidle-device" aria-hidden="true">#</a> cpuidle device</h3><p>在现在的 SMP 系统中，每个 cpu core 都会对应一个 cpuidle device, 内核通过 <code>strcut cpuidle_device</code> 抽象 cpuidle device.</p><h3 id="cpuidle-driver" tabindex="-1"><a class="header-anchor" href="#cpuidle-driver" aria-hidden="true">#</a> cpuidle driver</h3><p>cpuidle driver 是一个 “driver&quot;, 其驱动的对象是 cpuidle device, 也就是 CPU；注意到在 SMP 系统中，有多个 CPU，也就意味着有多个 cpuidle device; 在实现 idle 的时候，如果这些 cpuidle device 的功能、参数相同，则可以使用一个 cpuidle driver 驱动，具体而言，kernel 中的宏 <code>CONFIG_CPU_IDLE_MULTIPLE_DRIVERS</code> 可以用来使能是否使用多个 cpu driver. 在实际的应用场景中，这个开关是被使能的。</p>',8),m={href:"https://github.com/torvalds/linux/blob/master/include/linux/cpuidle.h",target:"_blank",rel:"noopener noreferrer"},h=e(`<div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/****************************
 * CPUIDLE DRIVER INTERFACE *
 ****************************/</span>

<span class="token keyword">struct</span> <span class="token class-name">cpuidle_driver</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span>		<span class="token operator">*</span>name<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">module</span> 		<span class="token operator">*</span>owner<span class="token punctuation">;</span>

        <span class="token comment">/* used by the cpuidle framework to setup the broadcast timer */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span>            bctimer<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">/* states array must be ordered in decreasing power consumption */</span>
	<span class="token keyword">struct</span> <span class="token class-name">cpuidle_state</span>	states<span class="token punctuation">[</span>CPUIDLE_STATE_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span>			state_count<span class="token punctuation">;</span>
	<span class="token keyword">int</span>			safe_state_index<span class="token punctuation">;</span>

	<span class="token comment">/* the driver handles the cpus in cpumask */</span>
	<span class="token keyword">struct</span> <span class="token class-name">cpumask</span>		<span class="token operator">*</span>cpumask<span class="token punctuation">;</span>

	<span class="token comment">/* preferred governor to switch at register time */</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span>		<span class="token operator">*</span>governor<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bctimer:1</code>: 一个标志，用于指示在 cpuidle driver 注册和注销时，是否需要设置一个 broadcast timer;</p><p><code>cpumask</code>: 一个 struct cpumask 结构的 bit map 指针，用于说明该 driver 支持哪些 cpu core;</p><p><code>states</code>, <code>state_count</code>：该 driver 所支持的 idle state 及其个数。cpuidle driver 的主要任务就是定义所支持的 cpuidle state; 需要注意注释中所提到的，<code>states</code> 应该按照功耗大小降序排列。</p><p>cpuidle driver 的注册，我们在这边主演研究多个 cpu driver 的场景，主要是分为几个：</p><p>💄 <code>__cpuidle_get_cpu_driver</code>:</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">cpuidle_driver</span> <span class="token operator">*</span><span class="token function">__cpuidle_get_cpu_driver</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 返回 pre_cpu 指针的值</span>
	<span class="token keyword">return</span> <span class="token function">per_cpu</span><span class="token punctuation">(</span>cpuidle_drivers<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>💄<code>__cpuidle_set_driver</code></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__cpuidle_set_driver</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cpuidle_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> cpu<span class="token punctuation">;</span>

	<span class="token function">for_each_cpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> drv<span class="token operator">-&gt;</span>cpumask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">cpuidle_driver</span> <span class="token operator">*</span>old_drv<span class="token punctuation">;</span>

		old_drv <span class="token operator">=</span> <span class="token function">__cpuidle_get_cpu_driver</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>old_drv <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>old_drv <span class="token operator">!=</span> drv<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">for_each_cpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> drv<span class="token operator">-&gt;</span>cpumask<span class="token punctuation">)</span>
		<span class="token function">per_cpu</span><span class="token punctuation">(</span>cpuidle_drivers<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span> <span class="token operator">=</span> drv<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于每个 cpumask 的 cpu, 设置 drv; 条件是原有的 cpu 无 drv 或者是有 drv 并且和需要设置的不相等（不相等的话直接 return 不进行设置）</li><li>设置的方法如高亮行所示</li></ul><h2 id="something-else" tabindex="-1"><a class="header-anchor" href="#something-else" aria-hidden="true">#</a> Something Else</h2><h3 id="tickless" tabindex="-1"><a class="header-anchor" href="#tickless" aria-hidden="true">#</a> tickless</h3><blockquote><p>In the context of operating systems, &quot;tickless&quot; refers to a power management feature that allows the system to reduce power consumption by dynamically adjusting the frequency of timer interrupts.</p></blockquote><p>About &quot;tick&quot; interrupt:</p><blockquote><p>Traditionally, operating systems use a periodic timer interrupt, often called the &quot;tick,&quot; to keep track of time and to perform various tasks such as updating the system clock, scheduling tasks, and handling interrupts. These timer interrupts are generated at a fixed frequency, regardless of whether there is any work to be done, which can consume a significant amount of power.</p></blockquote><h3 id="wfi" tabindex="-1"><a class="header-anchor" href="#wfi" aria-hidden="true">#</a> WFI</h3><p>WFI 是英文 Wait for Interrupt 的缩写，意为等待中断。WFI 指令是 ARM 处理器提供的一种指令，用于将处理器置于等待状态，直到下一个中断事件发生后才会继续执行。</p><p>Arm64 提供了 WFI 指令，使得 CPU 一旦执行该指令就进入低功耗状态，该状态会关闭 CPU 时钟，从而降低动态功耗。</p><p>如果我们想实现一个简单的 idle 的话，需要以下的流程即可<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上述代码中，我们的 CPU 空转一直等待某个条件成立；这是最简单的实现方法。</p><p>而 Arm64 提供的 WFI 指令可以帮助系统降低功耗。此外，操作系统还可以通过 WFI 指令实现快速唤醒，以保证系统的响应速度和实时性。</p><hr><hr class="footnotes-sep">`,24),g={class:"footnotes"},f={class:"footnotes-list"},y={id:"footnote1",class:"footnote-item"},w={href:"https://zhuanlan.zhihu.com/p/539722367",target:"_blank",rel:"noopener noreferrer"},x=n("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1);function C(U,P){const t=c("Mermaid"),p=c("ExternalLinkIcon");return i(),l("div",null,[d,r,k,v,a(t,{id:"mermaid-12",code:"eJxdkLsOgyAUhnefwhEHTap7k3rrC3RrGkLhGE2JWMA0vn3haEstA8P//RdCJ9WL90zb+FJHsTunqwGuRsH0Qo11gD5AjyBvcZoe45LwaV71eaIwWr0kGCsRV0QoOggJq1ihWBOpOJN00E8qBsPufzgnTPOe+mIf9a2gd47CryLDy5XJldcFGprD12BAArd7mhOf8APhaU2+sRD92f0kw7CGLhS7FPJ2n/X/Yrf+Fg1nkmVZEr0BlYBn0g=="}),_,a(t,{id:"mermaid-476",code:"eJxNjk0Kg0AMhfeeIst2YY9QqD+F7oS2KxGRmFZhMJIZ68KZu3cchtIsAsn73kteilccOjHwKBLwdanvOFC/KJIG0vRs9ToaHFrDFrLDrVcElTCS1sfAZzsEFudl9FobGnZKWci3bZ8AWci5ABdx9eYPycTiHKSnf7smRWi8N+B5eMBrLU2GxEIZ/b2MPiCGlj+KZ23hWufVMxxtki8yeUnT"}),b,n("p",null,[s("代码可见 "),n("a",m,[s("https://github.com/torvalds/linux/blob/master/include/linux/cpuidle.h"),a(p)])]),h,n("section",g,[n("ol",f,[n("li",y,[n("p",null,[n("a",w,[s("https://zhuanlan.zhihu.com/p/539722367"),a(p)]),s(),x])])])])])}const R=o(u,[["render",C],["__file","idle.html.vue"]]);export{R as default};
