import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as a,o as h}from"./app-11Vuyqh7.js";const t={};function l(n,i){return h(),e("div",null,i[0]||(i[0]=[a(`<h2 id="abstract" tabindex="-1"><a class="header-anchor" href="#abstract"><span>Abstract</span></a></h2><p>本文章作为一个 ARM 指令的速查表使用。</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">MNEMONIC{S}{condition} {Rd}, Operand1, Operand2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面就是 ARM 汇编指令的一个通用的格式说明，下面对每一个字段进行具体的说明：</p><ul><li>MNEMONIC: 指令的助记符，如 ADD</li><li>S: 可选的扩展位，如果指令后带了这个，将根据计算结果更新 CPSR 寄存器中相应的 FLAG</li><li>condition: 执行条件，如果没有指定，则默认位 AL（无条件执行）</li><li>Operand1: 第一个操作数，可以是寄存器或者立即数</li><li>Operand2: 第二个操作数，可变的，可以是一个寄存器或者立即数，甚至带移位操作的寄存器</li></ul><p>对于 Operand2 的解释和研究举例：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">#</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">		@ - 立即数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">Rx			@ - 寄存器，如 R1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">Rx, ASR n	 @ - 对寄存器中的值进行算术右移 n 位后的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">Rx RRX		@ - 对寄存器中的值进行带扩展的循环右移 </span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> 位后的值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="branch" tabindex="-1"><a class="header-anchor" href="#branch"><span>Branch</span></a></h2><table><thead><tr><th>Instruction</th><th>Example</th><th>Remark</th></tr></thead><tbody><tr><td>SUB</td><td></td><td>不进位的减法</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="sub" tabindex="-1"><a class="header-anchor" href="#sub"><span>sub</span></a></h3><p>减法指令，并且是不进位的减法。</p><h3 id="b" tabindex="-1"><a class="header-anchor" href="#b"><span>b</span></a></h3><p>（branch）跳转到某地址（无返回）, 不会改变 <em>lr (x30)</em> 寄存器的值；一般是本方法内的跳转，如 <code>while</code> 循环，<code>if else</code> 等 ，如：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">b LBB0_1      </span><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">; 直接跳转到标签 ‘LLB0_1’ 处开始执行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>b 指令的一些变体<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></p><ul><li><p><code>bl</code>: 跳转到标号出执行</p></li><li><p><code>b.le</code> ：判断上面cmp的值是小于等于 执行标号，否则直接往下走</p></li><li><p><code>b.ge</code> 大于等于 执行地址 否则往下</p></li><li><p><code>b.lt</code> 判断上面camp的值是 小于 执行后面的地址中的方法 否则直接往下走</p></li><li><p><code>b.gt</code> 大于 执行地址 否则往下</p></li><li><p><code>b.eq</code> 等于 执行地址 否则往下</p></li><li><p><code>b.hi</code> 比较结果是无符号大于，执行地址中的方法，否则不跳转</p></li><li><p><code>b.hs</code> 指令是判断是否无符号小于</p></li><li><p><code>b.ls</code> 指令是判断是否无符号大于</p></li><li><p><code>b.lo</code> 指令是判断是否无符号大于等于</p></li></ul><p>我们总结了一些常见的跳转指令的集合，如下所示：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">[</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.pl</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.ge</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.ls</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.vs</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">tbnz</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.gt</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">cbnz</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">svc</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.mi</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.lo</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">tbz</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.ne</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.hi</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">br</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.le</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.eq</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">ret</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">bl</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.lt</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">blr</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">b.hs</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;"> &#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">cbz</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="tst" tabindex="-1"><a class="header-anchor" href="#tst"><span>tst</span></a></h3><p>把一个寄存器的内容和另一个寄存器的内容进行按位与操作，并根据结果更新 CPSR 中条件标志位的值，当前运算结果为 1, 则 Z=0, 反之 Z=1.</p><h3 id="fcvtz" tabindex="-1"><a class="header-anchor" href="#fcvtz"><span>fcvtz</span></a></h3><p>浮点数转换为定点数。</p><h3 id="cbz" tabindex="-1"><a class="header-anchor" href="#cbz"><span>cbz</span></a></h3><p>和 0 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）;</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">CBZ Rn, label</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>Rn</code>: is the register holding the operand.</p><p><code>label</code>: is the branch destination.</p><p>同样的，还有不为 0 的时候跳转：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">CBNZ Rn, label</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="tbnz" tabindex="-1"><a class="header-anchor" href="#tbnz"><span>tbnz</span></a></h3><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">TBNZ X1, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">, label</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上述汇编的含义为，如果 <code>x1</code> 寄存器的第 3 位不为 0, 则跳转到 label.</p><p>还有用法如下：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">tbnz w16, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">, #+</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0xc</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> (addr </span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0x1baecc</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>按照上述的例子可以推断，判断 <code>w16</code> 的第 0 位是否为 0, 如果不为 0, 则跳转到上述地址。</p><h3 id="sxtw" tabindex="-1"><a class="header-anchor" href="#sxtw"><span>sxtw</span></a></h3><p><code>sxtw</code> 指令的使用方法如下：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">sxtw x7, w6</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其含义为将 <code>w6</code> 进行符号位扩展，并传给 <code>x7</code>; <code>w6</code> 为 <code>x7</code> 的低 32 位.</p><p>这个博客上面展示了一个 <code>sxtw</code> 导致的惨案：<a href="https://egguncle.github.io/2019/03/26/%E4%B8%80%E4%B8%AAinclude%E5%BC%95%E8%B5%B7%E7%9A%84%E6%83%A8%E6%A1%88/" target="_blank" rel="noopener noreferrer">一个include引起的惨案</a></p><h2 id="内存读写" tabindex="-1"><a class="header-anchor" href="#内存读写"><span>内存读写</span></a></h2><p>ARM 使用加载存储模型进行内存访问，这意味着只有加载/存储（<strong>LDR 和 STR</strong>）指令才能访问内存。在 x86 上，大多数指令都可以直接对内存中的数据进行操作，而在ARM上，<strong>必须先将内存中的数据从内存移到寄存器中，然后再进行操作</strong>。这意味着递增ARM上特定内存地址上的 32 位值将需要三种类型的指令（加载，递增和存储），以便首先将特定地址上的值加载到寄存器中，在寄存器中递增值，以及将其从寄存器存储回存储器<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>。</p><h3 id="ldr" tabindex="-1"><a class="header-anchor" href="#ldr"><span>ldr</span></a></h3><p>加载一个寄存器：</p><ul><li>32 位常量</li><li>地址</li></ul><p>用于从存储器中将一个 32 位的字数据传送到目的寄存器中。</p><ul><li><p>将寄存器 x1 的值作为地址，取该内存地址的值放入寄存器 x0 中：<code>x0 &lt;- [x1]</code></p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldr x0, [x1]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>将栈内存 [sp + 0x8] 处的值读取到 w8 寄存器中</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldr w8, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#81A1C1;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0x8</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>将寄存器 x1 的值加上 4 作为内存地址, 取该内存地址的值放入寄存器 x0 中, 然后将寄存器 x1 的值加上 4 放入寄存器 x1 中: <code>x0 &lt;- [x1 + 4]; x1 &lt;- x1 + 4</code></p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldr x0, [x1, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">]!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>将寄存器 x1 的值作为内存地址，取内该存地址的值放入寄存器 x0 中, 再将寄存器 x1 的值加上 4 放入寄存器 x1 中</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldr x0, [x1], #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>将寄存器 x1 和寄存器 x2 的值相加作为地址，取该内存地址的值放入寄存器 x0 中</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldr x0, [x1, x2]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h3 id="ldur" tabindex="-1"><a class="header-anchor" href="#ldur"><span>ldur</span></a></h3><p>和 <code>ldr</code> 一样，只不过，<code>ldur</code> 后面的立即数是负数。</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldur w16, [x5, #-</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="ldp" tabindex="-1"><a class="header-anchor" href="#ldp"><span>ldp</span></a></h3><p>举例来说：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldp	x20, x19, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#81A1C1;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0x150</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>简单可以理解为将栈弹出到 x20, x19 中。</p><h3 id="ldrb" tabindex="-1"><a class="header-anchor" href="#ldrb"><span>ldrb</span></a></h3><p>和下文中的 <code>strb</code> 的含义一样，将内存中的值读入寄存器中，并且只读取一个字节，也就是说把取到的数据放在目的寄存器的低 8 位，然后将高 24 位填充位 0。</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldrb w2, [x5, x2]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>读取 <code>x5 + x2</code> 内存的值并且存储其低 8 位到 <code>w2</code> 中。</p><p>关于其硬件原理的介绍，也可以参考这篇博客<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>：<a href="http://t.zoukankan.com/amanlikethis-p-3444411.html" target="_blank" rel="noopener noreferrer">ARM的STRB和LDRB指令分析</a></p><h3 id="ldrh" tabindex="-1"><a class="header-anchor" href="#ldrh"><span>ldrh</span></a></h3><p><code>ldrh</code> 和 <code>ldrb</code> 一样，不同之处在于 <code>ldrh</code> 会读入半个字长，就是 4 位。</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ldrh w2, [x5, x2, </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">lsl</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>将 <code>x5 + (x2 &lt;&lt; 1)</code> 的地址对应的值放入寄存器 <code>w2</code> 中，注意只放入读取到的值的最低 4 位，剩余的高 28 位填 0.</p><h3 id="ldrsw" tabindex="-1"><a class="header-anchor" href="#ldrsw"><span>ldrsw</span></a></h3><p>在 ARM 架构中，<code>LDRSW</code> 指令是用于从内存中读取一个 32 位带符号整数到寄存器的指令。<code>LDRSW</code> 的全称是“Load Register Signed Word”，其中的 <code>S</code> 表示的是 Signed，即有符号类型。</p><p>具体来说，<code>LDRSW</code> 指令的语法如下所示：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">LDRSW Xt, [Xn{,#</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">|,#Imm}]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中：</p><ul><li><code>Xt</code>：目标寄存器，用于存储从内存中读取的带符号整数。</li><li><code>Xn</code>：基地址寄存器，用于存储待读取数据的内存地址。</li><li><code>#Imm</code>：偏移量，用于计算实际要读取的内存地址，可以是 1~4 字节的立即数，根据指令变体的不同，也可能存在其他可选的偏移量格式。</li></ul><p>执行 <code>LDRSW</code> 指令时，它会从指定的内存地址中取得一个 32 位带符号整数，将其符号位扩展（sign extension）至 64 位，并将结果存储到目标寄存器中。需要注意的是，<code>LDRSW</code> 指令只能读取 32 位的有符号整数，如果需要读取其它类型的数据，则需要使用其他类型的 Load 指令。</p><p>总之，<code>LDRSW</code> 指令是 ARM 架构中的一种用于从内存中读取带符号整数的指令，可以广泛应用于各种需要使用 32 位有符号整数的场景中。</p><h3 id="adrp" tabindex="-1"><a class="header-anchor" href="#adrp"><span>adrp</span></a></h3><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">adrp x23, #-</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0x3ed000</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> (addr -</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0x234000</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>adrp 一般用于获得地址，就我个人的理解而言，adrp 将当前 PC 所在的页的基地址计算得到并存储到寄存器中，后续根据这个寄存器中的基地址进行偏移运算。</p><p>引用一个博客中的一段描述<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>：</p><blockquote><p>adrp指令根据 PC 的偏移地址计算目标页地址。首先 adrp 将一个 21 位有符号立即数<strong>左移</strong> 12 位，得到一个 33 位的有符号数（最高位为符号位），接着将 PC地址的低 12 位清零，这样就得到了当前 PC 地址所在页的地址，然后将当前 PC 地址所在页的地址加上 33 位的有符号数，就得到了目标页地址，最后将目标页地址写入通用寄存器。此处页大小为 4KB，只是为了得到更大的地址范围，和虚拟内存的页大小没有关系。通过 adrp 指令，可以<strong>获取当前 PC 地址 ±4GB范围内的地址</strong>。通常的使用场景是先通过 adrp 获取一个基地址，然后再通过基地址的偏移地址获取具体变量的地址。</p></blockquote><p>从上面的描述中我们可以看出，adrp 的结果是与当前的 PC 有关的，通过当前 PC 地址的偏移地址计算目标地址，因此属于位置无关码；在示例中括号也给出了最终的偏移地址。</p><h3 id="stp" tabindex="-1"><a class="header-anchor" href="#stp"><span>stp</span></a></h3><p>入栈指令，store pair</p><h3 id="str" tabindex="-1"><a class="header-anchor" href="#str"><span>str</span></a></h3><p>(store register) 将寄存器中的值写入到内存中，如：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> w9, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#81A1C1;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">0x8</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>将寄存器 w9 中的值保存到栈内存 <code>[sp + 0x8]</code> 处。</p><h3 id="strb" tabindex="-1"><a class="header-anchor" href="#strb"><span>strb</span></a></h3><p>(store register byte) 将寄存器中的值写入到内存中（只存储一个字节），如：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">strb w8, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#81A1C1;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>将寄存器 w8 中的低 1 字节的值保存到栈内存 <code>[sp + 7]</code> 处</p><h3 id="stlxr" tabindex="-1"><a class="header-anchor" href="#stlxr"><span>stlxr</span></a></h3><p>在 ARM 架构中，<code>STLXR</code> 指令是原子性的存储、条件执行和即时跳转指令。该指令用于在多核创建共享内存并发访问的场景中，对数据进行原子性操作，以保证数据的一致性和正确性。</p><p>具体来说，<code>STLXR</code> 指令的含义如下：</p><ul><li><code>STLXR</code>: Store Exclusive Register</li><li><code>Rd</code>: 目标寄存器，用于存储“存储操作”是否成功，取值为 0 或者 1。</li><li><code>Rt</code>: 源寄存器，其中存储“写入数据”。</li><li><code>Rn</code>: 目标地址寄存器，其中存储需要写入数据的内存地址。</li></ul><p>当执行 <code>STLXR</code> 指令时，它会将目标存储地址（<code>Rn</code>）处的数据与当前处理器正在执行的 CPU 的标识进行比较。如果这个位置的值与标识符相同，则将源寄存器（<code>Rt</code>）中的数据写入该位置，并将目标寄存器（<code>Rd</code>）设置为 1，表示存储成功；否则，将目标寄存器设置为 0，表示存储失败。</p><p>可以看出，<code>STLXR</code> 指令实现了一种快速锁定和释放内存地址的机制，使得在多核场景中，多个 CPU 可以同时读取和修改共享内存的数据，而不会出现资源竞争的情况。</p><h2 id="位操作" tabindex="-1"><a class="header-anchor" href="#位操作"><span>位操作</span></a></h2><h3 id="ubfx" tabindex="-1"><a class="header-anchor" href="#ubfx"><span>ubfx</span></a></h3><p>举例说明：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">ubfx	x10, x3, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">, #</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">29</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>含义为从 <code>x3</code> 寄存器的第 3 位开始，提取 29 位到 <code>x10</code> 寄存器中。剩余高位用 0 填充，即 无符号位域提取指令。</p><p>UBFX 指令一般有两种用法：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">UBFX Wd, Wn, #lsb, #width </span><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">; 32-bit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">UBFX Xd, Xn, #lsb, #width </span><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">; 64-bit</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="and" tabindex="-1"><a class="header-anchor" href="#and"><span>and</span></a></h3><p><code>AND</code> 为按位与操作。</p><p>我们结合一个 AND 指令的指令编码来分析一下 AND 指令中的细节。</p><p>指令如下：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">d2ffffe9 	</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">mov</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">	x9, #-</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">281474976710656</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>二进制编码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span>1011 0010 0100 1111 1111 1011 1110 1001</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>结合 arm v8 手册，我们 <strong>@todo</strong>，以后研究该命令。</p><h3 id="lsl" tabindex="-1"><a class="header-anchor" href="#lsl"><span>lsl</span></a></h3><p><code>lsl</code> 为逻辑左移指令。</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">lsl</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">	w9, w11, w9</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>左移指令分两种，可以给定寄存器或者立即数进行移位：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">LSL</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> &lt;Wd&gt;, &lt;Wn&gt;, #&lt;shift&gt; </span><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">; 32-bit</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">LSL</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt; </span><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">; 64-bit</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>or</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">LSL</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt; </span><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">; 32-bit</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">LSL</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt; </span><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">; 64-bit</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="lsr" tabindex="-1"><a class="header-anchor" href="#lsr"><span>lsr</span></a></h3><p><code>lsr</code> 为右移指令，用法和 <code>lsl</code> 相似。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>https://juejin.cn/post/6978137866152968222 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>https://azeria-labs.com/memory-instructions-load-and-store-part-4/ <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p><a href="http://t.zoukankan.com/amanlikethis-p-3444411.html" target="_blank" rel="noopener noreferrer">ARM的STRB和LDRB指令分析</a> <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>https://blog.csdn.net/u011037593/article/details/121877496 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li></ol></section>`,119)]))}const p=s(t,[["render",l]]),k=JSON.parse('{"path":"/architecture/arm/arm_ins.html","title":"ISA: ARM Instructions Set","lang":"zh-CN","frontmatter":{"title":"ISA: ARM Instructions Set","date":"2022-10-10T00:00:00.000Z","author":"weigao","category":["Arm"],"description":"Abstract 本文章作为一个 ARM 指令的速查表使用。 上面就是 ARM 汇编指令的一个通用的格式说明，下面对每一个字段进行具体的说明： MNEMONIC: 指令的助记符，如 ADD S: 可选的扩展位，如果指令后带了这个，将根据计算结果更新 CPSR 寄存器中相应的 FLAG condition: 执行条件，如果没有指定，则默认位 AL（无条件...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ISA: ARM Instructions Set\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-10-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-08T02:58:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"weigao\\"}]}"],["meta",{"property":"og:url","content":"https://vueblog.weigao.cc/architecture/arm/arm_ins.html"}],["meta",{"property":"og:site_name","content":"weigao"}],["meta",{"property":"og:title","content":"ISA: ARM Instructions Set"}],["meta",{"property":"og:description","content":"Abstract 本文章作为一个 ARM 指令的速查表使用。 上面就是 ARM 汇编指令的一个通用的格式说明，下面对每一个字段进行具体的说明： MNEMONIC: 指令的助记符，如 ADD S: 可选的扩展位，如果指令后带了这个，将根据计算结果更新 CPSR 寄存器中相应的 FLAG condition: 执行条件，如果没有指定，则默认位 AL（无条件..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-08T02:58:09.000Z"}],["meta",{"property":"article:author","content":"weigao"}],["meta",{"property":"article:published_time","content":"2022-10-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-08T02:58:09.000Z"}]]},"git":{"createdTime":1660112250000,"updatedTime":1738983489000,"contributors":[{"name":"weigao chen","username":"","email":"weigao_1995@yeah.net","commits":4},{"name":"chenweigao","username":"chenweigao","email":"297859260@qq.com","commits":3,"url":"https://github.com/chenweigao"},{"name":"weigao","username":"weigao","email":"weigao.cwg","commits":1,"url":"https://github.com/weigao"}]},"readingTime":{"minutes":9.65,"words":2894},"filePathRelative":"architecture/arm/arm_ins.md","excerpt":"<h2>Abstract</h2>\\n<p>本文章作为一个 ARM 指令的速查表使用。</p>\\n<div class=\\"language-asm line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"asm\\" style=\\"--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff\\"><pre class=\\"shiki shiki-themes github-light nord vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#24292E;--shiki-dark:#D8DEE9FF\\">MNEMONIC{S}{condition} {Rd}, Operand1, Operand2</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{p as comp,k as data};
