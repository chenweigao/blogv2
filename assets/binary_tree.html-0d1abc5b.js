const e=JSON.parse('{"key":"v-64751ed4","path":"/algorithm/binary_tree.html","title":"Binary Tree","lang":"zh-CN","frontmatter":{"title":"Binary Tree","date":"2022-04-27T00:00:00.000Z","category":["Algorithm"],"tag":["binary tree"],"description":"本文主要研究了： 二叉树的三种遍历方式：递归和迭代实现 二叉树相关的例题解析 二叉树的前序遍历 递归法 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: def preorder(node): if not node: return res.append(node.val) preorder(node.left) preorder(node.right) res = list() preorder(root) return res","head":[["meta",{"property":"og:url","content":"https://vueblog.weigao.cc/algorithm/binary_tree.html"}],["meta",{"property":"og:site_name","content":"WW"}],["meta",{"property":"og:title","content":"Binary Tree"}],["meta",{"property":"og:description","content":"本文主要研究了： 二叉树的三种遍历方式：递归和迭代实现 二叉树相关的例题解析 二叉树的前序遍历 递归法 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: def preorder(node): if not node: return res.append(node.val) preorder(node.left) preorder(node.right) res = list() preorder(root) return res"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Someone"}],["meta",{"property":"article:tag","content":"binary tree"}],["meta",{"property":"article:published_time","content":"2022-04-27T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Binary Tree\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-27T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Someone\\",\\"url\\":\\"https://www.weigao.cc\\"}]}"]]},"headers":[{"level":2,"title":"二叉树的前序遍历","slug":"二叉树的前序遍历","link":"#二叉树的前序遍历","children":[{"level":3,"title":"递归法","slug":"递归法","link":"#递归法","children":[]},{"level":3,"title":"迭代法","slug":"迭代法","link":"#迭代法","children":[]}]},{"level":2,"title":"二叉树的中序遍历","slug":"二叉树的中序遍历","link":"#二叉树的中序遍历","children":[{"level":3,"title":"递归法","slug":"递归法-1","link":"#递归法-1","children":[]},{"level":3,"title":"迭代法","slug":"迭代法-1","link":"#迭代法-1","children":[]}]},{"level":2,"title":"二叉树的层次遍历","slug":"二叉树的层次遍历","link":"#二叉树的层次遍历","children":[]},{"level":2,"title":"例题","slug":"例题","link":"#例题","children":[{"level":3,"title":"LC606 根据二叉树创建字符串（前序遍历）","slug":"lc606-根据二叉树创建字符串-前序遍历","link":"#lc606-根据二叉树创建字符串-前序遍历","children":[]},{"level":3,"title":"LC101 对称二叉树","slug":"lc101-对称二叉树","link":"#lc101-对称二叉树","children":[]},{"level":3,"title":"LC111 二叉树的最小深度","slug":"lc111-二叉树的最小深度","link":"#lc111-二叉树的最小深度","children":[]},{"level":3,"title":"LC104 二叉树的最大深度","slug":"lc104-二叉树的最大深度","link":"#lc104-二叉树的最大深度","children":[]},{"level":3,"title":"LC102 二叉树的层序遍历","slug":"lc102-二叉树的层序遍历","link":"#lc102-二叉树的层序遍历","children":[]},{"level":3,"title":"LC107 二叉树的层序遍历II","slug":"lc107-二叉树的层序遍历ii","link":"#lc107-二叉树的层序遍历ii","children":[]},{"level":3,"title":"LC103 二叉树的锯齿形层序遍历","slug":"lc103-二叉树的锯齿形层序遍历","link":"#lc103-二叉树的锯齿形层序遍历","children":[]},{"level":3,"title":"LC543 二叉树的直径","slug":"lc543-二叉树的直径","link":"#lc543-二叉树的直径","children":[]},{"level":3,"title":"面试题 04.06. 后继者","slug":"面试题-04-06-后继者","link":"#面试题-04-06-后继者","children":[]}]}],"git":{},"readingTime":{"minutes":12.4,"words":3719},"filePathRelative":"algorithm/binary_tree.md","localizedDate":"2022年4月27日","excerpt":"<p>本文主要研究了：</p>\\n<ul>\\n<li>二叉树的三种遍历方式：递归和迭代实现</li>\\n<li>二叉树相关的例题解析</li>\\n</ul>\\n<!-- more-->\\n<h2> 二叉树的前序遍历</h2>\\n<h3> 递归法</h3>\\n<div class=\\"language-python line-numbers-mode\\" data-ext=\\"py\\"><pre class=\\"language-python\\"><code><span class=\\"token comment\\"># Definition for a binary tree node.</span>\\n<span class=\\"token comment\\"># class TreeNode:</span>\\n<span class=\\"token comment\\">#     def __init__(self, val=0, left=None, right=None):</span>\\n<span class=\\"token comment\\">#         self.val = val</span>\\n<span class=\\"token comment\\">#         self.left = left</span>\\n<span class=\\"token comment\\">#         self.right = right</span>\\n<span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">Solution</span><span class=\\"token punctuation\\">:</span>\\n    <span class=\\"token keyword\\">def</span> <span class=\\"token function\\">preorderTraversal</span><span class=\\"token punctuation\\">(</span>self<span class=\\"token punctuation\\">,</span> root<span class=\\"token punctuation\\">:</span> Optional<span class=\\"token punctuation\\">[</span>TreeNode<span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">-</span><span class=\\"token operator\\">&gt;</span> List<span class=\\"token punctuation\\">[</span><span class=\\"token builtin\\">int</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">:</span>\\n        <span class=\\"token keyword\\">def</span> <span class=\\"token function\\">preorder</span><span class=\\"token punctuation\\">(</span>node<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">:</span>\\n            <span class=\\"token keyword\\">if</span> <span class=\\"token keyword\\">not</span> node<span class=\\"token punctuation\\">:</span>\\n                <span class=\\"token keyword\\">return</span>\\n            res<span class=\\"token punctuation\\">.</span>append<span class=\\"token punctuation\\">(</span>node<span class=\\"token punctuation\\">.</span>val<span class=\\"token punctuation\\">)</span>\\n            preorder<span class=\\"token punctuation\\">(</span>node<span class=\\"token punctuation\\">.</span>left<span class=\\"token punctuation\\">)</span>\\n            preorder<span class=\\"token punctuation\\">(</span>node<span class=\\"token punctuation\\">.</span>right<span class=\\"token punctuation\\">)</span>\\n\\n        res <span class=\\"token operator\\">=</span> <span class=\\"token builtin\\">list</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n        preorder<span class=\\"token punctuation\\">(</span>root<span class=\\"token punctuation\\">)</span>\\n        <span class=\\"token keyword\\">return</span> res\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
