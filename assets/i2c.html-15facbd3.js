import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as l,c,a as e,d as t,w as s,b as o,f as d}from"./app-22cda79c.js";const h={},p=e("h1",{id:"i2c-i3c",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#i2c-i3c","aria-hidden":"true"},"#"),o(" I2C, I3C")],-1),u={class:"table-of-contents"},f=d('<h2 id="abstract" tabindex="-1"><a class="header-anchor" href="#abstract" aria-hidden="true">#</a> Abstract</h2><p>这个文档主要用于收集嵌入式和芯片中公开的、基础的知识，用于扫盲。</p><p>如果某个知识点需要更加深入的了解的话，则单独新增新的博客。</p><h2 id="i2c-and-i3c" tabindex="-1"><a class="header-anchor" href="#i2c-and-i3c" aria-hidden="true">#</a> I2C and I3C</h2><h3 id="i2c" tabindex="-1"><a class="header-anchor" href="#i2c" aria-hidden="true">#</a> I2C</h3><blockquote><p>I2C (Inter-Integrated Circuit) is an on-board communication protocol that is ideal for short distances and low bandwidth.<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></p></blockquote><p>Inter-Integrated Circuit 直译为内部集成电路。</p><p>这句话说了 I2C 是一个理想的短距离、低带宽的通信协议。</p><blockquote><p>It has a master-slave architecture in which all slaves are connected to the master via two lines: the serial data line (SDA) and the serial clock line (SCL).</p></blockquote><p>架构是 master-slave 架构，所有的 slave 通过串行的 data line 和串行的 clock line 连接到 master, 简而言之，就是一个 master 多个 slave.</p><blockquote><p>I2C is typically used to connect lower speed peripherals, such as sensors to processors and microcontrollers over short distances, within an integrated circuit.</p></blockquote><p>peripherals /pə&#39;rifərəls/ 外设。</p><p>这句话说的是 I2C 一般用来连接低速外设，比如说传感器。I2C --&gt; Sensor.</p><hr><blockquote><p>The I2C protocol defines how data is sent.</p></blockquote><p>I2C 协议定义了数据如何发送。（通常协议会做的事情）</p><blockquote><p>Initially, the master issues a start condition followed by the address of the slave device with which it is communicating. Once the appropriate slave has identified its address, it searches for the progressive read / write flag issued by the master. This flag tells the slave if it can receive data or send data. As soon as the slave has confirmed the master, communication continues.</p></blockquote><p>上面这段过程比较长，总的而言就是 master 和 slave device 之前发生的一些事情。</p><h3 id="i3c" tabindex="-1"><a class="header-anchor" href="#i3c" aria-hidden="true">#</a> I3C</h3><p>I3C<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>: <em>Improved Inter Integrated Circuit</em>.</p><blockquote><p>I3C is also known as MIPI I3C and SenseWire. I3C is the new industry standard for serial multidrop data buses.</p></blockquote><p>MIPI<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup> 是一个联盟，Mobile Industry Processor Interface, 旨在推进手机应用处理器接口的标准化，I3C 就是其新的一个行业标准。</p><blockquote><p>I3C adds a considerable number of system interface functions while maintaining upward compatibility with existing I²C slave devices, while native I3C devices support higher data rates similar to SPI (Serial Peripheral Interface).</p></blockquote><p>I3C 增加了大量的系统接口，并保持了向后兼容。</p><p>原生的 I3C 设备支持更高数据速率，类似于 SPI(串行外设接口).</p><blockquote><p>With I3C, one or more master devices can be connected to one or more slaves via the bus.</p></blockquote><p>🟢 I3C 支持多个 master devices 连接到多个 slaves.</p><blockquote><p>I3C the evolution of I²C.</p></blockquote><p>I3C 是 I2C 的演化。</p><blockquote><p>I3C was originally intended as the only interface for all digitally connected sensors used in a mobile application.</p></blockquote><blockquote><p>The bus is also suitable for all medium and high speed embedded applications, including sensors, power controllers, actuators, MCUs and FPGAs.</p></blockquote><p>I3C 的应用范围。</p><blockquote><p>I3C builds on and enhances the features and benefits of I2C, while maintaining backward compatibility.</p></blockquote><p>增强了 I2C 并保持了向后兼容性。</p><blockquote><p>The interface is useful for many applications because it provides high-speed data transmission at very low power levels while allowing multi-drop between the host processor and the peripherals, which is highly desirable for any embedded system.</p></blockquote><p>对于嵌入式系统来说，I3C 非常优秀，以非常低的功耗提供了高速的数据传输速率，同时允许主机处理器和外设之间的多点传输。</p><h3 id="i2c-vs-i3c" tabindex="-1"><a class="header-anchor" href="#i2c-vs-i3c" aria-hidden="true">#</a> I2C vs I3C</h3><ul><li>Energy-saving and space-saving design for mobile devices (smartphones and IoT devices).</li><li>Two-pole interface, which is a superset of the I2C standard. Older I2C slave devices can be connected to the newer bus.</li><li>In-band interrupts over the serial bus instead of requiring separate pins.</li><li>Standard Data Rate (SDR) throughput of up to 12.5 Mbps when using CMOS I / O levels</li><li>HDR (High Data Rate) modes provide SPI-comparable throughput, but only require a fraction of the I2C fast-mode performance.</li><li>A standardized set of common command codes</li><li>Support for command queues</li><li>Error detection and recovery (parity check in SDR mode and 5-bit CRC for HDR modes)</li><li><strong>Dynamic Address Assignment</strong> (DAA) for I3C slaves, but still supports static addresses for older I2C devices</li><li>Hot-Join (some devices on the bus can be turned on and off during operation)</li><li><strong>Multi-master</strong> operation with clearly defined transfer</li><li>Four different device classes can be supported on an I3C bus in standard mode (SDR)</li></ul><h3 id="i2c-problem" tabindex="-1"><a class="header-anchor" href="#i2c-problem" aria-hidden="true">#</a> I2C Problem</h3><p>✅✅✅ Q: I2C 总线可以挂多个 Sensor, 但是我们的 SoC 中设置了很多 I2C Controller, 为什么要这么做呢？</p><ol><li>虽然一个 I2C 总线可以挂多个 Sensor, 但是总线可以传输的总的数据是固定的</li><li>不同的 I2C Controller 是挂在不同的处理器上面的，如 ACPU 有一个 I2C Controller, MCPU 也有一个 I2C Controller, 那么我们设置多个 I2C Controller 可以避免不同的 CPU 子系统对一个 controller 进行复用，简化软件控制</li></ol><p>✅✅✅ Q: SensorHub 和 I2C 对 Sensor 而言有什么区别？</p><p>I2C Controller 有些属于 CPU 控制，有些属于 SensorHub 控制；这也是为什么说 I2C 控制 Sensor 但是有一个 SensorHub，其关系应该是这样的：SensorHub --&gt; I2C Controller(驱动软件) --&gt; I2C 总线 --&gt; Sensor.</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><hr class="footnotes-sep">',45),I={class:"footnotes"},b={class:"footnotes-list"},C={id:"footnote1",class:"footnote-item"},m={href:"https://evision-webshop.de/I2C-vs-I3C-Protocol-Analyzers-Differences-and-Similarities",target:"_blank",rel:"noopener noreferrer"},_=e("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1),v={id:"footnote2",class:"footnote-item"},k={href:"https://en.wikipedia.org/wiki/I3C_(bus)#I%C2%B2C_features_not_supported_in_I3C",target:"_blank",rel:"noopener noreferrer"},g=e("a",{href:"#footnote-ref2",class:"footnote-backref"},"↩︎",-1),w={id:"footnote3",class:"footnote-item"},q={href:"https://en.wikipedia.org/wiki/MIPI_Alliance",target:"_blank",rel:"noopener noreferrer"},S=e("a",{href:"#footnote-ref3",class:"footnote-backref"},"↩︎",-1);function y(P,x){const a=r("router-link"),i=r("ExternalLinkIcon");return l(),c("div",null,[p,e("nav",u,[e("ul",null,[e("li",null,[t(a,{to:"#abstract"},{default:s(()=>[o("Abstract")]),_:1})]),e("li",null,[t(a,{to:"#i2c-and-i3c"},{default:s(()=>[o("I2C and I3C")]),_:1}),e("ul",null,[e("li",null,[t(a,{to:"#i2c"},{default:s(()=>[o("I2C")]),_:1})]),e("li",null,[t(a,{to:"#i3c"},{default:s(()=>[o("I3C")]),_:1})]),e("li",null,[t(a,{to:"#i2c-vs-i3c"},{default:s(()=>[o("I2C vs I3C")]),_:1})]),e("li",null,[t(a,{to:"#i2c-problem"},{default:s(()=>[o("I2C Problem")]),_:1})])])]),e("li",null,[t(a,{to:"#reference"},{default:s(()=>[o("Reference")]),_:1})])])]),f,e("section",I,[e("ol",b,[e("li",C,[e("p",null,[e("a",m,[o("https://evision-webshop.de/I2C-vs-I3C-Protocol-Analyzers-Differences-and-Similarities"),t(i)]),o(),_])]),e("li",v,[e("p",null,[e("a",k,[o("I3C Bus Wiki"),t(i)]),o(),g])]),e("li",w,[e("p",null,[e("a",q,[o("MIPI Alliance"),t(i)]),o(),S])])])])])}const M=n(h,[["render",y],["__file","i2c.html.vue"]]);export{M as default};
