import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c as l,d as a,a as n,b as s,f as c}from"./app-22cda79c.js";const r={},d=c(`<h1 id="init-h-in-thermal" tabindex="-1"><a class="header-anchor" href="#init-h-in-thermal" aria-hidden="true">#</a> init.h in Thermal</h1><h2 id="abstract" tabindex="-1"><a class="header-anchor" href="#abstract" aria-hidden="true">#</a> Abstract</h2><p>本文分析 Linux 源码 <code>init.h</code> 文件，并研究其中涉及到的内核初始化过程、Thermal 模块如何调用等问题。</p><h2 id="initcall" tabindex="-1"><a class="header-anchor" href="#initcall" aria-hidden="true">#</a> initcall</h2><h3 id="initcall-n-init" tabindex="-1"><a class="header-anchor" href="#initcall-n-init" aria-hidden="true">#</a> initcall{n}.init</h3><p>内核初始化过程中的调用顺序<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>：所有的 <code>__init</code> 函数在区段 <code>.initcall.init</code> 中还保存了一份函数指针，在初始化时内核会通过这些函数指针调用这些 <code>__init</code> 函数指针，并在整个初始化完成后，释放整个 <code>init</code> 区段，包括 <code>.init.text</code>，<code>.initcall.init</code> 等。</p><p>这些函数在内核初始化过程中的调用顺序只和这里的函数指针的顺序有关，和函数本身在 <code>.init.text</code> 的区段无关。在 2.4 内核中，这些函数指针的顺序也是和链接的顺序有关的，是不确定的。在 2.6 内核中，<code>initcall.init</code> 区段又分成7个子区段，分别是:</p><div class="language-markdown" data-ext="md"><pre class="language-markdown"><code>.initcall1.init  
.initcall2.init  
.initcall3.init  
.initcall4.init  
.initcall5.init  
.initcall6.init  
.initcall7.init
</code></pre></div><p>各个区段定义的方法分别是：</p><div class="language-markdown" data-ext="md"><pre class="language-markdown"><code>core_initcall(fn) ---&gt;.initcall1.init  
postcore_initcall(fn) ---&gt;.initcall2.init  
arch_initcall(fn) ---&gt;.initcall3.init  
subsys_initcall(fn) ---&gt;.initcall4.init  
fs_initcall(fn) ---&gt;.initcall5.init  
device_initcall(fn) ---&gt;.initcall6.init  
late_initcall(fn) ---&gt;.initcall7.init
</code></pre></div><p>在新的 5.17.4 内核中，各个区段的定义方法有所改变：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">pure_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">core_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">core_initcall_sync</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">1</span>s<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">postcore_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">postcore_initcall_sync</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>	<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2</span>s<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">arch_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">arch_initcall_sync</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">3</span>s<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">subsys_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">subsys_initcall_sync</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>	<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">4</span>s<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">fs_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>			<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">fs_initcall_sync</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">5</span>s<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">rootfs_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> rootfs<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">device_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">device_initcall_sync</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>	<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">6</span>s<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">late_initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">late_initcall_sync</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>		<span class="token function">__define_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">7</span>s<span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不难看出，是多了一些同步的调用方法，其优先级是没有变化的。</p><p>当我们需要把函数 <code>fn()</code> 放到 <code>.initcall1.init</code> 区段的时候，只需要声明：<code>core_initcall(fn)</code> 即可。</p><p>而与 2.4 兼容的 <code>initcall(fn)</code> 则等价于 <code>device_initcall(fn)</code>, 这个在内核中是如此兼容的：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__initcall</span><span class="token expression"><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token function">device_initcall</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span></span></span>
</code></pre></div><p>各个子区段之间的顺序是确定的，即先调用 <code>.initcall1.init</code> 中的函数指针，在调用 <code>.initcall2.init</code> 中的函数指针，等。而在每个子区段中的函数指针的顺序是和链接的顺序相关的，是不确定的。</p><p>在内核中，不同的 <code>init</code> 函数被放在不同的子区段中，因此也就决定了它们的调用顺序。这样做可以解决一些 <code>init</code> 函数之间必须保证一定的调用顺序的问题。</p><blockquote><p>A &quot;pure&quot; initcall has no dependencies on anything else, and purely initializes variables that couldn&#39;t be statically initialized.</p></blockquote><h2 id="thermal-postcore-initcall" tabindex="-1"><a class="header-anchor" href="#thermal-postcore-initcall" aria-hidden="true">#</a> Thermal postcore_initcall()</h2><p>在 <code>thermal_core.c</code> 对 thermal 进行初始化，我们这么调用：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token function">postcore_initcall</span><span class="token punctuation">(</span>thermal_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>也就是说，我们江 thermal_init 的步骤放在了 <code>.initcall2.init</code> 的子区段中，其 init 优先级仅次于 pure_init 和 core_init, 其中 pure_init 是不依赖于其他任何初始化函数的最先运行的。</p><h2 id="section" tabindex="-1"><a class="header-anchor" href="#section" aria-hidden="true">#</a> __section</h2><p>对于各个区段 section 的定义是这样的：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token comment">/* These are for everybody (although not all archs will actually
   discard it in modules) */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__init</span>		<span class="token expression"><span class="token function">__section</span><span class="token punctuation">(</span></span><span class="token string">&quot;.init.text&quot;</span><span class="token expression"><span class="token punctuation">)</span> __cold  </span><span class="token punctuation">\\</span>
            <span class="token expression">__latent_entropy __noinitretpoline __nocfi</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__initdata</span>	<span class="token expression"><span class="token function">__section</span><span class="token punctuation">(</span></span><span class="token string">&quot;.init.data&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__initconst</span>	<span class="token expression"><span class="token function">__section</span><span class="token punctuation">(</span></span><span class="token string">&quot;.init.rodata&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__exitdata</span>	<span class="token expression"><span class="token function">__section</span><span class="token punctuation">(</span></span><span class="token string">&quot;.exit.data&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__exit_call</span>	<span class="token expression">__used <span class="token function">__section</span><span class="token punctuation">(</span></span><span class="token string">&quot;.exitcall.exit&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>
</code></pre></div><p>各个区段的示意图如下：</p>`,27),u=c(`<p>上述应该在一个 Section 中，为了方便，将这两个分开画了。</p><p>理解上述代码需要参考《Linux 内核初始化定义》<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup> 这篇文章。</p><ul><li><p>第 3-4 行代码</p><p><code>#define __init __section(&quot;.init.text&quot;) __cold __latent_entropy __noinitretpoline __nocfi</code></p><p><code>__init</code> 用于标记函数，这个放在 <code>.init.text</code> section, 标记为初始化的函数，仅仅只是能在初始化的期间使用，在模块装载后，会将初始化函数扔掉。这样做可以将初始化函数占用的内存释放出来。</p><p><code>__cold</code> 是告诉编译器这个函数很可能不被执行到。</p></li><li><p>notrace</p><p><code>#define notrace __attribute__((no_instrument_function))</code> 说明 <code>notrace</code> 的定义，其作用是在程序中加入 hook, 让它在每次进入和退出函数的时候分别调用这个函数。</p></li><li><p>__initdata</p><p><code>#define __initdata __section(&quot;.init.data&quot;)</code></p></li></ul><p>​ <code>__initdata</code> 用于标记数据。</p><ul><li><p>第 8 行代码 __exit_call</p><p><code>#define __exit_call __used __section(&quot;.exitcall.exit&quot;)</code></p><p>在模块卸载的时候使用，如果模块直接被编进内核就不会被调用；如果内核编译的时候没有包含该模块。则此标记的函数将被简单的丢弃。</p></li></ul><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__ref</span>            <span class="token expression"><span class="token function">__section</span><span class="token punctuation">(</span></span><span class="token string">&quot;.ref.text&quot;</span><span class="token expression"><span class="token punctuation">)</span> noinline</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__refdata</span>        <span class="token expression"><span class="token function">__section</span><span class="token punctuation">(</span></span><span class="token string">&quot;.ref.data&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__refconst</span>       <span class="token expression"><span class="token function">__section</span><span class="token punctuation">(</span></span><span class="token string">&quot;.ref.rodata&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>
</code></pre></div><ul><li><code>noinline</code>: 阻止该函数被内联。</li></ul><p>还有很多类似的定义 <code>__section</code> 的地方，就不一一列举了。</p><p>对于 <code>__section</code> 的定义，在 <code>compiler_attributes.h</code> 中可以找到：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__section</span><span class="token expression"><span class="token punctuation">(</span>section<span class="token punctuation">)</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__section__</span><span class="token punctuation">(</span>section<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre></div><p>我们不难看出，其本质就是一个 <code>__attribute__</code>.</p><h3 id="attribute" tabindex="-1"><a class="header-anchor" href="#attribute" aria-hidden="true">#</a> <code>__attribute__</code></h3><p>可以设置函数属性(Function Attribute), 变量属性(Variable Attribute), 类型属性(Type Attribute)<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>.</p><p>GNU CC 需要使用 <code>–Wall</code> 编译器来击活 <code>__attribute__</code> 功能。</p><p>具体后续再进行研究。</p><h2 id="linux-内核初始化" tabindex="-1"><a class="header-anchor" href="#linux-内核初始化" aria-hidden="true">#</a> Linux 内核初始化</h2><h3 id="start-kernel" tabindex="-1"><a class="header-anchor" href="#start-kernel" aria-hidden="true">#</a> start_kernel</h3><p>内核初始化的 C 语言入口<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>是 <code>start_kernel</code>, 该函数首先初始化基础设施，即初始化内核的各个子系统，然后调用函数 <code>rest_init</code>, 该函数的执行流程如下：</p><ol><li>创建 1 号线程，即 init 线程，线程函数是 <code>kernel_init</code></li><li>创建 2 号线程，即 kthread 线程，负责创建内核线程</li><li>0 号线程最终变成空闲线程</li></ol><h3 id="init-线程" tabindex="-1"><a class="header-anchor" href="#init-线程" aria-hidden="true">#</a> init 线程</h3><p>init 线程继续初始化，执行的主要操作如下：</p><ol><li><code>smp_prepare_cpus()</code> 在启动从处理器以前执行准备工作</li><li><code>do_pre_smp_initcalls()</code>: 执行必须在初始化 SMP 系统以前执行的早期初始化，即使用宏 <code>early_initcall</code> 注册的初始化函数</li><li><code>smp_init()</code>: 初始化 SMP 系统（对称多处理器系统），启动所有从处理器</li><li><code>do_initcalls()</code>: 执行级别 0~7 的初始化</li><li>... 暂略</li></ol><p>分析：</p><ol><li>我们可以看到，<code>do_initcalls()</code> 这一步骤执行了级别 0~7 的初始化，所以说我们 thermal 模块的初始化就是在这个阶段完成的。</li><li>从上文看到，在初始化 thermal 的时候，从处理器已经完成启动了。这句话的深层含义是说，系统启动时拔核等操作是在更底层完成的，要和加载区分进行区分，不要混淆。</li></ol><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><hr class="footnotes-sep">`,26),k={class:"footnotes"},_={class:"footnotes-list"},f={id:"footnote1",class:"footnote-item"},h={href:"https://e-mailky.github.io/2016-10-14-linux_kernel_init_seq",target:"_blank",rel:"noopener noreferrer"},m=n("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1),v={id:"footnote2",class:"footnote-item"},x={href:"https://blog.csdn.net/beatbean/article/details/8448623",target:"_blank",rel:"noopener noreferrer"},b=n("a",{href:"#footnote-ref2",class:"footnote-backref"},"↩︎",-1),y={id:"footnote3",class:"footnote-item"},g={href:"https://sites.google.com/site/emmoblin/gcc-tech/gun-attribute",target:"_blank",rel:"noopener noreferrer"},w=n("strong",null,"attribute",-1),q=n("a",{href:"#footnote-ref3",class:"footnote-backref"},"↩︎",-1),L=n("li",{id:"footnote4",class:"footnote-item"},[n("p",null,[s("《Linux 内核深度解析》 "),n("a",{href:"#footnote-ref4",class:"footnote-backref"},"↩︎")])],-1);function C(A,T){const t=o("Mermaid"),e=o("ExternalLinkIcon");return i(),l("div",null,[d,a(t,{id:"mermaid-71",code:"eJxLy8kvT85ILCpR8AniUgCC4tKk9KLEggyF4tTkksz8PLBgomF0tF5JakVJbCyEbwTkF+WnJJYkwkSMgSLIfBMgP6m4GMpNzUvhAgD4nx9f"}),a(t,{id:"mermaid-72",code:"eJxLy8kvT85ILCpR8AniUgCC4tKk9KLEggyF4tTkksz8PCOwaKJpdLRecWVuSWJSbCxExAwoUpSao1eSWlECEzOHiqUkliTCxCyAYimpSaXpMAFLoEBOZl4qjG9oADK7JBVhdmpeChcAF+ctLg=="}),u,n("section",k,[n("ol",_,[n("li",f,[n("p",null,[n("a",h,[s("内核初始化过程中的调用顺序"),a(e)]),s(),m])]),n("li",v,[n("p",null,[n("a",x,[s("Linux 内核初始化定义"),a(e)]),s(),b])]),n("li",y,[n("p",null,[n("a",g,[s("GNU "),w,s(" 机制"),a(e)]),s(),q])]),L])])])}const J=p(r,[["render",C],["__file","init_h.html.vue"]]);export{J as default};
