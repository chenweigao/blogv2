import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o,c,a as e,d as s,w as n,b as a,f as t}from"./app-22cda79c.js";const p={},h=e("h2",{id:"abstract",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#abstract","aria-hidden":"true"},"#"),a(" Abstract")],-1),u={class:"table-of-contents"},k=t(`<p>Redis(Remote Dictionary Server) server 的启动：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>redis-server.exe redis.windows.conf
</code></pre></div><p>安装 redis-py:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>pip <span class="token function">install</span> redis
</code></pre></div>`,4),_={href:"https://redis-py.readthedocs.io/en/latest/",target:"_blank",rel:"noopener noreferrer"},f=t(`<blockquote><p>redis 提供两个类 Redis 和 StrictRedis 用于实现 Redis 的命令，StrictRedis 用于实现大部分官方的命令，并使用官方的语法和命令，Redis 是 StrictRedis 的子类，用于向后兼容旧版本的 redis-py。</p></blockquote><p>可以使用 Redis 可视化工具 <strong>RDM(redis deaktop manager)</strong></p><h2 id="redis-简述" tabindex="-1"><a class="header-anchor" href="#redis-简述" aria-hidden="true">#</a> Redis 简述</h2><p>什么是 Redis？有什么优缺点？</p><ul><li>Redis本质上是一个 key-value 类型的内存数据库，整个数据库都在内存中加载，通过异步操作可以持久化到磁盘中</li><li>Redis的性能十分出色，是已知的性能最快的 key-value DB(每秒大概处理10W次IO操作)</li><li>Redis 拥有丰富的数据结构（5 种，分别是 string, list, hash, set, zset）</li><li>Redis 丰富的数据结构给了它很多的应用，如 celery 就可以维护一个高性能的消息队列(list)</li><li>不同于 memcached, redis 的单个 value 可以保存的最大数据限制是 1GB(memcached 是 1M)</li><li>缺点在于 redis 的数据存储受到物理内存的限制，不能做海量的数据场景</li></ul><h2 id="redis-原理" tabindex="-1"><a class="header-anchor" href="#redis-原理" aria-hidden="true">#</a> Redis 原理</h2><h2 id="数据淘汰策略" tabindex="-1"><a class="header-anchor" href="#数据淘汰策略" aria-hidden="true">#</a> 数据淘汰策略</h2><p>当达到内存最大限制的时候，Redis 会采用一些策略(maxmemory-policy配置), 来进行数据淘汰：</p><ol><li>noeviction：默认策略，不淘汰，达到最大的内存限制的时候，如果再请求更多的数据，直接报错</li><li>allkeys-lru：LRU 策略，删除最近最少使用的 key, 针对于所有的key</li><li>volatile-lru：设置的 expire 的key使用 LRU</li><li>allkeys-random：随机删除一部分key</li><li>volatile-random：对设置的 expire 的key随机删除</li><li>volatile-ttl：对设置 expire 的key使用，优先删除剩余时间短的key</li></ol><p>对于这六种数据淘汰策略的使用场景可以归纳为：</p><ol><li>如果分为热数据和冷数据的场景（所有key中有一部分经常被读写），使用 LRU 方法</li><li>如果是循环读所有的 key, 那么就使用 allkeys-random 策略</li></ol><h2 id="redis-生产适用场景" tabindex="-1"><a class="header-anchor" href="#redis-生产适用场景" aria-hidden="true">#</a> Redis 生产适用场景</h2><ol><li>session cache 会话缓存<br> 一般业界使用 memcached, 但是 redis 多了持久化功能，可以维护严格要求一致性的缓存</li><li>FPC 全页缓存</li><li>redis queues<br> 如 celery 队列可以使用 redis作为broker</li><li>排行榜、计数器<br> 使用了 redis 中的递增和递减操作</li><li>原子操作、事务操作<br> 事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行；<br> 事务在执行的过程中不会被其他客户端发送过来的命令打断；<br> 事务是一个原子操作，事务中的所有命令要么全部被执行，要么全部不执行。<br> 事务相关的命令：<code>MULTI, EXEC, DISCARD, WATCH</code></li></ol><h2 id="redis-优化" tabindex="-1"><a class="header-anchor" href="#redis-优化" aria-hidden="true">#</a> Redis 优化</h2><ol><li><p>设置key的过期时间<br> 使用<code>expire</code>命令，如果想要永久有效，那么就使用 <code>presist</code>.</p></li><li><p>使用散列表<br> 比如说有一个场景，需要存储用户的账户、密码等信息，尽量不给每一个字段去设置单独的key, 而是将他们一起存储于一张散列表里面。</p></li></ol><h2 id="redis-分布式锁" tabindex="-1"><a class="header-anchor" href="#redis-分布式锁" aria-hidden="true">#</a> Redis 分布式锁</h2><h3 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h3><p>分布式的流行使得原单机部署情况下的并发控制策略失效。</p><p>分布式锁大致分为三种：</p><ol><li>数据库乐观锁</li><li>基于 redis 的分布式锁</li><li>基于 ZooKeeper 的分布式锁</li></ol><p>分布式锁的实现条件：</p><ol><li>互斥性，任何时候只能有一个客户端持有锁</li><li>可靠性，尽量避免死锁</li><li>一致性，锁只能由加锁人解锁，不能产生A的加锁被B用户解锁的情况</li></ol><h2 id="redis-分布式集群" tabindex="-1"><a class="header-anchor" href="#redis-分布式集群" aria-hidden="true">#</a> Redis 分布式集群</h2><p>目前已知的可以通过 proxy 来实现</p><h3 id="redis-分布式锁-1" tabindex="-1"><a class="header-anchor" href="#redis-分布式锁-1" aria-hidden="true">#</a> Redis 分布式锁</h3><p>基本上实现如下，主要使用三个命令：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># SETNX</span>
SETNX key val
<span class="token comment"># EXPIRE</span>
expire key <span class="token function">timeout</span>
<span class="token comment"># DELETE</span>
delete key
</code></pre></div><p>redis 锁的实现思路基本上是：</p><ol><li>setnx加锁，并设置超时时间，这时候锁的 value 值就是一个随机生成的 UUID</li><li>获取锁和超时时间</li><li>释放锁的时候根据 UUID 判断，而后 DELETE 删除（注意这里要注意原子性）</li></ol><h3 id="redis-cluster-槽" tabindex="-1"><a class="header-anchor" href="#redis-cluster-槽" aria-hidden="true">#</a> Redis Cluster 槽</h3><h2 id="redis-py" tabindex="-1"><a class="header-anchor" href="#redis-py" aria-hidden="true">#</a> redis-py</h2><h3 id="strictredis" tabindex="-1"><a class="header-anchor" href="#strictredis" aria-hidden="true">#</a> StrictRedis()</h3><p>初始化 Redis:</p><div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> redis <span class="token keyword">import</span> StrictRedis

<span class="token keyword">def</span> <span class="token function">create_redis_client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    redis_client <span class="token operator">=</span> StrictRedis<span class="token punctuation">(</span>
            host<span class="token operator">=</span><span class="token string">&#39;localhost&#39;</span><span class="token punctuation">,</span>
            port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">,</span>
            password<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> redis_client
</code></pre></div><p>也可以使用 <code>Redis()</code> 类初始化，如果遇到了向后兼容的问题。</p><h3 id="append" tabindex="-1"><a class="header-anchor" href="#append" aria-hidden="true">#</a> append()</h3><div class="language-python" data-ext="py"><pre class="language-python"><code>redis_client<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
</code></pre></div><p>如果 key 不存在则创建。</p>`,38);function y(R,b){const i=l("router-link"),r=l("ExternalLinkIcon");return o(),c("div",null,[h,e("nav",u,[e("ul",null,[e("li",null,[s(i,{to:"#abstract"},{default:n(()=>[a("Abstract")]),_:1})]),e("li",null,[s(i,{to:"#redis-简述"},{default:n(()=>[a("Redis 简述")]),_:1})]),e("li",null,[s(i,{to:"#redis-原理"},{default:n(()=>[a("Redis 原理")]),_:1})]),e("li",null,[s(i,{to:"#数据淘汰策略"},{default:n(()=>[a("数据淘汰策略")]),_:1})]),e("li",null,[s(i,{to:"#redis-生产适用场景"},{default:n(()=>[a("Redis 生产适用场景")]),_:1})]),e("li",null,[s(i,{to:"#redis-优化"},{default:n(()=>[a("Redis 优化")]),_:1})]),e("li",null,[s(i,{to:"#redis-分布式锁"},{default:n(()=>[a("Redis 分布式锁")]),_:1}),e("ul",null,[e("li",null,[s(i,{to:"#分布式锁"},{default:n(()=>[a("分布式锁")]),_:1})])])]),e("li",null,[s(i,{to:"#redis-分布式集群"},{default:n(()=>[a("Redis 分布式集群")]),_:1}),e("ul",null,[e("li",null,[s(i,{to:"#redis-分布式锁-1"},{default:n(()=>[a("Redis 分布式锁")]),_:1})]),e("li",null,[s(i,{to:"#redis-cluster-槽"},{default:n(()=>[a("Redis Cluster 槽")]),_:1})])])]),e("li",null,[s(i,{to:"#redis-py"},{default:n(()=>[a("redis-py")]),_:1}),e("ul",null,[e("li",null,[s(i,{to:"#strictredis"},{default:n(()=>[a("StrictRedis()")]),_:1})]),e("li",null,[s(i,{to:"#append"},{default:n(()=>[a("append()")]),_:1})])])])])]),k,e("p",null,[e("a",_,[a("官方文档"),s(r)])]),f])}const v=d(p,[["render",y],["__file","redis.html.vue"]]);export{v as default};
