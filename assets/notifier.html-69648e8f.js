const e=JSON.parse('{"key":"v-7e64a095","path":"/linux/kernel/notifier.html","title":"Notifier","lang":"zh-CN","frontmatter":{"description":"Notifier Abstract 我们简单研究一下内核的 notify 机制。 大多数内核子系统都是相互独立的，但是某个子系统可能会对其他子系统产生的事件感兴趣。为了满足这个需求，让某个子系统在发生某个事件的时候通知其他的子系统，Linux kernel 提供了通知链的机制，通知链表只能够在内核的子系统之间使用，而不能够在内核与用户空间之间进行事件的通知。 提示 本文分析的代码主要集中于：notifier.c 和 notifier.h 中。","head":[["meta",{"property":"og:url","content":"https://vueblog.weigao.cc/linux/kernel/notifier.html"}],["meta",{"property":"og:site_name","content":"WW"}],["meta",{"property":"og:title","content":"Notifier"}],["meta",{"property":"og:description","content":"Notifier Abstract 我们简单研究一下内核的 notify 机制。 大多数内核子系统都是相互独立的，但是某个子系统可能会对其他子系统产生的事件感兴趣。为了满足这个需求，让某个子系统在发生某个事件的时候通知其他的子系统，Linux kernel 提供了通知链的机制，通知链表只能够在内核的子系统之间使用，而不能够在内核与用户空间之间进行事件的通知。 提示 本文分析的代码主要集中于：notifier.c 和 notifier.h 中。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Someone"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Notifier\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Someone\\",\\"url\\":\\"https://www.weigao.cc\\"}]}"]]},"headers":[{"level":2,"title":"Abstract","slug":"abstract","link":"#abstract","children":[]},{"level":2,"title":"Notifier Struct","slug":"notifier-struct","link":"#notifier-struct","children":[{"level":3,"title":"notifier_chain(notifier_head)","slug":"notifier-chain-notifier-head","link":"#notifier-chain-notifier-head","children":[]},{"level":3,"title":"atomic_notifier_head","slug":"atomic-notifier-head","link":"#atomic-notifier-head","children":[]},{"level":3,"title":"blocking_notifier_head","slug":"blocking-notifier-head","link":"#blocking-notifier-head","children":[]},{"level":3,"title":"raw_notifier_head","slug":"raw-notifier-head","link":"#raw-notifier-head","children":[]},{"level":3,"title":"srcu_notifier_head","slug":"srcu-notifier-head","link":"#srcu-notifier-head","children":[]},{"level":3,"title":"notifier_block","slug":"notifier-block","link":"#notifier-block","children":[]}]},{"level":2,"title":"APIs","slug":"apis","link":"#apis","children":[{"level":3,"title":"Abstract","slug":"abstract-1","link":"#abstract-1","children":[]},{"level":3,"title":"notifier_chain_register","slug":"notifier-chain-register","link":"#notifier-chain-register","children":[]},{"level":3,"title":"notifier_chain_unregister","slug":"notifier-chain-unregister","link":"#notifier-chain-unregister","children":[]},{"level":3,"title":"notifier_call_chain","slug":"notifier-call-chain","link":"#notifier-call-chain","children":[]}]},{"level":2,"title":"Usage","slug":"usage","link":"#usage","children":[{"level":3,"title":"Usage: init","slug":"usage-init","link":"#usage-init","children":[]},{"level":3,"title":"Usage: register, unregister and call","slug":"usage-register-unregister-and-call","link":"#usage-register-unregister-and-call","children":[]},{"level":3,"title":"Usage: example","slug":"usage-example","link":"#usage-example","children":[]}]},{"level":2,"title":"How notifier works","slug":"how-notifier-works","link":"#how-notifier-works","children":[]},{"level":2,"title":"Summary","slug":"summary","link":"#summary","children":[{"level":3,"title":"Something","slug":"something","link":"#something","children":[]}]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]}],"git":{},"readingTime":{"minutes":10.18,"words":3054},"filePathRelative":"linux/kernel/notifier.md","excerpt":"<h1> Notifier</h1>\\n<h2> Abstract</h2>\\n<p>我们简单研究一下内核的 notify 机制。</p>\\n<p>大多数内核子系统都是相互独立的，但是某个子系统可能会对其他子系统产生的事件感兴趣。为了满足这个需求，让某个子系统在发生某个事件的时候通知其他的子系统，Linux kernel 提供了<strong>通知链</strong>的机制，通知链表只能够在内核的子系统之间使用，而不能够在内核与用户空间之间进行事件的通知。</p>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>本文分析的代码主要集中于：<code>notifier.c</code> 和 <code>notifier.h</code> 中。</p>\\n</div>","autoDesc":true}');export{e as data};
