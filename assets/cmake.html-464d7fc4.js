import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o,c as p,a,b as n,d as e,f as l}from"./app-22cda79c.js";const i={},d=l(`<h1 id="cmake" tabindex="-1"><a class="header-anchor" href="#cmake" aria-hidden="true">#</a> CMake</h1><h2 id="abstract" tabindex="-1"><a class="header-anchor" href="#abstract" aria-hidden="true">#</a> Abstract</h2><p>搞 C 还是离不开这个啊，再怎么还是要研究一下的，本文参考以下比较好的文档：</p><ol><li>CMake Examples<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>, GitHub 上的 CMake 例子；</li><li>CMake Tutorial<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>, 官方文档</li></ol><h2 id="concepts" tabindex="-1"><a class="header-anchor" href="#concepts" aria-hidden="true">#</a> Concepts</h2><table><thead><tr><th>Concepts</th><th>Means</th><th></th></tr></thead><tbody><tr><td>CMakeLists.txt</td><td>这个文件是存储所有 CMake 命令的文件，注意这个文件的名称：<code>CMakeLists.txt</code> 严格区分大小写。</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="argument" tabindex="-1"><a class="header-anchor" href="#argument" aria-hidden="true">#</a> Argument</h2><h3 id="verbose" tabindex="-1"><a class="header-anchor" href="#verbose" aria-hidden="true">#</a> Verbose</h3><p>我们可以设置 make 时候 debug 信息，如下所示：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> clean
<span class="token function">make</span> <span class="token assign-left variable">VERBOSE</span><span class="token operator">=</span><span class="token number">1</span>
</code></pre></div><h3 id="destdir" tabindex="-1"><a class="header-anchor" href="#destdir" aria-hidden="true">#</a> DESTDIR</h3><p>这个可以用来设置 CMAKE_INSTALL_PREFIX 的位置：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code>make install DESTDIR=/tmp/stage
</code></pre></div><h2 id="env" tabindex="-1"><a class="header-anchor" href="#env" aria-hidden="true">#</a> ENV</h2><p>介绍几个环境变量<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>。</p><table><thead><tr><th>Variable</th><th>Means</th><th></th></tr></thead><tbody><tr><td>PROJECT_NAME</td><td>命令 <code>project (hello_cmake)</code> 执行后会创建一个 变量 <code>\${PROJECT_NAME}</code>, 其值为 <code>hello_cmake</code></td><td></td></tr><tr><td>CMAKE_BINARY_DIR</td><td>执行 cmake 命令的 root, 或者 top level 的文件夹，后续分析关联见 <code>Binary Directory</code>。<br>The root binary / build directory. This is the directory where you ran the cmake command.</td><td></td></tr><tr><td>CMAKE_SOURCE_DIR</td><td>The root source directory</td><td></td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>The current source directory if using sub-projects and directories.</td><td></td></tr><tr><td>CMAKE_CURRENT_BINARY_DIR</td><td>The build directory you are currently in.</td><td></td></tr><tr><td>PROJECT_BINARY_DIR</td><td>The build directory for the current project.</td><td></td></tr><tr><td>CMAKE_INSTALL_PREFIX</td><td><code>make install</code> 产生，默认值是 <code>/usr/local/</code></td><td></td></tr><tr><td>CMAKE_C_FLAGS</td><td>compile flags</td><td></td></tr><tr><td>CMAKE_CXX_FLAGS</td><td>compile flags</td><td></td></tr><tr><td>xxx_INCLUDE_DIRS</td><td>三方库找到的话对应的位置<br>A variable pointing to the include directory for the library.</td><td></td></tr><tr><td>xxx_LIBRARY</td><td>A variable pointing to the library path.</td><td></td></tr><tr><td>XXX_FOUND</td><td>某个第三方库是否找到</td><td></td></tr><tr><td>CMAKE_CXX_STANDARD</td><td>指定 C++ 的版本</td><td></td></tr></tbody></table><p>以后还会增加。</p><h3 id="binary-directory" tabindex="-1"><a class="header-anchor" href="#binary-directory" aria-hidden="true">#</a> Binary Directory</h3><blockquote><p>The root or top level folder that you run the cmake command from is known as your <strong>CMAKE_BINARY_DIR</strong> and is the root folder for all your binary files. CMake supports building and generating your binary files both in-place and also out-of-source.</p></blockquote><p>这段话说了可以原地 cmake, 也可以在外面 cmake.</p><p>原地 cmake 如下：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>cmake <span class="token builtin class-name">.</span>
</code></pre></div><p>原地 cmake 的缺点在于：你的源代码和 Makefiles 和目标代码都混在一起了(interspersed)</p><p>Out-of-Source cmake 如下：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkdir</span> build
<span class="token builtin class-name">cd</span> build/
cmake <span class="token punctuation">..</span>
</code></pre></div><p>换个地方 cmake 的好处就是，你想重新 cmake 的话，你就把生成的那个文件夹删除了，再 cmake 一次，就 OK 了。</p><h2 id="functions" tabindex="-1"><a class="header-anchor" href="#functions" aria-hidden="true">#</a> functions</h2><h3 id="target-include-directories" tabindex="-1"><a class="header-anchor" href="#target-include-directories" aria-hidden="true">#</a> target_include_directories</h3><p>如果存在多个 include 文件夹，则可以使用 <code>target_include_directories()</code>， 其作用类似于 <code>-I</code>.</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>target
    <span class="token namespace">PRIVATE</span>
        <span class="token punctuation">\${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/include
<span class="token punctuation">)</span>
</code></pre></div><p><code>PRIVATE</code> 标识了 include 的作用域。</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>hello_library
    <span class="token namespace">PUBLIC</span>
        <span class="token punctuation">\${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/include
<span class="token punctuation">)</span>
</code></pre></div><p>This will cause the included directory used in the following places:</p><ul><li>When compiling the library</li><li>When compiling any additional target that links the library.</li></ul><p>就是说在编译的时候会找 include 下面的东西，或者是其他链接到这个 library 的也会来这找的。</p><h3 id="add-library" tabindex="-1"><a class="header-anchor" href="#add-library" aria-hidden="true">#</a> add_library</h3><blockquote><p>The add_library() function is used to create a library from some source files.</p></blockquote><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">add_library</span><span class="token punctuation">(</span>hello_library <span class="token namespace">STATIC</span>
    src/Hello.cpp
<span class="token punctuation">)</span>
</code></pre></div><p>上述代码会创建出一个 <code>hello_library.a</code>.</p><p>除此之外也支持 shared lib:</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">add_library</span><span class="token punctuation">(</span>hello_library <span class="token namespace">SHARED</span>
    src/Hello.cpp
<span class="token punctuation">)</span>
</code></pre></div><p>上述代码会创建出一个 <code>libhello_library.so</code>.</p><h3 id="target-link-libraries" tabindex="-1"><a class="header-anchor" href="#target-link-libraries" aria-hidden="true">#</a> target_link_libraries</h3><p>比较好理解，就是链接的：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello_binary
    src/main.cpp
<span class="token punctuation">)</span>

<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span> hello_binary
    <span class="token namespace">PRIVATE</span>
        hello_library
<span class="token punctuation">)</span>
</code></pre></div><h3 id="install" tabindex="-1"><a class="header-anchor" href="#install" aria-hidden="true">#</a> install</h3><blockquote><p>CMake offers the ability to add a <code>make install</code> target to allow a user to install binaries, libraries and other files.</p></blockquote><p>cmake 支持获取二进制文件，安装的位置存储在环境变量 <strong>CMAKE_INSTALL_PREFIX</strong> 中，举例如下：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">install</span> <span class="token punctuation">(</span>TARGETS cmake_examples_inst_bin
    DESTINATION bin<span class="token punctuation">)</span>
</code></pre></div><p>或者 lib 文件(输出在 \${CMAKE_INSTALL_PREFIX}/bin)：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">install</span> <span class="token punctuation">(</span>TARGETS cmake_examples_inst
    LIBRARY DESTINATION lib<span class="token punctuation">)</span>
</code></pre></div><p>或者说目录（输出在 \${CMAKE_INSTALL_PREFIX}/include）：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">install</span><span class="token punctuation">(</span>DIRECTORY <span class="token punctuation">\${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/include/
    DESTINATION include<span class="token punctuation">)</span>
</code></pre></div><p>或者说文件（输出在 \${CMAKE_INSTALL_PREFIX}/etc）：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">install</span> <span class="token punctuation">(</span>FILES cmake-examples.conf
    DESTINATION etc<span class="token punctuation">)</span>
</code></pre></div><p>对于这个，我们涉及到了使用 <code>make install</code>, 所以需要再说明一下，我们对上面存在四个 <code>install</code> 的 CMake 文件进行 make,　其步骤如下：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">mkdir</span> build
$ <span class="token builtin class-name">cd</span> build/
$ cmake <span class="token punctuation">..</span>
$ <span class="token function">make</span>
$ <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span> 
</code></pre></div><p>其对应的输出如下：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>Install the project<span class="token punctuation">..</span>.
-- Install configuration: <span class="token string">&quot;&quot;</span>
-- Installing: /usr/local/bin/cmake_examples_inst_bin
-- Set runtime path of <span class="token string">&quot;/usr/local/bin/cmake_examples_inst_bin&quot;</span> to <span class="token string">&quot;&quot;</span>
-- Installing: /usr/local/lib/libcmake_examples_inst.so
-- Up-to-date: /usr/local/include
-- Installing: /usr/local/include/installing
-- Installing: /usr/local/include/installing/Hello.h
-- Installing: /usr/local/etc/cmake-examples.conf
</code></pre></div><p>我们在执行完 <code>sudo make install </code> 命令后会生成一个 <code>install_manifest.txt</code> 文件，其内容如下：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>/usr/local/bin/cmake_examples_inst_bin
/usr/local/lib/libcmake_examples_inst.so
/usr/local/include/installing/Hello.h
</code></pre></div><p>❓❓❓ 如果要看到输出：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:/usr/local/lib cmake_examples_inst_bin
Hello Install<span class="token operator">!</span>
</code></pre></div><p>还有一点，如果我们要更改 <strong>CMAKE_INSTALL_PREFIX</strong> 这个环境变量的默认值的话，可以这么操作：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT</span> <span class="token punctuation">)</span>
  <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">&quot;Setting default CMAKE_INSTALL_PREFIX path to <span class="token interpolation"><span class="token punctuation">\${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span></span>/install&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_INSTALL_PREFIX</span> <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">\${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span></span>/install&quot;</span> <span class="token variable">CACHE</span> STRING <span class="token string">&quot;The path to use for make install&quot;</span> FORCE<span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>或者这样：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code>make install DESTDIR=/tmp/stage
</code></pre></div><p>我们执行完后，需要进行卸载，命令如下：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code>sudo xargs rm &lt; install_manifest.txt
</code></pre></div><p>🧡🧡🧡 我之前使用了 <code>make clean</code> 似乎也达到了效果，但是仔细观察发现，libcmake_examples_inst.so 这个文件没有被干掉，所以还是要使用上面的方式！需要注意。</p><h3 id="target-compile-definitions" tabindex="-1"><a class="header-anchor" href="#target-compile-definitions" aria-hidden="true">#</a> target_compile_definitions</h3><p>target_compile_definitions() 这个函数就是用来设置 compile flags 的，我们引用原文：</p><p>CMake supports setting compile flags in a number of different ways:</p><ul><li>using target_compile_definitions() function</li><li>using the CMAKE_C_FLAGS and CMAKE_CXX_FLAGS variables.</li></ul><p>举例如下：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">target_compile_definitions</span><span class="token punctuation">(</span>cmake_examples_compile_flags
    <span class="token namespace">PRIVATE</span> EX3
<span class="token punctuation">)</span>
</code></pre></div><p>这个会造成在编译的时候加入定义 EX3.</p><h3 id="find-package" tabindex="-1"><a class="header-anchor" href="#find-package" aria-hidden="true">#</a> find_package</h3><p>如果要使用第三方库的话，我们需要进行查找，如下所示：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">find_package</span><span class="token punctuation">(</span>Boost <span class="token number">1.46.1</span> REQUIRED COMPONENTS filesystem system<span class="token punctuation">)</span>
</code></pre></div><p>我们如果需要验证是否找到了这个包，可以通过生成的变量 <code>XXX_FOUND</code> 来进行判断，如下所示：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">if</span><span class="token punctuation">(</span>Boost_FOUND<span class="token punctuation">)</span>
    <span class="token keyword">message</span> <span class="token punctuation">(</span><span class="token string">&quot;boost found&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">\${</span>Boost_INCLUDE_DIRS<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">message</span> <span class="token punctuation">(</span>FATAL_ERROR <span class="token string">&quot;Cannot find Boost&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上面出现了一个 <code>\${Boost_INCLUDE_DIRS}</code>， 原理类似，就是找到的话，我们会生成一个这样的变量供我们使用。</p><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> set</h3><p>我们可以指定 c++ 的版本，如下所示：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">11</span><span class="token punctuation">)</span>
</code></pre></div><p>当然我们还有基础的方法：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">if</span><span class="token punctuation">(</span>COMPILER_SUPPORTS_CXX11<span class="token punctuation">)</span><span class="token comment">#</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_FLAGS</span> <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">\${</span><span class="token variable">CMAKE_CXX_FLAGS</span><span class="token punctuation">}</span></span> -std=c++11&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">elseif</span><span class="token punctuation">(</span>COMPILER_SUPPORTS_CXX0X<span class="token punctuation">)</span><span class="token comment">#</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_FLAGS</span> <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">\${</span><span class="token variable">CMAKE_CXX_FLAGS</span><span class="token punctuation">}</span></span> -std=c++0x&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">&quot;The compiler <span class="token interpolation"><span class="token punctuation">\${</span><span class="token variable">CMAKE_CXX_COMPILER</span><span class="token punctuation">}</span></span> has no C++11 support. Please use a different C++ compiler.&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="target-compile-features" tabindex="-1"><a class="header-anchor" href="#target-compile-features" aria-hidden="true">#</a> target_compile_features</h3><p>其用法如下，我们设置了 <code>cxx_auto_type</code> 这个 feature：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">target_compile_features</span><span class="token punctuation">(</span>hello_cpp11 <span class="token namespace">PUBLIC</span> <span class="token property">cxx_auto_type</span><span class="token punctuation">)</span>
</code></pre></div><p>在执行 <code>cmake ..</code> 的时候，我们可以看到打印：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token string">&quot;List of compile features: <span class="token interpolation"><span class="token punctuation">\${</span><span class="token variable">CMAKE_CXX_COMPILE_FEATURES</span><span class="token punctuation">}</span></span>&quot;</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>List of compile features: cxx_template_template_parameters<span class="token punctuation">;</span>cxx_alias_templates<span class="token punctuation">;</span><span class="token punctuation">..</span>.
</code></pre></div><p>就是说，我们的所有 feature 都是保存在了 <code>CMAKE_CXX_COMPILE_FEATURES</code> 这个变量中。</p><h3 id="message" tabindex="-1"><a class="header-anchor" href="#message" aria-hidden="true">#</a> message</h3><p>有的时候我们需要打印出一些变量来用于调试，我们可以使用 <code>mesage()</code> 来实现：</p><div class="language-cmake line-numbers-mode" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.5</span><span class="token punctuation">)</span>

<span class="token comment"># Set the project name</span>
<span class="token keyword">project</span> <span class="token punctuation">(</span>hello_cmake<span class="token punctuation">)</span>

<span class="token comment"># print project name variable</span>
<span class="token keyword">message</span> <span class="token punctuation">(</span><span class="token string">&quot;project name is <span class="token interpolation"><span class="token punctuation">\${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span></span>&quot;</span><span class="token punctuation">)</span>

<span class="token comment"># Add an executable</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello_cmake main.cpp<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其输出如下所示：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>project name is hello_cmake
</code></pre></div><h2 id="compiler-option" tabindex="-1"><a class="header-anchor" href="#compiler-option" aria-hidden="true">#</a> Compiler Option</h2><h3 id="clang" tabindex="-1"><a class="header-anchor" href="#clang" aria-hidden="true">#</a> clang</h3><p>CMake exposes options to control the programs used to compile and link your code. These programs include:</p><ul><li>CMAKE_C_COMPILER - The program used to compile c code.</li><li>CMAKE_CXX_COMPILER - The program used to compile c++ code.</li><li>CMAKE_LINKER - The program used to link your binary.</li></ul><p>（如果要进行验证，首先安装 clang: <code>sudo apt-get install clang-3.6</code>）</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code>cmake .. -DCMAKE_C_COMPILER=clang-<span class="token number">3.6</span> -DCMAKE_CXX_COMPILER=clang++-<span class="token number">3.6</span>
</code></pre></div><h3 id="ninja" tabindex="-1"><a class="header-anchor" href="#ninja" aria-hidden="true">#</a> ninja</h3><p>我们可以指定构建工具进行构建，如 ninja:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>cmake <span class="token punctuation">..</span> <span class="token parameter variable">-G</span> Ninja
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span>
CMakeCache.txt  CMakeFiles  build.ninja  cmake_install.cmake  hello_cmake  rules.ninja
</code></pre></div><h2 id="sub-projects" tabindex="-1"><a class="header-anchor" href="#sub-projects" aria-hidden="true">#</a> Sub Projects</h2><h3 id="add-subdirectory" tabindex="-1"><a class="header-anchor" href="#add-subdirectory" aria-hidden="true">#</a> add_subdirectory</h3><p>其用法如下：</p><div class="language-cmake" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>sublibrary1<span class="token punctuation">)</span>
<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>sublibrary2<span class="token punctuation">)</span>
<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>subbinary<span class="token punctuation">)</span>
</code></pre></div><p>为了加深理解，我们给出这个含有子目录的文件结构：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>.
|-- CMakeLists.txt
|-- README.adoc
|-- subbinary
|   |-- CMakeLists.txt
|   \`-- main.cpp
|-- sublibrary1
|   |-- CMakeLists.txt
|   |-- include
|   |   \`-- sublib1
|   |       \`-- sublib1.h
|   \`-- src
|       \`-- sublib1.cpp
\`-- sublibrary2
    |-- CMakeLists.txt
    \`-- include
        \`-- sublib2
            \`-- sublib2.h
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，和 Cmake 文件同在一个路径的有 subbinary， subbinary1 和 subbinary2 三个，所以我们 add_subdirectory 使用了三个。</p><p>其更加稳妥的用法如下：</p><div class="language-cpp" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span><span class="token punctuation">(</span>EXISTS $<span class="token punctuation">{</span>PRJ_TOP_DIR<span class="token punctuation">}</span><span class="token operator">/</span>src<span class="token punctuation">)</span>
  <span class="token function">add_subdirectory</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>
<span class="token function">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><hr class="footnotes-sep">`,121),r={class:"footnotes"},u={class:"footnotes-list"},k={id:"footnote1",class:"footnote-item"},m={href:"https://github.com/ttroy50/cmake-examples",target:"_blank",rel:"noopener noreferrer"},h=a("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1),g={id:"footnote2",class:"footnote-item"},b={href:"https://cmake.org/cmake/help/latest/guide/tutorial/index.html",target:"_blank",rel:"noopener noreferrer"},_=a("a",{href:"#footnote-ref2",class:"footnote-backref"},"↩︎",-1),f={id:"footnote3",class:"footnote-item"},v={href:"https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/Useful-Variables",target:"_blank",rel:"noopener noreferrer"},y=a("a",{href:"#footnote-ref3",class:"footnote-backref"},"↩︎",-1);function C(E,x){const s=c("ExternalLinkIcon");return o(),p("div",null,[d,a("section",r,[a("ol",u,[a("li",k,[a("p",null,[a("a",m,[n("https://github.com/ttroy50/cmake-examples"),e(s)]),n(),h])]),a("li",g,[a("p",null,[a("a",b,[n("https://cmake.org/cmake/help/latest/guide/tutorial/index.html"),e(s)]),n(),_])]),a("li",f,[a("p",null,[a("a",v,[n("Useful Variables"),e(s)]),n(),y])])])])])}const R=t(i,[["render",C],["__file","cmake.html.vue"]]);export{R as default};
