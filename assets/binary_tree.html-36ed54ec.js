import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as l,c as i,e as u,d as a,a as n,b as s,f as e}from"./app-22cda79c.js";const r={},d=n("p",null,"本文主要研究了：",-1),k=n("ul",null,[n("li",null,"二叉树的三种遍历方式：递归和迭代实现"),n("li",null,"二叉树相关的例题解析")],-1),v=e(`<h2 id="二叉树的前序遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的前序遍历" aria-hidden="true">#</a> 二叉树的前序遍历</h2><h3 id="递归法" tabindex="-1"><a class="header-anchor" href="#递归法" aria-hidden="true">#</a> 递归法</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># Definition for a binary tree node.</span>
<span class="token comment"># class TreeNode:</span>
<span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="token comment">#         self.val = val</span>
<span class="token comment">#         self.left = left</span>
<span class="token comment">#         self.right = right</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            preorder<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            preorder<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        res <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        preorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述就是递归实现的而阐述的前序遍历。除此之外，还有一种不是很 Python 的但是较为通用、方便理解的方法：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token comment"># 前序遍历函数</span>
    <span class="token keyword">def</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>preOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>preOrder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>preOrder<span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其本质上就是把递归的结果收集 <code>res</code> 增加到了递归中去了。</p><p>我们还有一种很 Python 的实现方式如下：</p><div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">return</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
</code></pre></div><p>是不是很优雅？哈哈，值得深入去理解！</p><h3 id="迭代法" tabindex="-1"><a class="header-anchor" href="#迭代法" aria-hidden="true">#</a> 迭代法</h3><p>前序遍历的迭代实现依赖于栈结构，具体而言不是很好理解的，需要多加理解才可以，其实现如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack <span class="token keyword">or</span> root<span class="token punctuation">:</span>
            <span class="token keyword">while</span> root<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码中可以看出来的规律如下：</p><ol><li>stack 中自始至终只加入了 <code>root.right</code></li><li><code>root.left</code> 都是被遍历完毕了</li></ol><h2 id="二叉树的中序遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的中序遍历" aria-hidden="true">#</a> 二叉树的中序遍历</h2><h3 id="递归法-1" tabindex="-1"><a class="header-anchor" href="#递归法-1" aria-hidden="true">#</a> 递归法</h3><p>二叉树的中序遍历递归解法参考如下：</p><div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
</code></pre></div><h3 id="迭代法-1" tabindex="-1"><a class="header-anchor" href="#迭代法-1" aria-hidden="true">#</a> 迭代法</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack <span class="token keyword">or</span> root<span class="token punctuation">:</span>
            <span class="token keyword">while</span> root<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法理解起来并不是很直观，我们需要加深对“中序遍历：左 -- 根 -- 右” 的理解，就是说我们先遍历左子树，然后遍历完之后再走到右子树。</p><p>我们可以举例说：</p>`,22),m=n("p",null,"上述二叉树的中序遍历结果是 [4, 2, 5, 1, 6, 3]",-1),b=n("p",null,"我们第一趟的时候，栈内元素是 [1, 2, 4], 然后 root 指向了 Null, 这时候我们给结果里面增加元素，到 root.right 不是 Null 了，再继续找。",-1),h={href:"https://leetcode.cn/problems/successor-lcci/",target:"_blank",rel:"noopener noreferrer"},f=n("h2",{id:"二叉树的层次遍历",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#二叉树的层次遍历","aria-hidden":"true"},"#"),s(" 二叉树的层次遍历")],-1),y={href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},g=n("p",null,"代码实现如下：",-1),w={href:"https://github.com/chenweigao/_code/blob/master/python/binary_tree.py",target:"_blank",rel:"noopener noreferrer"},_=e(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&#39;&#39;&#39;
    二叉树的层次遍历
    &#39;&#39;&#39;</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>data<span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 存储层次遍历的结果</span>
    current <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>  <span class="token comment"># 存储当前层次内的节点，在循环里面更新</span>

    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        node_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 临时存储节点</span>
        <span class="token keyword">for</span> node <span class="token keyword">in</span> current<span class="token punctuation">:</span>  <span class="token comment"># 循环内遍历</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                node_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                node_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">if</span> node_list <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        vals <span class="token operator">=</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>data <span class="token keyword">for</span> node <span class="token keyword">in</span> node_list<span class="token punctuation">]</span>  <span class="token comment"># 拿出当前层次的节点的值</span>
        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>vals<span class="token punctuation">)</span>
        current <span class="token operator">=</span> node_list  <span class="token comment"># 更新层次</span>
    <span class="token keyword">return</span> result
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是目前可以写出的比较高效的一个算法，应当牢记。</p><p>也可以参考下面的解法：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            <span class="token comment"># 这个 node 已经取出了</span>
            size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 在 for 循环中把 q 这个队列拿空</span>
                <span class="token comment"># 第一次 for 迭代循环的是 root 节点</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>

            <span class="token keyword">if</span> tmp<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>

        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用递归的方法：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> res<span class="token punctuation">,</span> level<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> level<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当遍历到一个新的深度 level，而最终结果 res 中还没有创建 level 对应的列表时，应该在 res 中新建一个列表用来保存该 level 的所有节点。</p><h2 id="例题" tabindex="-1"><a class="header-anchor" href="#例题" aria-hidden="true">#</a> 例题</h2><h3 id="lc606-根据二叉树创建字符串-前序遍历" tabindex="-1"><a class="header-anchor" href="#lc606-根据二叉树创建字符串-前序遍历" aria-hidden="true">#</a> LC606 根据二叉树创建字符串（前序遍历）</h3>`,9),x={href:"https://leetcode-cn.com/problems/construct-string-from-binary-tree/",target:"_blank",rel:"noopener noreferrer"},T=e(`<p>题目的大概意思是，前序遍历二叉树，但是给每个子节点都用括号包裹起来，如果子节点是空的话，就不用括号。是一道简单题。</p><p>这道题目的核心难点在于，如何包裹。解法给出了一个<strong>讨论情况然后分别处理</strong>的方法：</p><ol><li>左右节点都没有了，返回；</li><li>左节点有，右节点没有，左节点包裹后继续递归；</li><li>左节点没有，右节点有，左节点用空括号（题目要求），右节点递归</li><li>左右节点都有，都递归</li></ol><p>其实现方式如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">tree2str</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">&#39;&#39;</span>
        
        res <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            <span class="token keyword">return</span> res

        left <span class="token operator">=</span> self<span class="token punctuation">.</span>tree2str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>tree2str<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        res <span class="token operator">+=</span> <span class="token string">&#39;(&#39;</span> <span class="token operator">+</span> left <span class="token operator">+</span> <span class="token string">&#39;)&#39;</span>
        <span class="token keyword">if</span> right<span class="token punctuation">:</span>
            res <span class="token operator">+=</span> <span class="token string">&#39;(&#39;</span> <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token string">&#39;)&#39;</span>

        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="lc101-对称二叉树" tabindex="-1"><a class="header-anchor" href="#lc101-对称二叉树" aria-hidden="true">#</a> LC101 对称二叉树</h3>`,6),q={href:"https://leetcode-cn.com/problems/symmetric-tree/",target:"_blank",rel:"noopener noreferrer"},N=e(`<p>给定二叉树，判断二叉树是否镜像对称。</p><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>    1
   / \\
  2   2
 / \\ / \\
3  4 4  3
</code></pre></div><h4 id="dfs-解法" tabindex="-1"><a class="header-anchor" href="#dfs-解法" aria-hidden="true">#</a> DFS 解法</h4><p>这是该题目的 DFS（递归）解法。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">SolutionDFS</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token comment"># 反例 [1]</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>

        <span class="token comment"># if not root.left or not root.right:</span>
        <span class="token comment">#     return False</span>

        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 递归终止条件，两个节点都为空</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> left <span class="token keyword">and</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>

            <span class="token keyword">if</span> <span class="token keyword">not</span> left <span class="token keyword">or</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>

            <span class="token keyword">if</span> left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>

            <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">and</span> dfs<span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>

        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码中我们可以看出，我们定义递归终止条件：</p><ol><li>两个节点都为空，返回 True, 递归终止</li><li>两个节点中有一个不存在，不对称，返回 False</li><li>两个节点的值不相等，返回 False</li></ol><p>在这些条件满足以后，我们对 <code>left.left</code> 和 <code>right.right</code>等分别递归即可求出结果。</p><h4 id="bfs-解法" tabindex="-1"><a class="header-anchor" href="#bfs-解法" aria-hidden="true">#</a> BFS 解法</h4>`,10),S={href:"https://leetcode-cn.com/problems/symmetric-tree/",target:"_blank",rel:"noopener noreferrer"},L=e(`<p>给定二叉树，判断二叉树是否镜像对称。</p><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>    1
   / \\
  2   2
 / \\ / \\
3  4 4  3
</code></pre></div><p>可以看出，上述中就是一个对称的二叉树，我们得出一个简单的规律：</p><ol><li>对于某个节点，如果其没有左节点或者右节点，那么其肯定不是一个对称二叉树；</li><li>对于某个节点，其兄弟节点的左右节点值要与自己的左右节点值对应相等。我们该如何保证这个呢？</li></ol><p>其对应的代码如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

        q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            left<span class="token punctuation">,</span> right <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> left <span class="token keyword">and</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> left <span class="token keyword">or</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">if</span> left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>

            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种解法的思路在于，在队列中同时取出两个节点 left, right，然后判断其值是否相等，再将他们的孩子中按照 <code>(left.left, right.right)</code> 一组，<code>(left.right, right.left)</code>一组放入队列中。</p><p>还有一种解法是，往队列中放 4 次元素，按照 <code>left.left, right.right, left.right, right.left</code> 的顺序，然后逐一判断即可。</p><h3 id="lc111-二叉树的最小深度" tabindex="-1"><a class="header-anchor" href="#lc111-二叉树的最小深度" aria-hidden="true">#</a> LC111 二叉树的最小深度</h3>`,9),F={href:"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},O=e(`<p>🏀🏀🏀 我们根据“概览”中的原则对这个问题进行分析：起点就是 root 节点，终点就是最靠近根节点的那个叶子节点（叶子节点的左右子节点都是 null）。</p><h4 id="bfs-解法-1" tabindex="-1"><a class="header-anchor" href="#bfs-解法-1" aria-hidden="true">#</a> BFS 解法</h4><p>其使用 BFS 的解法如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># Definition for a binary tree node.</span>
<span class="token comment"># class TreeNode:</span>
<span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="token comment">#         self.val = val</span>
<span class="token comment">#         self.left = left</span>
<span class="token comment">#         self.right = right</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        
        queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        first_node <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>first_node<span class="token punctuation">)</span>

        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node<span class="token punctuation">,</span> depth <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 判断是否到达终点，终止条件</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> depth
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="lc104-二叉树的最大深度" tabindex="-1"><a class="header-anchor" href="#lc104-二叉树的最大深度" aria-hidden="true">#</a> LC104 二叉树的最大深度</h3><h4 id="dfs-解法-1" tabindex="-1"><a class="header-anchor" href="#dfs-解法-1" aria-hidden="true">#</a> DFS 解法</h4>`,6),B={href:"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},D=n("p",null,[s("💓💓💓 "),n("strong",null,"思考"),s(" 🧡🧡🧡")],-1),C=n("p",null,"如何用 DFS 的思维来思考这个问题呢？",-1),M=n("p",null,[s("假设我们已经知道了左子树和右子树的最大深度 "),n("code",null,"l"),s(", "),n("code",null,"r"),s(", 那么整个二叉树的最大深度就是根节点的深度 1 加上左右子树中的最大深度，用公式表达是：")],-1),z=n("p",{class:"katex-block"},[n("span",{class:"katex-display"},[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[n("semantics",null,[n("mrow",null,[n("mi",null,"d"),n("mi",null,"e"),n("mi",null,"p"),n("mi",null,"t"),n("mi",null,"h"),n("mo",null,"="),n("mi",null,"m"),n("mi",null,"a"),n("mi",null,"x"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mo",{separator:"true"},","),n("mi",null,"r"),n("mo",{stretchy:"false"},")"),n("mo",null,"+"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"}," depth = max(l, r) + 1 ")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),n("span",{class:"mord mathnormal"},"d"),n("span",{class:"mord mathnormal"},"e"),n("span",{class:"mord mathnormal"},"pt"),n("span",{class:"mord mathnormal"},"h"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"="),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"ma"),n("span",{class:"mord mathnormal"},"x"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),n("span",{class:"mclose"},")"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])])])],-1),I=n("p",null,"所以我们可以使用深度有限搜索来计算二叉树的最大深度，具体而言就是递归计算出二叉树左子树和右子树的最大深度，然后再使用上述公式直接计算出二叉树的最大深度。",-1),V=n("p",null,"而二叉树左右子树的深度也都可以通过相同的方法递归获得，递归在访问到空节点时退出。",-1),E=n("p",null,[n("strong",null,"复杂度分析")],-1),G=n("p",null,[s("该问题使用 DFS 求解，其时间复杂度为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s(", 每个节点在递归中只被遍历一次。")],-1),U=n("p",null,[s("其空间复杂度为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"h"),n("mi",null,"e"),n("mi",null,"i"),n("mi",null,"g"),n("mi",null,"h"),n("mi",null,"t"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(height)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"h"),n("span",{class:"mord mathnormal"},"e"),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"h"),n("span",{class:"mord mathnormal"},"t"),n("span",{class:"mclose"},")")])])]),s("，与二叉树的高度有关。由于递归需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。")],-1),H=e(`<p><strong>问题求解</strong></p><p>这个题目存在 DFS 和 BFS 解法，下面是这个题目的 DFS 解法：</p><ul><li><p>解法：使用辅助函数来进行递归：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>

        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span>

            <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>

        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述做法使用了一个 <code>dfs()</code>辅助函数进行递归，我们也可以不使用辅助函数。</p></li><li><p>解法：直接递归：</p><div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code></pre></div><p>这个不带辅助函数的解法是比带辅助函数的解法稍慢的，但是代码更加简洁。</p></li></ul><h4 id="bfs-解法-2" tabindex="-1"><a class="header-anchor" href="#bfs-解法-2" aria-hidden="true">#</a> BFS 解法</h4><p>对比求二叉树的最小深度，其代码如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        res <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            node<span class="token punctuation">,</span> depth <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，该题目还存在 DFS 解法，可以参考上文。</p><h3 id="lc102-二叉树的层序遍历" tabindex="-1"><a class="header-anchor" href="#lc102-二叉树的层序遍历" aria-hidden="true">#</a> LC102 二叉树的层序遍历</h3>`,8),W={href:"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},J=e(`<p>二叉树的层序遍历也会使用到 BFS 的思想，这个题目存在以下几个难点：</p><ol><li>如何构造最终的结果，即类似于 <code>[[3], [9,20], [15,7]]</code> 这样的 List of List 的形式？</li><li>能否继续使用上面的解法模板来求解这个问题？模板是否具有普适性？</li></ol><h4 id="bfs-解法-3" tabindex="-1"><a class="header-anchor" href="#bfs-解法-3" aria-hidden="true">#</a> BFS 解法</h4><p>接下来看第一版本的代码：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 在 for 循环中把 q 这个队列拿空</span>
                <span class="token comment"># 第一次 for 迭代循环的是 root 节点</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>

            <span class="token keyword">if</span> tmp<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出：</p><ol><li><p>在每次迭代中，我们都保证了把同一层的元素进行迭代；即队列中存储的元素永远是在同一层的元素，然后计算出这些元素的个数，用 for 循环逐一进行遍历。</p><div class="hint-container warning"><p class="hint-container-title">❗❗❗ BFS 为什么要使用队列？</p><p>在这里我理解了为什么 BFS 要使用队列这个数据结构，我们用 for 循环逐一进行遍历的时候，还没被遍历到的“上一层”元素都是在队列头部的，使用队列能保证这些上一层元素都被“踢”出去，而不影响本层新进来的元素。</p></div></li><li><p>这个题目的关键就是用 for 循环保证了同一层元素的遍历。</p></li></ol><h3 id="lc107-二叉树的层序遍历ii" tabindex="-1"><a class="header-anchor" href="#lc107-二叉树的层序遍历ii" aria-hidden="true">#</a> LC107 二叉树的层序遍历II</h3>`,8),P={href:"https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/",target:"_blank",rel:"noopener noreferrer"},R=e(`<p>这个题目不同于二叉树层次遍历的地方在于，**给定一个二叉树，返回其节点值自底向上的层序遍历。 **</p><p>为了达到这个效果，我们可以在每次遍历之后，将结果放在结果集的头部，这样就可以得到我们想要的输出形式了。</p><p>其相对于上述代码的不同在于：</p><div class="language-python" data-ext="py"><pre class="language-python"><code>res <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 向左端插入</span>
res<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>

<span class="token comment"># 返回时进行类型转换</span>
<span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre></div><p>当然也可以使用上面的代码直接将结果反转。</p><h3 id="lc103-二叉树的锯齿形层序遍历" tabindex="-1"><a class="header-anchor" href="#lc103-二叉树的锯齿形层序遍历" aria-hidden="true">#</a> LC103 二叉树的锯齿形层序遍历</h3>`,6),A={href:"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},Q=e(`<p>这道题目是上面二叉树层序遍历的变种题目，题目的描述为：</p><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p></blockquote><p>我们对题目进行分析可以发现遍历顺序和层级的关系：</p><table><thead><tr><th>层数</th><th>遍历顺序</th></tr></thead><tbody><tr><td>第一层（root）</td><td>从左往右</td></tr><tr><td>第二层</td><td>从右往左</td></tr><tr><td>第三次</td><td>从左往右</td></tr><tr><td>第四层</td><td>从右往左</td></tr><tr><td><strong>奇数层</strong></td><td>从左往右</td></tr><tr><td><strong>偶数层</strong></td><td>从右往左</td></tr></tbody></table><p>我们发现遍历的顺序是和层级有关的，因此我们可以根据层级来确定遍历顺序：</p><p>🔴🔴🔴 <strong>遍历顺序</strong>，需要注意的是，我们一定要在队列中先添加左节点，再添加右节点，这个顺序需要保证，才能与后面的 <code>depth % 2 == 0</code> 配套。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        depth <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node<span class="token punctuation">,</span> depth <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment"># 注意遍历顺序</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                
            <span class="token keyword">if</span> depth <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token comment"># 偶数层从右往左</span>
                tmp<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> tmp<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>

        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="lc543-二叉树的直径" tabindex="-1"><a class="header-anchor" href="#lc543-二叉树的直径" aria-hidden="true">#</a> LC543 二叉树的直径</h3>`,8),Z={href:"https://leetcode-cn.com/problems/diameter-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Y=e(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">1</span>

    <span class="token keyword">def</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span>

            left <span class="token operator">=</span> depth<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> depth<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

            self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
        depth<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res <span class="token operator">-</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="面试题-04-06-后继者" tabindex="-1"><a class="header-anchor" href="#面试题-04-06-后继者" aria-hidden="true">#</a> 面试题 04.06. 后继者</h3>`,2),j={href:"https://leetcode.cn/problems/successor-lcci/",target:"_blank",rel:"noopener noreferrer"},K=e(`<blockquote><p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p><p>如果指定节点没有对应的“下一个”节点，则返回<code>null</code>。</p></blockquote><h4 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h4><p>我们可以使用中序遍历的方法来求解这个问题，并且中序遍历过程中，维护上一个访问的节点。</p><p>中序遍历部分，可以直接套用迭代的中序遍历模板。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        pre<span class="token punctuation">,</span> cur <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> root

        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">while</span> stack <span class="token keyword">or</span> cur<span class="token punctuation">:</span>
            <span class="token keyword">while</span> cur<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left

            cur <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> pre <span class="token operator">==</span> p<span class="token punctuation">:</span>
                <span class="token keyword">return</span> cur
            
            pre <span class="token operator">=</span> cur
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right

        <span class="token keyword">return</span> <span class="token boolean">None</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实现这个代码的时候，有几点我没有理解透彻，导致写错：</p><ol><li><code>pre, cur = None, root</code> 初始值的赋值需要好好体会</li><li><code>stack.append(cur)</code> 这边是 <code>cur</code> 入栈，入栈以后再遍历左边</li><li><code>cur = stack.pop()</code> 出栈的步骤不要忘记</li></ol><h4 id="bst-特性解法" tabindex="-1"><a class="header-anchor" href="#bst-特性解法" aria-hidden="true">#</a> BST 特性解法</h4><p>这道题目除了可以根据中序遍历来求解外，也可以根据 BST 的特点进行求解。</p><p>@todo</p>`,10);function X($,nn){const o=p("Mermaid"),t=p("ExternalLinkIcon");return l(),i("div",null,[d,k,u(" more"),v,a(o,{id:"mermaid-79",code:"eJxLy8kvT85ILCpRCHHhUgCCovz8Eg0NQ01NBV1dO4W8/JRUIw0NI01NHJLGGhrGUEmEWrisiYaGCW5ZUw0NUyRZiFFwWTMNDTPcsnmlOTkaGn5ABQAV9S58"}),m,b,n("p",null,[s("同样的，我们可以根据中序遍历的应用题目 "),n("a",h,[s("面试题 04.06. 后继者"),a(t)]),s(" 来加深印象。")]),f,n("p",null,[n("a",y,[s("LC102 - Binary Tree Level Order Traversal"),a(t)])]),g,n("p",null,[n("a",w,[s("Code GitHub - binary_tree"),a(t)])]),_,n("p",null,[n("a",x,[s("https://leetcode-cn.com/problems/construct-string-from-binary-tree/"),a(t)])]),T,n("p",null,[n("a",q,[s("101. 对称二叉树"),a(t)])]),N,n("p",null,[n("a",S,[s("101. 对称二叉树"),a(t)])]),L,n("p",null,[n("a",F,[s("二叉树的最小深度"),a(t)])]),O,n("p",null,[n("a",B,[s("104. 二叉树的最大深度"),a(t)])]),D,C,M,z,I,V,E,G,U,H,n("p",null,[n("a",W,[s("102. 二叉树的层序遍历"),a(t)])]),J,n("p",null,[n("a",P,[s("107. 二叉树的层序遍历 II"),a(t)])]),R,n("p",null,[n("a",A,[s("103. 二叉树的锯齿形层序遍历"),a(t)])]),Q,n("p",null,[n("a",Z,[s("https://leetcode-cn.com/problems/diameter-of-binary-tree/"),a(t)])]),Y,n("p",null,[n("a",j,[s("面试题 04.06. 后继者"),a(t)])]),K])}const tn=c(r,[["render",X],["__file","binary_tree.html.vue"]]);export{tn as default};
