import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as o,o as r}from"./app-11Vuyqh7.js";const s={};function e(i,t){return r(),n("div",null,t[0]||(t[0]=[o('<h2 id="_1-指令类型" tabindex="-1"><a class="header-anchor" href="#_1-指令类型"><span>1. 指令类型</span></a></h2><h3 id="_1-1-指令占比概览" tabindex="-1"><a class="header-anchor" href="#_1-1-指令占比概览"><span>1.1. 指令占比概览</span></a></h3><h3 id="_1-2-指令类型及占比" tabindex="-1"><a class="header-anchor" href="#_1-2-指令类型及占比"><span>1.2. 指令类型及占比</span></a></h3><p>以下是业务中各类指令的占比情况：</p><table><thead><tr><th>指令类别</th><th>占比 (%)</th><th>指令类别</th><th>占比 (%)</th><th>指令类别</th><th>占比 (%)</th></tr></thead><tbody><tr><td>数据传输 (DATAXFER)</td><td>44.00</td><td>算术运算 (BINARY)</td><td>17.00</td><td>条件跳转 (COND_BR)</td><td>14.00</td></tr><tr><td>逻辑运算 (LOGICAL)</td><td>7.00</td><td>移位操作 (SHIFT)</td><td>4.00</td><td>其他 (MISC)</td><td>3.00</td></tr><tr><td>空操作 (NOP)</td><td>2.00</td><td>出栈 (POP)</td><td>1.00</td><td>入栈 (PUSH)</td><td>1.00</td></tr><tr><td>无条件跳转 (UNCOND_BR)</td><td>1.00</td><td>函数调用 (CALL)</td><td>1.00</td><td>函数返回 (RET)</td><td>1.00</td></tr><tr><td>矢量扩展 (AVX)</td><td>1.00</td><td>宽 NOP (WIDENOP)</td><td>1.00</td><td>数据预取 (PREFETCH)</td><td>0.00</td></tr><tr><td>条件移动 (CMOV)</td><td>0.00</td><td>SSE 指令 (SSE)</td><td>0.00</td><td>条件设置 (SETCC)</td><td>0.00</td></tr><tr><td>信号量 (SEMAPHORE)</td><td>0.00</td><td>数据转换 (CONVERT)</td><td>0.00</td><td>字符串操作 (STRINGOP)</td><td>0.00</td></tr><tr><td>浮点逻辑 (LOGICAL_FP)</td><td>0.00</td><td>文本处理 (STTNI)</td><td>0.00</td><td>位操作扩展 (BMI1)</td><td>0.00</td></tr><tr><td>循环移位 (ROTATE)</td><td>0.00</td><td>广播 (BROADCAST)</td><td>0.00</td><td>高级矢量扩展 (AVX2)</td><td>0.00</td></tr><tr><td>前导零计数 (LZCNT)</td><td>0.00</td><td>位/字节操作 (BITBYTE)</td><td>0.00</td><td>系统调用 (SYSCALL)</td><td>0.00</td></tr><tr><td>FMA 指令 (VFMA)</td><td>0.00</td><td>位操作扩展 (BMI2)</td><td>0.00</td><td>掩码寄存器 (KMASK)</td><td>0.00</td></tr><tr><td>随机数生成 (RDRAND)</td><td>0.00</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="_1-3-高占比指令" tabindex="-1"><a class="header-anchor" href="#_1-3-高占比指令"><span>1.3. 高占比指令</span></a></h3><p><strong>DATAXFER (44%)</strong> - <strong>数据传输指令</strong>：负责在寄存器、内存和堆栈之间传输数据。</p><ul><li><p>典型指令：MOV, LEA, XCHG。</p></li><li><p>高占比表明代码数据移动频繁，可能涉及大量内存访问或寄存器间数据交换。</p></li></ul><p><strong>BINARY (17%)</strong> - <strong>算术运算指令</strong>：执行整数加法、减法、乘法、除法等操作。</p><ul><li><p>典型指令：ADD, SUB, MUL, DIV, INC, DEC。</p></li><li><p>占比较高，说明代码涉及大量数值计算。</p></li></ul><p><strong>COND_BR (14%)</strong> - <strong>条件跳转指令</strong>：依赖标志寄存器的值决定是否跳转。</p><ul><li><p>典型指令：JZ, JNZ, JE, JNE, JA, JB。</p></li><li><p>说明代码逻辑较复杂，可能存在大量 if-else 结构或循环控制。</p></li></ul><p><strong>LOGICAL (7%)</strong> - <strong>逻辑运算指令</strong></p><ul><li><p>处理位运算，如按位与、或、异或等。</p></li><li><p>典型指令：AND, OR, XOR, NOT, TEST。</p></li><li><p>这些指令常用于位运算优化、布尔逻辑计算、掩码操作等。</p></li></ul><p><strong>SHIFT (4%)</strong> - <strong>移位指令</strong>：进行算术或逻辑移位，常用于高效乘除法、哈希计算或数据对齐。</p><ul><li><p>典型指令：SHL, SHR, SAR, ROL, ROR。</p></li><li><p>表明代码中有一定的位运算优化需求。</p></li></ul><p><strong>MISC (3%)</strong> - <strong>其他类型指令</strong>：可能包括系统控制、性能测量等特殊指令。</p><ul><li><p>典型指令：CPUID, RDTSC, HLT, RDPMC。</p></li><li><p>占比较低，说明这部分功能不是代码核心。</p></li></ul><p><strong>NOP (2%)</strong> - <strong>空操作指令</strong>：NOP 用于对齐、性能优化、流水线填充等。说明代码可能经过一定程度的指令对齐优化。</p><p><strong>POP (1%) / PUSH (1%)</strong> - <strong>栈操作指令</strong>：PUSH 和 POP 用于函数调用、寄存器保存/恢复。低占比说明代码对栈的依赖较少，可能优化了寄存器使用。</p><p><strong>UNCOND_BR (1%)</strong> - <strong>无条件跳转指令</strong>：直接跳转到指定地址，通常用于循环或异常处理。</p><ul><li><p>典型指令：JMP, CALL, RET。</p></li><li><p>低占比表明代码结构较线性，不依赖大量跳转。</p></li></ul><p><strong>CALL (1%) / RET (1%)</strong> - <strong>函数调用与返回</strong>：CALL 进入子程序，RET 退出子程序。低占比可能说明函数调用层次较少，或者有内联优化。</p><h3 id="_1-4-极低或未使用指令" tabindex="-1"><a class="header-anchor" href="#_1-4-极低或未使用指令"><span>1.4. 极低或未使用指令</span></a></h3><p><strong>AVX (1%)</strong> - <strong>AVX 指令</strong></p><ul><li><p>先进矢量扩展（Advanced Vector Extensions），用于 SIMD 浮点运算。</p></li><li><p>典型指令：VADDPS, VMULPS。</p></li><li><p>低占比可能说明代码未针对 SIMD 优化，或者 AVX 计算需求较少。</p></li></ul><p><strong>WIDENOP (1%)</strong> - <strong>宽 NOP 指令</strong>：主要用于对齐和优化指令流水线。</p><p><strong>PREFETCH (0%)</strong> - <strong>数据预取指令</strong>：用于提前加载数据到缓存，提高缓存命中率。</p><ul><li><p>典型指令：PREFETCHT0, PREFETCHW。</p></li><li><p>低占比表明代码没有显式使用数据预取优化。</p></li></ul><p><strong>CMOV (0%)</strong> - <strong>条件移动指令</strong>：避免分支预测失败，提高性能。</p><ul><li><p>典型指令：CMOVZ, CMOVNZ。</p></li><li><p>低占比可能说明编译器优化不足，或者代码不依赖分支规避技术。</p></li></ul><p><strong>SSE (0%)</strong> - <strong>SSE 指令</strong></p><ul><li><p>浮点和 SIMD 计算指令。</p></li><li><p>典型指令：MOVAPS, ADDPS。</p></li><li><p>占比 0% 可能说明代码没有使用 SSE 或者使用了更先进的 AVX。</p></li></ul><p><strong>SETCC (0%)</strong> - <strong>条件设置指令</strong></p><p>• 依据标志寄存器结果，将寄存器设置为 0 或 1。</p><p>• 典型指令：SETZ, SETNZ。</p><p>• 占比 0% 可能说明代码逻辑不依赖条件标志位存储。</p><p><strong>SEMAPHORE (0%)</strong> - <strong>信号量操作指令</strong></p><p>• 多线程同步控制指令。</p><p>• 说明代码基本没有多线程同步需求。</p><p><strong>CONVERT (0%)</strong> - <strong>数据转换指令</strong></p><p>• 例如整数与浮点数转换。</p><p>• CVTSI2SS, CVTSS2SI。</p><ol><li><strong>STRINGOP (0%)</strong> - <strong>字符串操作指令</strong></li></ol><p>• REP MOVSB, REP SCASB。</p><p>• 说明代码不涉及大规模字符串处理。</p><ol start="20"><li><strong>LOGICAL_FP (0%)</strong> - <strong>浮点逻辑指令</strong></li></ol><p>• 处理浮点数的逻辑操作。</p><ol start="21"><li><strong>STTNI (0%)</strong> - <strong>文本处理指令</strong></li></ol><p>• 主要用于字符串匹配。</p><ol start="22"><li><strong>BMI1 (0%) / BMI2 (0%)</strong> - <strong>位操作扩展指令</strong></li></ol><p>• 主要用于高效位操作。</p><p>• 典型指令：PDEP, PEXT。</p><ol start="23"><li><strong>ROTATE (0%)</strong> - <strong>循环移位指令</strong></li></ol><p>• 典型指令：ROL, ROR。</p><p>• 说明代码不涉及循环移位优化。</p><ol start="24"><li><strong>BROADCAST (0%)</strong> - <strong>广播指令</strong></li></ol><p>• 用于 SIMD 数据扩展。</p><p>• VBROADCASTSS。</p><ol start="25"><li><strong>AVX2 (0%)</strong> - <strong>AVX2 指令</strong></li></ol><p>• 比 AVX 更高级的 SIMD 指令。</p><p>• VPACKSSWB, VPMADDWD。</p><ol start="26"><li><strong>LZCNT (0%)</strong> - <strong>前导零计数指令</strong></li></ol><p>• 计数最高位前的零位数。</p><ol start="27"><li><strong>BITBYTE (0%)</strong> - <strong>位和字节操作指令</strong></li></ol><p>• BT, BTS, BTC。</p><ol start="28"><li><strong>SYSCALL (0%)</strong> - <strong>系统调用指令</strong></li></ol><p>• SYSCALL。</p><ol start="29"><li><strong>VFMA (0%)</strong> - <strong>FMA 指令</strong></li></ol><p>• VFMADD132PS，用于 fused multiply-add（FMA）计算。</p><ol start="30"><li><strong>KMASK (0%)</strong> - <strong>掩码寄存器操作</strong></li></ol><p>• 主要用于 AVX-512。</p><ol start="31"><li><strong>RDRAND (0%)</strong> - <strong>随机数生成指令</strong></li></ol><p>• RDRAND，用于硬件随机数生成。</p><hr><p><strong>总结</strong></p><p>• 代码主要是 <strong>数据传输（44%）+ 计算（17%）+ 逻辑判断（14%）</strong>，符合通用计算或控制逻辑密集型应用的特点。</p><p>• 几乎没有 <strong>SIMD（AVX/SSE）</strong>，说明未做高性能矢量化优化。</p><p>• <strong>无 SYSCALL、多线程同步（SEMAPHORE）</strong>，可能是单线程用户态应用。</p><p>• <strong>低 PREFETCH</strong>，说明内存访问优化较少。</p><h2 id="_2-rep-movsb-指令" tabindex="-1"><a class="header-anchor" href="#_2-rep-movsb-指令"><span>2. REP MOVSB 指令</span></a></h2><h3 id="_2-1-rep-movsb-指令解析" tabindex="-1"><a class="header-anchor" href="#_2-1-rep-movsb-指令解析"><span>2.1. REP MOVSB 指令解析</span></a></h3><h4 id="_2-1-1-1-指令基础简介" tabindex="-1"><a class="header-anchor" href="#_2-1-1-1-指令基础简介"><span>2.1.1. <strong>1. 指令基础简介</strong></span></a></h4><ul><li><strong>全称</strong>：Repeat Move String Byte（重复移动字节串）</li><li><strong>功能</strong>：将内存中一段连续的字节数据（字节串）从源地址逐字节复制到目标地址，通过前缀 <code>REP</code>（重复）实现批量操作。</li><li><strong>所属指令集</strong>：x86 汇编语言中的串操作指令（String Operations），适用于 Intel 和 AMD 处理器。</li></ul><h4 id="_2-1-2-指令格式" tabindex="-1"><a class="header-anchor" href="#_2-1-2-指令格式"><span>2.1.2. 指令格式</span></a></h4><ul><li><p><strong>汇编语法</strong>：</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span>REP MOVSB</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>操作数</strong>：</p><ul><li>源串地址：由寄存器 <code>ESI</code>（源变址寄存器，默认对应段寄存器 <code>DS</code>）指向。</li><li>目标串地址：由寄存器 <code>EDI</code>（目标变址寄存器，默认对应段寄存器 <code>ES</code>）指向。</li><li>重复次数：由寄存器 <code>RCX</code>（64 位模式）或 <code>CX</code>（32 位及以下模式）指定，每执行一次 <code>MOVSB</code>，<code>RCX/CX</code> 减 1，直到其值为 0 时停止。</li></ul></li><li><p><strong>方向标志</strong>：由标志位 <code>DF</code>（Direction Flag）控制地址变化方向：</p><ul><li><code>DF=0</code>（默认）：每次操作后 <code>ESI/EDI</code> 递增（适用于正向复制）。</li><li><code>DF=1</code>：每次操作后 <code>ESI/EDI</code> 递减（适用于反向复制，如重叠内存区域的复制）。</li></ul></li></ul><h4 id="_2-1-3-3-执行过程" tabindex="-1"><a class="header-anchor" href="#_2-1-3-3-执行过程"><span>2.1.3. <strong>3. 执行过程</strong></span></a></h4><ol><li><strong>初始化</strong>： <ul><li>设定 <code>ESI</code> 指向源串首地址（或末地址，取决于 <code>DF</code>），<code>EDI</code> 指向目标串首地址（或末地址），<code>RCX/CX</code> 为待复制的字节数。</li></ul></li><li><strong>循环执行</strong>： <ul><li>每次循环执行一次 <code>MOVSB</code>，将 <code>[ESI]</code> 处的字节数据复制到 <code>[EDI]</code> 处。</li><li>根据 <code>DF</code> 更新 <code>ESI</code> 和 <code>EDI</code>（<code>+1</code> 或 <code>-1</code>），<code>RCX/CX</code> 减 1。</li></ul></li><li><strong>终止条件</strong>：当 <code>RCX/CX</code> 减为 0 时，停止执行。</li></ol><h4 id="_2-1-4-4-对标志位的影响" tabindex="-1"><a class="header-anchor" href="#_2-1-4-4-对标志位的影响"><span>2.1.4. <strong>4. 对标志位的影响</strong></span></a></h4><ul><li><code>REP</code> 前缀本身不影响标志位，仅控制循环次数。</li><li><code>MOVSB</code> 指令本身也不改变标志位（串操作指令中，仅 <code>SCASB</code>、<code>CMPSB</code> 等会影响标志位）。</li></ul><h4 id="_2-1-5-5-增强版本-erms-enhanced-rep-movsb-stosb" tabindex="-1"><a class="header-anchor" href="#_2-1-5-5-增强版本-erms-enhanced-rep-movsb-stosb"><span>2.1.5. <strong>5. 增强版本：ERMS（Enhanced REP MOVSB/STOSB）</strong></span></a></h4><ul><li><strong>背景</strong>：现代处理器（如 AMD Zen 系列、Intel Xeon 等）对 <code>REP MOVSB</code> 和 <code>REP STOSB</code>（存储字节串）进行了硬件级优化，称为 <strong>ERMS</strong>（增强型重复串操作）。</li><li><strong>优化点</strong>： <ul><li>支持批量处理多个字节（而非逐字节操作），减少循环开销。</li><li>利用缓存预取技术，提升大块内存复制的效率。</li></ul></li><li><strong>限制</strong>： <ul><li>性能与数据大小、内存对齐方式密切相关。例如，在 AMD Zen3+ 处理器上，当数据大小在默认阈值（如 2113 字节到 524288 字节）时，ERMS 可能因对齐问题导致性能低于向量化指令（如使用 SIMD 指令手动实现的内存复制）。</li></ul></li></ul><h4 id="_2-1-6-6-性能影响因素-结合网页内容" tabindex="-1"><a class="header-anchor" href="#_2-1-6-6-性能影响因素-结合网页内容"><span>2.1.6. <strong>6. 性能影响因素（结合网页内容）</strong></span></a></h4><ol><li><strong>数据大小</strong>： <ul><li>当数据大小在 <code>rep_movsb_threshold</code>（默认 2113 字节）到 <code>rep_movsb_stop_threshold</code>（Zen3 核心 L2 缓存大小，524288 字节）时，glibc 会启用 ERMS。</li><li>超出此范围时，可能切换为向量化指令（如 <code>memcpy</code> 的向量实现）。</li></ul></li><li><strong>内存对齐</strong>： <ul><li>目标地址未对齐（如对齐值为 15 字节）时，ERMS 性能可能大幅下降（网页中数据显示吞吐量从 84GB/s 骤降至 4.4GB/s）。</li></ul></li><li><strong>可调参数</strong>： <ul><li><p>通过环境变量 <code>GLIBC_TUNABLES</code> 调整阈值，例如：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">GLIBC_TUNABLES</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">glibc.cpu.</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">x86_rep_movsb_threshold</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">1000000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可强制对更大数据使用向量化指令，避免 ERMS 在低对齐场景下的性能问题。</p></li></ul></li></ol><h4 id="_2-1-7-7-应用场景" tabindex="-1"><a class="header-anchor" href="#_2-1-7-7-应用场景"><span>2.1.7. <strong>7. 应用场景</strong></span></a></h4><ul><li><strong>内存复制</strong>：用于 <code>memcpy</code> 函数的底层实现（当数据大小适合 ERMS 时）。</li><li><strong>系统调用</strong>：内核或库函数中批量数据移动（如缓冲区拷贝）。</li><li><strong>兼容性</strong>：支持跨架构，但优化效果因处理器型号而异（如 Zen3+ 与 Intel Xeon 的 ERMS 实现不同）。</li></ul><h4 id="_2-1-8-总结" tabindex="-1"><a class="header-anchor" href="#_2-1-8-总结"><span>2.1.8. 总结</span></a></h4><p><code>REP MOVSB</code> 是 x86 架构中高效批量复制字节数据的指令，配合 <code>ERMS</code> 优化可提升大块内存操作性能。但在特定硬件（如 AMD Zen3+）和数据场景（小尺寸、未对齐）下，可能因阈值设置或硬件特性导致性能瓶颈，需通过可调参数或代码优化（如手动向量化）规避。实际开发中，需结合硬件架构和工作负载选择最优策略。</p>',98)]))}const a=d(s,[["render",e]]),g=JSON.parse('{"path":"/architecture/x86_inst.html","title":"Instructions of x86","lang":"zh-CN","frontmatter":{"title":"Instructions of x86","date":"2025-03-19T00:00:00.000Z","description":"1. 指令类型 1.1. 指令占比概览 1.2. 指令类型及占比 以下是业务中各类指令的占比情况： 1.3. 高占比指令 DATAXFER (44%) - 数据传输指令：负责在寄存器、内存和堆栈之间传输数据。 典型指令：MOV, LEA, XCHG。 高占比表明代码数据移动频繁，可能涉及大量内存访问或寄存器间数据交换。 BINARY (17%) - 算...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Instructions of x86\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-19T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-07T09:27:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Someone\\",\\"url\\":\\"https://www.weigao.cc\\"}]}"],["meta",{"property":"og:url","content":"https://vueblog.weigao.cc/architecture/x86_inst.html"}],["meta",{"property":"og:site_name","content":"weigao"}],["meta",{"property":"og:title","content":"Instructions of x86"}],["meta",{"property":"og:description","content":"1. 指令类型 1.1. 指令占比概览 1.2. 指令类型及占比 以下是业务中各类指令的占比情况： 1.3. 高占比指令 DATAXFER (44%) - 数据传输指令：负责在寄存器、内存和堆栈之间传输数据。 典型指令：MOV, LEA, XCHG。 高占比表明代码数据移动频繁，可能涉及大量内存访问或寄存器间数据交换。 BINARY (17%) - 算..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-07T09:27:16.000Z"}],["meta",{"property":"article:published_time","content":"2025-03-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-07T09:27:16.000Z"}]]},"git":{"createdTime":1746610036000,"updatedTime":1746610036000,"contributors":[{"name":"weigao","username":"weigao","email":"weigao.cwg","commits":1,"url":"https://github.com/weigao"}]},"readingTime":{"minutes":8.21,"words":2462},"filePathRelative":"architecture/x86_inst.md","excerpt":"<h2>1. 指令类型</h2>\\n<h3>1.1. 指令占比概览</h3>\\n<h3>1.2. 指令类型及占比</h3>\\n<p>以下是业务中各类指令的占比情况：</p>\\n<table>\\n<thead>\\n<tr>\\n<th>指令类别</th>\\n<th>占比 (%)</th>\\n<th>指令类别</th>\\n<th>占比 (%)</th>\\n<th>指令类别</th>\\n<th>占比 (%)</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>数据传输 (DATAXFER)</td>\\n<td>44.00</td>\\n<td>算术运算 (BINARY)</td>\\n<td>17.00</td>\\n<td>条件跳转 (COND_BR)</td>\\n<td>14.00</td>\\n</tr>\\n<tr>\\n<td>逻辑运算 (LOGICAL)</td>\\n<td>7.00</td>\\n<td>移位操作 (SHIFT)</td>\\n<td>4.00</td>\\n<td>其他 (MISC)</td>\\n<td>3.00</td>\\n</tr>\\n<tr>\\n<td>空操作 (NOP)</td>\\n<td>2.00</td>\\n<td>出栈 (POP)</td>\\n<td>1.00</td>\\n<td>入栈 (PUSH)</td>\\n<td>1.00</td>\\n</tr>\\n<tr>\\n<td>无条件跳转 (UNCOND_BR)</td>\\n<td>1.00</td>\\n<td>函数调用 (CALL)</td>\\n<td>1.00</td>\\n<td>函数返回 (RET)</td>\\n<td>1.00</td>\\n</tr>\\n<tr>\\n<td>矢量扩展 (AVX)</td>\\n<td>1.00</td>\\n<td>宽 NOP (WIDENOP)</td>\\n<td>1.00</td>\\n<td>数据预取 (PREFETCH)</td>\\n<td>0.00</td>\\n</tr>\\n<tr>\\n<td>条件移动 (CMOV)</td>\\n<td>0.00</td>\\n<td>SSE 指令 (SSE)</td>\\n<td>0.00</td>\\n<td>条件设置 (SETCC)</td>\\n<td>0.00</td>\\n</tr>\\n<tr>\\n<td>信号量 (SEMAPHORE)</td>\\n<td>0.00</td>\\n<td>数据转换 (CONVERT)</td>\\n<td>0.00</td>\\n<td>字符串操作 (STRINGOP)</td>\\n<td>0.00</td>\\n</tr>\\n<tr>\\n<td>浮点逻辑 (LOGICAL_FP)</td>\\n<td>0.00</td>\\n<td>文本处理 (STTNI)</td>\\n<td>0.00</td>\\n<td>位操作扩展 (BMI1)</td>\\n<td>0.00</td>\\n</tr>\\n<tr>\\n<td>循环移位 (ROTATE)</td>\\n<td>0.00</td>\\n<td>广播 (BROADCAST)</td>\\n<td>0.00</td>\\n<td>高级矢量扩展 (AVX2)</td>\\n<td>0.00</td>\\n</tr>\\n<tr>\\n<td>前导零计数 (LZCNT)</td>\\n<td>0.00</td>\\n<td>位/字节操作 (BITBYTE)</td>\\n<td>0.00</td>\\n<td>系统调用 (SYSCALL)</td>\\n<td>0.00</td>\\n</tr>\\n<tr>\\n<td>FMA 指令 (VFMA)</td>\\n<td>0.00</td>\\n<td>位操作扩展 (BMI2)</td>\\n<td>0.00</td>\\n<td>掩码寄存器 (KMASK)</td>\\n<td>0.00</td>\\n</tr>\\n<tr>\\n<td>随机数生成 (RDRAND)</td>\\n<td>0.00</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{a as comp,g as data};
