import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as p,a as n,b as a,d as i,f as c}from"./app-22cda79c.js";const l={},r=c(`<h1 id="spring" tabindex="-1"><a class="header-anchor" href="#spring" aria-hidden="true">#</a> Spring</h1><h2 id="什么是-spring" tabindex="-1"><a class="header-anchor" href="#什么是-spring" aria-hidden="true">#</a> 什么是 spring？</h2><ol><li>Spring 在创立之初是一个轻量级的 java 开源开发框架（轻量相对于J2EE EJB而言，其实 spring 也是比较大了），其提出是为了解决企业应用开发的复杂性而创建的，spring 可以更加快速、简单的构建应用，在目前是最受欢迎的 java 框架。</li><li>其设计理念在于分层架构思想，分层架构使得开发者可以自由选择要使用的组件。</li><li>Spring 的核心优势在于其可以无缝集成主流开发框架，只需通过配置和简单的对象注入。</li></ol><p>Spring 的两个核心特性：IoC 和 AOP（控制反转和面向切面编程）</p><h2 id="ioc" tabindex="-1"><a class="header-anchor" href="#ioc" aria-hidden="true">#</a> IoC</h2><h3 id="什么是-ioc" tabindex="-1"><a class="header-anchor" href="#什么是-ioc" aria-hidden="true">#</a> 什么是 IoC?</h3><p>IoC 指的是控制反转，有些时候可以理解和依赖注入一个关系, IOC 是一种设计思想，将原本程序手中控制对象创建的权力，交给框架来管理；IOC 容器是实现 IOC 的载体，实际上底层就是一个 Map, 其中存放着各种对象。</p><ul><li>容器概念：IOC 容器中存放着各种对象。在项目启动的时候，根据配置文件读取 beans, 然后通过反射放到容器里面，此时容器中就有各种对象了，后面会在需要的时候进行依赖注入。</li><li>控制反转：没有引入 IOC 容器的时候，对象的创建存在依赖；引入以后，对象之间失去了联系，而是在需要使用某对象的时候，由 IOC 主动创建并注入。</li></ul><h3 id="bean-的注册" tabindex="-1"><a class="header-anchor" href="#bean-的注册" aria-hidden="true">#</a> bean 的注册</h3><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 返回 IOC 容器，基于 XML配置，传入配置文件的位置</span>
<span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;xxx.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="applicationcontext-和-beanfactory" tabindex="-1"><a class="header-anchor" href="#applicationcontext-和-beanfactory" aria-hidden="true">#</a> ApplicationContext 和 BeanFactory</h3><p>通过上面的代码，问问题：ApplicationContext 和 BeanFactory 的区别是什么？</p><p>回答：</p><ol><li>ApplicationContext 是 BeanFactory 的子接口；</li><li>BeanFactory 通过延迟加载的方式来注入 bean, ApplicationContext 是在容器启动时就一次性创建了所有的 bean；</li><li>ApplicationContext 提供了更完整的功能，如统一的资源文件访问方式、支持国际化、同时加载多个配置文件等。</li></ol><h3 id="bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#bean-的生命周期" aria-hidden="true">#</a> bean 的生命周期</h3><p>@todo</p><h3 id="spring-bean-的作用域" tabindex="-1"><a class="header-anchor" href="#spring-bean-的作用域" aria-hidden="true">#</a> Spring bean 的作用域</h3><ul><li>singleton 单例</li><li>prototype</li><li>request</li><li>session</li><li>global-session(Spring 5 以后废弃)</li></ul><h4 id="spring-singleton-是线程安全吗" tabindex="-1"><a class="header-anchor" href="#spring-singleton-是线程安全吗" aria-hidden="true">#</a> Spring singleton 是线程安全吗？</h4><p>不是。bean 可以分为有状态对象 stateful bean 和无状态对象 stateless bean, 有状态对象保存有实例变量，有数据，不是线程安全的；</p><p>对于单例 bean, 存在多个线程共享这个 bean 的实例，如果是一个无状态 bean, 那么各个线程不会对这个 bean 进行查询以外的操作，这时候是线程安全的。如果是有状态 bean, 这时候存在资源的竞争。</p><p>如何避免？</p><ol><li>可以通过 <code>ThreadLocal</code> 来解决线程安全的问题，因为 <code>ThreadLocal</code> 为每个线程保存线程私有的数据。</li><li>定义无状态 bean(实际生产中较难)。</li></ol><h2 id="aop" tabindex="-1"><a class="header-anchor" href="#aop" aria-hidden="true">#</a> AOP</h2><h3 id="什么是-aop" tabindex="-1"><a class="header-anchor" href="#什么是-aop" aria-hidden="true">#</a> 什么是 AOP?</h3><p>AOP 是面向切面编程的意思。其思想在于把与业务无关的，各个业务模块可以公用的模块（如日志、事务、异步调用等）封装起来，减少重复代码、降低耦合，其相关的设计模式为代理模式。</p><p>Spring AOP 基于动态代理实现。对于已经实现的接口，JDK 可以动态代理去创建代理对象；如果该对象没有实现接口，那么会使用 CGlib 动态代理生成一个代理的子类来作为代理。</p><h3 id="enableaspectjautoproxy" tabindex="-1"><a class="header-anchor" href="#enableaspectjautoproxy" aria-hidden="true">#</a> @EnableAspectJAutoProxy</h3><p><code>@Enable</code> 模块：<code>@Enable</code> 模块驱动注解 <code>EnableAspectJAutoProxy</code> 用于开启 AspectJ 自动代理。</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">AspectJAutoProxyRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableAspectJAutoProxy</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">proxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">exposeProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>AspectJAutoProxyRegistrar</code> 为一个 <code>AspectJ</code> 自动代理注册器，通过 <code>@import</code> 注解导入。</p><h2 id="如何解决循环依赖" tabindex="-1"><a class="header-anchor" href="#如何解决循环依赖" aria-hidden="true">#</a> 如何解决循环依赖？</h2><h3 id="循环依赖与-ioc" tabindex="-1"><a class="header-anchor" href="#循环依赖与-ioc" aria-hidden="true">#</a> 循环依赖与 IoC</h3><blockquote><p>类与类之间的依赖关系形成了闭环，就会导致循环依赖问题的产生。</p></blockquote><p>通过 Spring IOC 流程的源码分析循环依赖问题：</p><ol><li>先从缓存中获取，获取不到则继续往下走</li><li>实例化 Class A</li><li>依赖注入 Class A 对象的成员变量（setter） -- 注意到此时辉产生循环依赖</li><li>初始化 Class A（初始化方法）</li><li>将 Class A 的引用放入一级缓存</li></ol><p>循环依赖的三种情况：</p><ol><li>通过构造方法进行依赖注入的时候产生的循环依赖</li><li>通过 setter 方法进行依赖注入的时候产生的循环依赖（多例模式下）</li><li><strong>通过 setter 方法进行依赖注入的时候产生的循环依赖（单例模式下）-- Spring 解决了这种场景下循环依赖的问题</strong></li></ol><p>构造方法进行依赖主语的时候，new 对象的时候就阻塞住了。而多例的循环依赖每次 <code>getBean()</code> 时，都会产生一个新的 bean, 最终导致 OOM 发生。</p><h3 id="spring-三大缓存" tabindex="-1"><a class="header-anchor" href="#spring-三大缓存" aria-hidden="true">#</a> Spring 三大缓存</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>Spring 解决循环依赖主要是通过两个缓存。总的来说，Spring 有三大缓存：一级缓存 singletonObjects, 二级缓存 earlySingletonObjects 和三级缓存 singletonFactories.</p></div><h4 id="一级缓存-singletonobjects" tabindex="-1"><a class="header-anchor" href="#一级缓存-singletonobjects" aria-hidden="true">#</a> 一级缓存 singletonObjects</h4><ol><li>对容器外提供单例 bean 的存储功能</li><li>非创建中的 bean 才会被存储在该缓存</li></ol><h4 id="二级缓存-earlysingletonobjects" tabindex="-1"><a class="header-anchor" href="#二级缓存-earlysingletonobjects" aria-hidden="true">#</a> 二级缓存 earlySingletonObjects</h4><p>主要是存储原生的早期 bean.</p><ol><li>用于存储单例模式下创建的 bean 实例（该 bean 还在创建中）</li><li>该缓存对内使用，Spring 内部的框架裸机使用该缓存</li></ol><h4 id="三级缓存-singletonfactories" tabindex="-1"><a class="header-anchor" href="#三级缓存-singletonfactories" aria-hidden="true">#</a> 三级缓存 singletonFactories</h4><p>主要是存储代理的 bean.</p>`,48),d={href:"https://juejin.cn/post/6895753832815394824",target:"_blank",rel:"noopener noreferrer"};function u(h,k){const s=t("ExternalLinkIcon");return o(),p("div",null,[r,n("p",null,[a("参考："),n("a",d,[a("https://juejin.cn/post/6895753832815394824"),i(s)]),a(" 继续书写。")])])}const x=e(l,[["render",u],["__file","spring.html.vue"]]);export{x as default};
