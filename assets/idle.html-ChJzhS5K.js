import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,d as i,e as n,r as t,o as h}from"./app-11Vuyqh7.js";const p={};function k(d,s){const a=t("Mermaid");return h(),l("div",null,[s[0]||(s[0]=i('<h2 id="_1-abstract" tabindex="-1"><a class="header-anchor" href="#_1-abstract"><span>1. Abstract</span></a></h2><p>本文主要研究 kernel 中的 idle 机制以及代码实现。</p><h2 id="_2-x86-idle-state" tabindex="-1"><a class="header-anchor" href="#_2-x86-idle-state"><span>2. x86 idle state</span></a></h2><p>来看一下 x86 的 idle state：</p><p>C-state 描述的是 CPU 处于空闲时的不同睡眠状态，包括 POLL C1 C1E和C6，它们统称为 C-states。CPU 的每种睡眠状态都消耗不同的功耗，并且对应用程序性能的影响也不同。这些状态的睡眠深度排序为 C6 &gt; C1E &gt; C1 &gt; POLL。</p><p>POLL 状态表示 CPU 不睡眠，一直空跑或执行指令，这种状态下 CPU 性能最好，功耗也最大。</p><p>C1 状态是 CPU 的基本睡眠状态。当 CPU 没有任务需要处理时，会进入这个状态。这种状态下，CPU 的大部分电路会停止工作，从而降低功耗，但 CPU 可以迅速唤醒以继续处理任务。</p><p><mark>C1E（Enhanced C1）</mark> 是 C1 状态的增强，进一步提高了节能效果。在 C1E 状态下，CPU 可以<strong>动态降低其频率和电压</strong>，以达到更低的功耗。</p><p>C6 状态是一个更深的节能状态，通常能将 CPU 的功耗进一步降低到非常低的水平。在这个状态下，CPU 的核心可能会关闭电源，从而实现更显著的节能效果。</p><p>当 CPU 从一个更深的 C-state 返回到运行状态时，CPU 被唤醒的时间也更长，对应用程序性能影响也更大。</p><table><thead><tr><th><strong>状态</strong></th><th><strong>描述</strong></th><th><strong>延迟</strong></th><th><strong>功耗</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>C0</strong></td><td>工作状态（非 Idle）</td><td>0</td><td>高</td><td>CPU 正在运行任务，不是空闲状态</td></tr><tr><td><strong>C1</strong></td><td>第一个 Idle 状态</td><td>低</td><td>中</td><td>快速响应，可立即唤醒</td></tr><tr><td><strong>C1E</strong></td><td>C1 Enhanced（增强型 C1）</td><td>低</td><td>更低</td><td>在 C1 的基础上降低电压/频率（一般 BIOS 控制）</td></tr><tr><td><strong>C2</strong></td><td>更深层 Idle</td><td>中</td><td>更低</td><td>延迟略高于 C1，现代系统中不常见</td></tr><tr><td><strong>C3</strong></td><td>停止 L2 缓存</td><td>更高</td><td>更低</td><td>停止更多组件，唤醒延迟变大</td></tr><tr><td><strong>C6</strong></td><td>Save 内核状态并切断供电</td><td>高</td><td>极低</td><td>将核心寄存器状态写入内存，彻底切断电源</td></tr><tr><td><strong>C7</strong></td><td>更深的 Idle，比 C6 更激进</td><td>非常高</td><td>最低</td><td>只有现代架构支持，如 Haswell/Broadwell 等</td></tr><tr><td><strong>POLL</strong></td><td>短暂空转等待状态（不是省电）</td><td>极低</td><td>高</td><td>通常为驱动内部逻辑，不建议启用为省电手段</td></tr></tbody></table><p>对比一下 C1E 和 C6 state 的区别：</p><table><thead><tr><th><strong>特性</strong></th><th><strong>C1E</strong></th><th><strong>C6</strong></th></tr></thead><tbody><tr><td>功能</td><td>类似 C1，但更进一步降低电压/频率</td><td>将 CPU 核心电源关闭，状态写入内存</td></tr><tr><td>响应速度</td><td>非常快（&lt;10 微秒）</td><td>慢得多（&gt;100 微秒）</td></tr><tr><td>适用场景</td><td>高频次短暂 idle（频繁进出）</td><td>长时间空闲或低负载系统</td></tr><tr><td>由谁控制</td><td>多数时候由 BIOS 启用</td><td>由操作系统 + 硬件协同控制</td></tr><tr><td>对性能影响</td><td>非常小，几乎无影响</td><td>可能影响延迟敏感任务，尤其是高频唤醒场景</td></tr><tr><td>是否推荐开启</td><td>通常推荐开启</td><td>HPC / 低延迟场景建议关闭以减少唤醒延迟</td></tr></tbody></table><p>如果需要查看当下支持的 idle 状态：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">cpupower</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;"> idle-info</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;"> /sys/devices/system/cpu/cpu0/cpuidle/state</span><span style="--shiki-light:#005CC5;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">/name</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_3-function-flow" tabindex="-1"><a class="header-anchor" href="#_3-function-flow"><span>3. Function Flow</span></a></h2><p>我们先对大体上的函数调用栈进行一个简单的示意图总结：</p>',19)),n(a,{id:"mermaid-289",code:"eJxdkLsOgyAUhnefwhEHTap7k3rrC3RrGkLhGE2JWMA0vn3haEstA8P//RdCJ9WL90zb+FJHsTunqwGuRsH0Qo11gD5AjyBvcZoe45LwaV71eaIwWr0kGCsRV0QoOggJq1ihWBOpOJN00E8qBsPufzgnTPOe+mIf9a2gd47CryLDy5XJldcFGprD12BAArd7mhOf8APhaU2+sRD92f0kw7CGLhS7FPJ2n/X/Yrf+Fg1nkmVZEr0BlYBn0g=="}),s[1]||(s[1]=i(`<p>cpuidle_enter_state() 之后的流程可以参考 tick_broadcast_oneshot_control() 的分析。</p><h2 id="_4-cpu-startup-entry" tabindex="-1"><a class="header-anchor" href="#_4-cpu-startup-entry"><span>4. cpu_startup_entry</span></a></h2><p>笔者在实际的业务场景中抓取过 idle 函数的调用栈，大概如下所示：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span>[] [pid:0,cpu6,swapper/6,0] show_stack+0x14/0x1c</span></span>
<span class="line"><span>[] [pid:0,cpu6,swapper/6,1] dump_stack_lvl+0xb8/0x108</span></span>
<span class="line"><span>[] [pid:0,cpu6,swapper/6,2] dump_stack+0x14/0x1c</span></span>
<span class="line highlighted"><span>[] [pid:0,cpu6,swapper/6,3] cpuidle_select+0x20/0x54</span></span>
<span class="line"><span>[] [pid:0,cpu6,swapper/6,4] 0xffffffe55f4d072c</span></span>
<span class="line highlighted"><span>[] [pid:0,cpu6,swapper/6,5] cpu_startup_entry+0x20/0x24</span></span>
<span class="line highlighted"><span>[] [pid:0,cpu6,swapper/6,6] secondary_start_kernel+0x1e8/0x208</span></span>
<span class="line"><span>[] [pid:0,cpu6,swapper/6,7]CPU: 6 PID: 0 Comm: swapper/6 VIP: 00</span></span>
<span class="line"><span>[] [pid:0,cpu6,swapper/6,8]TGID: 0 Comm: swapper/6</span></span>
<span class="line"><span>[] [pid:0,cpu6,swapper/6,9]Hardware name: xxx (DT)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一个很关键的调用栈，我们可以看到 <code>cpu_startup_entry</code> 会调用到 <code>cpuidle_select</code>, 在图中进行了高亮。</p><p><code>start_kernel</code> → <code>rest_init</code> → <code>cpu_startup_entry</code>, 基本的调用关系可以如此理解，看 <code>cpu_startup_entry</code> 的实现：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">// in kernel/linux-5.10/kernel/sched/idle.c</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> cpu_startup_entry</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuhp_state </span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	arch_cpu_idle_prepare</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	cpuhp_online_idle</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	while</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		do_idle</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">cpu_startup_entry 流程</p><ul><li><code>void cpu_startup_entry(enum cpuhp_state state)</code><ul><li><code>arch_cpu_idle_prepare()</code>，进行 idle 前的准备工作，ARM64 中没有实现 <ul><li>cpu idle loop: 进入 cpuidle 的主循环；在上面代码中体现为 while loop <ul><li>…</li><li><em>下面的流程见 <code>do_idle()</code></em></li></ul></li></ul></li></ul></li></ul></div><p>也就是说，idle 线程执行的时候，是一直在运行这个 <code>do_idle()</code> 的。</p><h2 id="_5-do-idle" tabindex="-1"><a class="header-anchor" href="#_5-do-idle"><span>5. do_idle</span></a></h2><p><code>do_idle()</code> 会执行 CPU idle 的主要操作。</p><div class="hint-container note"><p class="hint-container-title">cpu_idle_loop 调用流程 static void do_idle(void)</p><ul><li><p><code>__current_set_polling()</code>: 后续研究</p></li><li><p><code>tick_nohz_idle_enter()</code>: 后续研究</p></li><li><p>如果系统当前不需要调度（<code>while (!need_resched())</code>），执行后续的动作</p><ul><li><p>local_irq_disable()，关闭 irq 中断</p></li><li><p>arch_cpu_idle_enter()，arch 相关的 cpuidle enter，ARM64 中没有实现</p></li><li><p><strong>cpuidle_idle_call()</strong>，main idle function</p><ul><li>cpuidle_select，通过 cpuidle governor，选择一个 cpuidle state</li><li>cpuidle_enter，通过 cpuidle state，进入该 idle 状态</li><li>…</li><li>中断产生，idle 返回（注意，此时irq是被禁止的，因此CPU不能响应产生中断的事件）</li><li>cpuidle_reflect，通知 cpuidle governor，更新状态</li><li>local_irq_enable，使能中断，响应中断事件，跳转到对应的中断处理函数</li><li>…</li></ul></li></ul></li><li><p>arch_cpu_idle_exit，和 enter 类似，ARM64没有实现</p></li></ul></div><h2 id="_6-local-irq-dis-en-able" tabindex="-1"><a class="header-anchor" href="#_6-local-irq-dis-en-able"><span>6. local_irq_dis(en)able</span></a></h2><p>这个函数涉及到中断处理的相关操作，<code>local_irq_disable()</code> 会禁止本地中断的传递，在这个地方有 4 个相似的接口，可以加以区分便于使用：</p><table><thead><tr><th style="text-align:center;">函数</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">local_irq_disable()</td><td style="text-align:center;">禁止本地中断传递</td></tr><tr><td style="text-align:center;">local_irq_enable()</td><td style="text-align:center;">激活本地中断传递（无条件激活中断）</td></tr><tr><td style="text-align:center;">local_irq_save()</td><td style="text-align:center;">保存本地中断传递的当前状态，然后禁止本地中断传递</td></tr><tr><td style="text-align:center;">local_irq_restore()</td><td style="text-align:center;">恢复本地中断传递到更定的状态</td></tr></tbody></table><p>通常而言，我们会使用 <code>local_irq_save()</code> 和 <code>local_irq_restore()</code> 配合使用，这样做的好处在于：我们在此之前并不知道本地中断是开启还是关闭的，如果要使我们的代码对中断的原始状态不做过多的影响，用这两个接口是非常合适的。再多说一些，<code>local_irq_enable()</code> 是会无条件激活中断的，尽管这个中断可能在开始时就是关闭的。</p><p>再回到禁止中断这个事情本身，通过禁止中断，可以确保某个中断处理程序不会抢占当前的代码；此外，禁止中断还可以禁止内核抢占。但是需要注意的是，禁止中断并不能避免来自其他处理器的并发访问（使用锁来防止并发访问，或者使用核独占的数据结构）。</p><p>实现禁止中断只需要使用一条汇编指令即可，在 arm64 中使用的是 <code>msr daifclr, #2</code> 来禁止中断。</p><h2 id="_7-cpuidle-idle-call" tabindex="-1"><a class="header-anchor" href="#_7-cpuidle-idle-call"><span>7. cpuidle_idle_call</span></a></h2><p>在外围对是否进入该函数有一个判断：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">cpu_idle_force_poll </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> tick_check_broadcast_expired</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">())</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">    tick_nohz_idle_restart_tick</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">    cpu_idle_poll</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> else</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">    cpuidle_idle_call</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>cpu_idle_force_poll</code> 表示是否开启强制轮询模式，关于 idle polling 可以见下面章节的描述；</p><p><code>tick_check_broadcast_expired</code> 表示 tick 是否过期需要重新开始以免进入深度睡眠。</p><p>在进入 cpuidle_idle_call 之后，会有一段较长的逻辑：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> cpuidle_idle_call</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">	// ...</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">need_resched</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">())</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		local_irq_enable</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">cpuidle_not_available</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">))</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		tick_nohz_idle_stop_tick</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		default_idle_call</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		goto</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> exit_idle</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">idle_should_enter_s2idle</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;"> dev</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">forced_idle_latency_limit_ns</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">		// ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		call_cpuidle</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> next_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> else</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">		next_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> cpuidle_select</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">stop_tick</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">stop_tick </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> tick_nohz_tick_stopped</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">())</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">			tick_nohz_idle_stop_tick</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		else</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">			tick_nohz_idle_retain_tick</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">		entered_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> call_cpuidle</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> next_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		cpuidle_reflect</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> entered_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">exit_idle:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	__current_set_polling</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">	// ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们去除了一些复杂细节，专注于我们的主体流程研究。</p><p>cpuidle_idle_call 函数刚开始，先是两个判断：</p><ol><li>need_resched(): 是否有任务过来需要调度？</li><li>cpuidle_not_available(drv, dev): 驱动是否支持？</li></ol><p>这两个判断的结果比较明显，分支预测准确的概览也较大。</p><p>接下来的流程就是进行判断，根据策略的不同走不同的分支，最终都会调用到函数 call_cpuidle.</p><h2 id="_8-call-cpuidle" tabindex="-1"><a class="header-anchor" href="#_8-call-cpuidle"><span>8. call_cpuidle</span></a></h2><p>该函数的逻辑比较简单，就是一些特殊情况的判断，而后进行 <strong>cpuidle_enter</strong> 函数的调用：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> call_cpuidle</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_driver </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_device </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		      int</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;"> next_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">current_clr_polling_and_test</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">())</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">		// ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		return</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">EBUSY</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> cpuidle_enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> next_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cpuidle_enter 的逻辑也是非常简单，进行一个判断：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> cpuidle_enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_driver </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_device </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		  int</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">	// ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">cpuidle_state_is_coupled</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">))</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">		ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> cpuidle_enter_state_coupled</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	else</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">		ret </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> cpuidle_enter_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">	</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> ret</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论哪种情况，都是会进行 cpuidle_enter_state 函数的调用。</p><h2 id="_9-cpuidle-enter-state" tabindex="-1"><a class="header-anchor" href="#_9-cpuidle-enter-state"><span>9. cpuidle_enter_state()</span></a></h2><blockquote><p>函数位置：kernel/linux-5.10/drivers/cpuidle/cpuidle.c</p></blockquote><p>为了方便我们理解记忆，将该函数进行分解：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> cpuidle_enter_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_device </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_driver </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">			int</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">index </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">	broadcast </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> !!</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">target_state</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">flags</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> CPUIDLE_FLAG_TIMER_STOP</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">broadcast </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">&amp;&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> tick_broadcast_enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">())</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">		// maybe return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">target_state</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">flags</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> CPUIDLE_FLAG_TLB_FLUSHED</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		leave_mm</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">target_state</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">flags</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> CPUIDLE_FLAG_RCU_IDLE</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		rcu_idle_enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">	entered_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;"> target_state</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">target_state</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">flags</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> CPUIDLE_FLAG_RCU_IDLE</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		rcu_idle_exit</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">	/* The cpu is no longer idle or about to enter idle. */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	sched_idle_set_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#81A1C1;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">broadcast</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">		</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">cpuidle_state_is_coupled</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		local_irq_enable</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">entered_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">		</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> else</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> entered_state</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数核心的逻辑是进入给定 index 的 idle 状态 <code>target_state-&gt;enter(dev, drv, index);</code>, 然后将这个状态返回；但是在实际的实现中，因为涉及到中断、tick、配置等逻辑，所以比较复杂。</p><p>下文是对代码中细节和原理的研究：</p><h3 id="_9-1-broadcast" tabindex="-1"><a class="header-anchor" href="#_9-1-broadcast"><span>9.1. broadcast</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">broadcast </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> !!</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">target_state</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> CPUIDLE_FLAG_TIMER_STOP</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这行代码的作用是设置一个广播标志，判断是否需要停止定时器。其中，target_state 是一个指向 cpuidle_state 结构体的指针，该结构体描述了 CPU 的空闲状态，包括状态标识、所需的底层硬件支持、进入和退出该状态所需的操作等信息。</p><p>具体来说，target_state-&gt;flags 是一个位掩码，用于描述该空闲状态标识的一些特定属性。&amp;运算符将该位掩码与 CPUIDLE_FLAG_TIMER_STOP 逐位进行 AND 运算，结果非零则表示 target_state 的 flags 属性中存在 CPUIDLE_FLAG_TIMER_STOP 标志，即需要停止定时器。<em>!!</em> 运算符则将结果转换为布尔类型，确保在任何情况下返回的都是 0 或 1 的布尔值，而不是整型数值（双重否定表示肯定）。</p><p>因此，这行代码最终会将广播标志设置为 true 或 false，表示需要或不需要停止定时器。在 CPU 进入空闲状态之前，内核会根据广播标志来决定是否向其他 CPU 广播空闲状态，并通知它们停止当前正在运行的定时器。</p><p>简单来说，如果 local timer 关闭的话（进入更深层次的 idle 状态），就需要使用 broadcast.</p><h3 id="_9-2-cpuidle-flag-tlb-flushed" tabindex="-1"><a class="header-anchor" href="#_9-2-cpuidle-flag-tlb-flushed"><span>9.2. CPUIDLE_FLAG_TLB_FLUSHED</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">target_state</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> CPUIDLE_FLAG_TLB_FLUSHED</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">    leave_mm</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的作用是，<strong>在CPU进入指定的空闲状态之前检查该状态是否需要刷新TLB</strong>，并在必要时执行离开当前进程的操作。（从实测的数据来看，基本上没有刷新 TLB 的操作，这段逻辑很少被执行）</p><p>其中，target_state 是一个指向 cpuidle_state 结构体的指针，描述了要进入的空闲状态，包括状态标识、所需的底层硬件支持和进入该状态所需的操作等信息。flags 字段表示该状态的一些特殊属性，如 CPUIDLE_FLAG_TLB_FLUSHED，表示在进入该状态前需要刷新 TLB（Translation Lookaside Buffer）。</p><p>如果检测到目标状态需要刷新 TLB，则调用 <code>leave_mm(dev-&gt;cpu)</code> 函数执行离开当前进程的操作。该函数的作用是在该 CPU 上的所有进程中暂停当前进程，并切换到空闲进程，以便操作系统在进入空闲状态之前刷新 TLB 高速缓存。</p><p>总之，这段代码的作用是确保在进入特定的空闲状态之前清除 TLB 以避免任何不必要的冲突，同时保证进程能够正确地切换。</p><h3 id="_9-3-sched-idle-set-state" tabindex="-1"><a class="header-anchor" href="#_9-3-sched-idle-set-state"><span>9.3. sched_idle_set_state</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">/* Take note of the planned idle state. */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">sched_idle_set_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">target_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">// 其实现如下：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> sched_idle_set_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">idle_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	idle_set_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">this_rq</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(),</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> idle_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的作用是将当前 CPU 切换到指定的空闲状态，也就是进入一种较低功耗的状态以进行省电。注意到在我们的 cpuidle_enter_state 流程中，这个 sched_idle_set_state 函数被两次调用：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">/* Take note of the planned idle state. */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">sched_idle_set_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">target_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">/* The cpu is no longer idle or about to enter idle. */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">sched_idle_set_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#81A1C1;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>sched_idle_set_state</code> 是一个内核函数，用于设置当前 CPU 的空闲状态，并让 CPU 进入相应的空闲状态。target_state 是一个指向 cpuidle_state 结构体的指针，描述了要进入的空闲状态，包括状态标识、所需的底层硬件支持和进入该状态所需的操作等信息。</p><p><code>this_rq()</code> 表示<em>当前 CPU 所在的 CPU 运行队列</em>（runqueue），它的返回值是一个指向 <code>struct rq</code> 结构体的指针，该结构体描述了 CPU 调度器的运作情况和统计信息。</p><p>在调用该函数之前，内核通常会执行一些准备工作，如停止定时器、暂停当前进程、刷新 TLB 等。接着，调用该函数将当前 CPU 切换到目标状态，并执行目标状态所需的操作，如关闭某些设备、降低 CPU 主频等。</p><p>整个过程是由内核负责管理和控制的，程序员无法直接控制。当系统需要重新唤醒 CPU 时，内核会根据 CPU 的中断或事件触发来驱动 CPU 从空闲状态中返回，并恢复相关的设备和资源。</p><h3 id="_9-4-rcu-idle-enter" tabindex="-1"><a class="header-anchor" href="#_9-4-rcu-idle-enter"><span>9.4. rcu_idle_enter</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">target_state</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> CPUIDLE_FLAG_RCU_IDLE</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">    rcu_idle_enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码用于判断当前进入空闲状态的目标状态是否需要进行<strong>RCU（Read-Copy-Update）空闲处理</strong>，如果需要，则调用 <code>rcu_idle_enter</code> 函数进行 RCU 空闲处理。</p><p>在Linux内核中，RCU是一种无锁机制，用于在多个进程间共享数据。当一个进程需要修改共享数据时，该进程会先创建出一个新的副本，对其进行修改，然后将新副本加入到RCU保护区中。此时，其他进程仍然可以访问旧的副本，不会受到影响。当所有对旧副本的访问都结束后，RCU保护区才会被清空，新副本才会变成有效的数据。</p><p>在进入空闲状态时，如果当前CPU正在进行RCU更新操作，就需要进行RCU空闲处理，即等待所有正在使用旧副本的进程完成访问后，再进行新副本的更新。这样一来，就可以避免数据的冲突和不一致性。</p><p>rcu_idle_enter函数用于启动RCU空闲处理，并进入RCU空闲状态。该函数会将当前CPU所在的调度器的状态设置为RCU空闲状态，然后等待所有正在使用旧副本的进程访问完毕，直到RCU保护区被清空。在此期间，该CPU不会执行任何其他任务，以避免对正在访问旧副本的进程产生干扰。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> rcu_idle_enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	lockdep_assert_irqs_disabled</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	rcu_eqs_enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#81A1C1;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>rcu_idle_enter</code> 函数是用于启动RCU空闲处理并进入RCU空闲状态的函数。</p><p>其中，<code>lockdep_assert_irqs_disabled</code> 函数用于断言<strong>当前中断已经被禁止</strong>，在RCU空闲处理期间不会被重新打开。该函数会在执行时检查当前是否处于内核锁定状态，并通过锁依赖机制确保锁的正确性。如果当前存在锁冲突，则会抛出一个警告信息。</p><p><code>rcu_eqs_enter</code> 函数则用于进入RCU空闲状态并等待所有正在使用旧副本的进程访问完毕。其中，参数false表示<em>不需要检查是否处于内核软件调试状态</em>（KDB或KGDB）。在该函数中，会调用rcu_prepare_for_idle函数进行RCU更新准备工作，并将当前CPU所在的调度器状态设置为RCU空闲状态。然后，该函数会启动一个RCU处理线程，在其中等待所有正在使用旧副本的进程访问完毕并结束。❓❓ 待处理线程结束之后，该函数会将当前CPU所在调度器状态设置为正常运行状态，并返回。</p><h3 id="_9-5-enter" tabindex="-1"><a class="header-anchor" href="#_9-5-enter"><span>9.5. enter</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">entered_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> target_state</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">enter</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">dev</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>进入 state, 待深入研究。❌❌❌</p><h3 id="_9-6-rcu-idle-exit" tabindex="-1"><a class="header-anchor" href="#_9-6-rcu-idle-exit"><span>9.6. rcu_idle_exit</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">target_state</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> CPUIDLE_FLAG_RCU_IDLE</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">    rcu_idle_exit</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码用于判断目标状态是否为RCU空闲状态，并在不是RCU空闲状态时退出RCU空闲处理。</p><p>如果目标状态的flags字段中包含CPUIDLE_FLAG_RCU_IDLE标志，说明此时需要进入RCU空闲状态，即需要等待所有正在访问旧副本的进程结束后再进行新副本的更新。此时，不需要退出RCU空闲处理，代码直接跳过。</p><p>但如果目标状态的flags字段中不包含CPUIDLE_FLAG_RCU_IDLE标志，则代表当前并不需要进行RCU空闲处理。此时，需要通过rcu_idle_exit函数退出RCU空闲处理。该函数会将当前CPU所在的调度器状态设置为正常运行状态，并唤醒所有等待RCU更新的进程（如等待RCU更新的进程队列等）。这样一来，RCU更新操作就可以继续进行，而不会被阻塞在RCU空闲状态中。</p><p>需要注意的是，只有在完成了RCU更新操作之后，才能调用rcu_idle_exit函数退出RCU空闲状态。否则，会引起数据访问冲突和不一致性，导致系统出现异常。因此，在使用该函数时，需要保证系统支持RCU机制，并遵循相关的使用原则和规范。</p><h3 id="_9-7-critical-timings" tabindex="-1"><a class="header-anchor" href="#_9-7-critical-timings"><span>9.7. critical_timings</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">stop_critical_timings</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">// ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">start_critical_timings</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>stop_critical_timings</code> 用于停止内核关键代码段的性能计数和统计，以便进行性能分析和优化。该函数通常在内核调试、性能测试等场景下使用，以了解内核关键代码段的耗时和执行情况，从而进行优化。</p><p>该函数会将内核当前的性能计数器（如TSC、APIC计数器等）停止，并记录下停止时的值，然后将所有的性能计数器状态都设置为暂停。这样一来，在停止之前和停止之后，所有关键代码段的执行时间就可以计算出来了。</p><p><code>start_critical_timings</code> 的作用正好相反，就不过多赘述了。</p><h2 id="_10-idle-polling" tabindex="-1"><a class="header-anchor" href="#_10-idle-polling"><span>10. idle polling</span></a></h2><p>idle polling 是一个空闲轮询机制。</p><p>我们来看代码：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-light-font-weight:inherit;--shiki-dark:#5E81AC;--shiki-dark-font-weight:bold;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> CONFIG_GENERIC_IDLE_POLL_SETUP</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> __init </span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">cpu_idle_poll_setup</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">__unused</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">	cpu_idle_force_poll </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	return</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">__setup</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">nohlt</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpu_idle_poll_setup</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> __init </span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">cpu_idle_nopoll_setup</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">__unused</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">	cpu_idle_force_poll </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	return</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">__setup</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#A3BE8C;">hlt</span><span style="--shiki-light:#032F62;--shiki-dark:#ECEFF4;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpu_idle_nopoll_setup</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-light-font-weight:inherit;--shiki-dark:#5E81AC;--shiki-dark-font-weight:bold;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>cpu_idle_poll_ctrl</code>可以作为一个调度器选项，对空闲轮询机制进行控制。其具体做法是：</p><ul><li><p>当<code>cpu_idle_poll_ctrl=1</code>时，空闲轮询机制被启用，调度器会直接检查是否有可运行的进程；</p></li><li><p>当<code>cpu_idle_poll_ctrl=0</code>时，空闲轮询机制被禁用，CPU会挂起或执行某些简单指令以等待其他事件的发生。</p></li></ul><p>在传统的CPU调度方案中，当CPU处于空闲状态时，调度器通常会挂起CPU或让CPU执行一些简单的指令，以避免CPU浪费过多的时间。而在空闲轮询机制下，调度器会在CPU空闲时，立即检查系统中是否有可运行的进程，如果有，则立即唤醒该进程并将CPU分配给它。</p><p>具体的 polling 实现可能会分成很多种，如 busy-waiting, 表示如果没有可以运行的进程的话，则调度器会继续等待下一次轮询；如 sleep, 当 CPU 空闲时，会将整个 CPU 设置为休眠状态，以节能。</p><h2 id="_11-define-per-cpu" tabindex="-1"><a class="header-anchor" href="#_11-define-per-cpu"><span>11. DEFINE_PER_CPU</span></a></h2><p><code>DEFINE_PER_CPU</code> 是一个宏，用于定义一种特殊的变量类型，称为 &quot;per-cpu 变量&quot;。这种变量在 Linux 内核中广泛使用，用于跨多个 CPU 核心共享数据时保证数据的一致性。</p><p>使用 <code>DEFINE_PER_CPU</code> 宏定义的变量，会在每个 CPU 核心上都创建一个独立的副本，并通过内核提供的函数接口进行同步和访问。这样，在多核系统中，不同 CPU 核心上的代码可以同时访问该变量，而不会出现数据竞争或者锁竞争等问题。</p><p>具体来说，<code>DEFINE_PER_CPU</code> 宏的语法如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">DEFINE_PER_CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，<code>type</code> 指定了变量的类型，<code>var</code> 是变量名。例如：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">DEFINE_PER_CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> my_var</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上述代码定义了一个名为 <code>my_var</code> 的 per-cpu 整型变量。在汇编层面，编译器会自动生成对应的代码，以便为每个 CPU 核心上创建一个独立的 <code>int</code> 类型的变量，并对其进行初始化和管理。在 C 代码层面，程序员可以通过 <code>get_cpu_var()</code> 和 <code>put_cpu_var()</code> 等函数来访问和修改 per-cpu 变量的值，例如：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> val </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> get_cpu_var</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">my_var</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">put_cpu_var</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">my_var</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> val</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，per-cpu 变量仅适用于每个 CPU 核心独立使用的数据，并不适用于需要全局同步的数据结构。此外，需要注意内存分配和访问的开销，以避免影响系统的性能。</p><h2 id="_12-idle-data-struct" tabindex="-1"><a class="header-anchor" href="#_12-idle-data-struct"><span>12. Idle Data Struct</span></a></h2><h3 id="_12-1-abstract" tabindex="-1"><a class="header-anchor" href="#_12-1-abstract"><span>12.1. Abstract</span></a></h3><p>本章节主要针对性分析 Idle 中的数据结构。在 kernel 中的 cpuidle framework 主体包括三个模块：cpuidle core, cpudile governors 和 cpuidle drivers.</p><p><strong>cpuidle core</strong>: 负责整体框架，对接 sched 模块，调度器发现没有任务在执行的时候，就切换到 idle 进程，通知就会给 cpuidle core; cpuidle core 负责向 cpuidle driver/governors 模块提供统一的注册和管理接口，向用户空间提供 governor 选择的接口。</p><p><strong>cpuidle governors</strong>: 在该模块进行 cpuidle 的选择；</p><p><strong>cpuidle driver</strong>: 负责具体 idle 机制的实现。</p><p>总的来说，这几个的关系大致如下图所示：</p>`,111)),n(a,{id:"mermaid-753",code:"eJxNjk0Kg0AMhfeeIst2YY9QqD+F7oS2KxGRmFZhMJIZ68KZu3cchtIsAsn73kteilccOjHwKBLwdanvOFC/KJIG0vRs9ToaHFrDFrLDrVcElTCS1sfAZzsEFudl9FobGnZKWci3bZ8AWci5ABdx9eYPycTiHKSnf7smRWi8N+B5eMBrLU2GxEIZ/b2MPiCGlj+KZ23hWufVMxxtki8yeUnT"}),s[2]||(s[2]=i(`<h3 id="_12-2-cpuidle-core" tabindex="-1"><a class="header-anchor" href="#_12-2-cpuidle-core"><span>12.2. cpuidle core</span></a></h3><p>cpuidle core 是 cpuidle framework 的核心模块，负责抽象出 cpuidle device、cpuidle driver 和 cpuidle governor三个实体。</p><p>其负责的功能有：</p><ol><li>（如上阐述）向底层的 cpuidle driver 模块提供 cpudile devic e和 cpuidle driver 的注册/注销接口；</li><li>（如上阐述）向 cpuidle governors 提供 governor 的注册接口；</li><li>提供全局的 puidle 机制的开、关、暂停、恢复等功能；</li><li>（如上阐述）向用户空间程序提供 governor 选择的接口；</li><li>向 kernel sched 中的 cpuidle entry 提供 cpuidle 的级别选择、进入等接口，以方便调用。</li></ol><h3 id="_12-3-cpuidle-device" tabindex="-1"><a class="header-anchor" href="#_12-3-cpuidle-device"><span>12.3. cpuidle device</span></a></h3><p>在现在的 SMP 系统中，每个 cpu core 都会对应一个 cpuidle device, 内核通过 <code>strcut cpuidle_device</code> 抽象 cpuidle device.</p><h3 id="_12-4-cpuidle-driver" tabindex="-1"><a class="header-anchor" href="#_12-4-cpuidle-driver"><span>12.4. cpuidle driver</span></a></h3><p>cpuidle driver 是一个 “driver&quot;, 其驱动的对象是 cpuidle device, 也就是 CPU；注意到在 SMP 系统中，有多个 CPU，也就意味着有多个 cpuidle device; 在实现 idle 的时候，如果这些 cpuidle device 的功能、参数相同，则可以使用一个 cpuidle driver 驱动，具体而言，kernel 中的宏 <code>CONFIG_CPU_IDLE_MULTIPLE_DRIVERS</code> 可以用来使能是否使用多个 cpu driver. 在实际的应用场景中，这个开关是被使能的。</p><p>代码可见 https://github.com/torvalds/linux/blob/master/include/linux/cpuidle.h</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">/****************************</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;"> * CPUIDLE DRIVER INTERFACE *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;"> ****************************/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_driver </span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	const</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		*</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> module 		</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">owner</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">        /* used by the cpuidle framework to setup the broadcast timer */</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">            bctimer:</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">	/* states array must be ordered in decreasing power consumption */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_state	</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9FF;">states</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">CPUIDLE_STATE_MAX</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">]</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">			state_count</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">			safe_state_index</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">	/* the driver handles the cpus in cpumask */</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpumask		</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">cpumask</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">	/* preferred governor to switch at register time */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	const</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		*</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">governor</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bctimer:1</code>: 一个标志，用于指示在 cpuidle driver 注册和注销时，是否需要设置一个 broadcast timer;</p><p><code>cpumask</code>: 一个 struct cpumask 结构的 bit map 指针，用于说明该 driver 支持哪些 cpu core;</p><p><code>states</code>, <code>state_count</code>：该 driver 所支持的 idle state 及其个数。cpuidle driver 的主要任务就是定义所支持的 cpuidle state; 需要注意注释中所提到的，<code>states</code> 应该按照功耗大小降序排列。</p><p>cpuidle driver 的注册，我们在这边主演研究多个 cpu driver 的场景，主要是分为几个：</p><p>💄 <code>__cpuidle_get_cpu_driver</code>:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_driver </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">__cpuidle_get_cpu_driver</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;"> cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#616E88;">    // 返回 pre_cpu 指针的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> per_cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">cpuidle_drivers</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>💄<code>__cpuidle_set_driver</code></p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> __cpuidle_set_driver</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_driver </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#D8DEE9;">drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	for_each_cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;"> drv</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">cpumask</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		struct</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpuidle_driver </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">old_drv</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">		old_drv </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;"> __cpuidle_get_cpu_driver</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">old_drv </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">old_drv </span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> drv</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">			return</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">EBUSY</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">	for_each_cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;"> drv</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9;">cpumask</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line highlighted"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">		per_cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">cpuidle_drivers</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;"> drv</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	return</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于每个 cpumask 的 cpu, 设置 drv; 条件是原有的 cpu 无 drv 或者是有 drv 并且和需要设置的不相等（不相等的话直接 return 不进行设置）</li><li>设置的方法如高亮行所示</li></ul><h2 id="_13-something-else" tabindex="-1"><a class="header-anchor" href="#_13-something-else"><span>13. Something Else</span></a></h2><h3 id="_13-1-tickless" tabindex="-1"><a class="header-anchor" href="#_13-1-tickless"><span>13.1. tickless</span></a></h3><blockquote><p>In the context of operating systems, &quot;tickless&quot; refers to a power management feature that allows the system to reduce power consumption by dynamically adjusting the frequency of timer interrupts.</p></blockquote><p>About &quot;tick&quot; interrupt:</p><blockquote><p>Traditionally, operating systems use a periodic timer interrupt, often called the &quot;tick,&quot; to keep track of time and to perform various tasks such as updating the system clock, scheduling tasks, and handling interrupts. These timer interrupts are generated at a fixed frequency, regardless of whether there is any work to be done, which can consume a significant amount of power.</p></blockquote><h3 id="_13-2-wfi" tabindex="-1"><a class="header-anchor" href="#_13-2-wfi"><span>13.2. WFI</span></a></h3><p>WFI 是英文 Wait for Interrupt 的缩写，意为等待中断。WFI 指令是 ARM 处理器提供的一种指令，用于将处理器置于等待状态，直到下一个中断事件发生后才会继续执行。</p><p>Arm64 提供了 WFI 指令，使得 CPU 一旦执行该指令就进入低功耗状态，该状态会关闭 CPU 时钟，从而降低动态功耗。</p><p>如果我们想实现一个简单的 idle 的话，需要以下的流程即可<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#24292e;--shiki-dark:#d8dee9ff;--shiki-light-bg:#fff;--shiki-dark-bg:#2e3440ff;"><pre class="shiki shiki-themes github-light nord vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#B48EAD;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#D8DEE9FF;">condition</span><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#81A1C1;">		break</span><span style="--shiki-light:#24292E;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，我们的 CPU 空转一直等待某个条件成立；这是最简单的实现方法。</p><p>而 Arm64 提供的 WFI 指令可以帮助系统降低功耗。此外，操作系统还可以通过 WFI 指令实现快速唤醒，以保证系统的响应速度和实时性。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>https://zhuanlan.zhihu.com/p/539722367 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li></ol></section>`,34))])}const c=e(p,[["render",k]]),g=JSON.parse('{"path":"/linux/kernel/idle.html","title":"Idle","lang":"zh-CN","frontmatter":{"title":"Idle","date":"2023-03-16T00:00:00.000Z","author":"weigao","category":["Kernel"],"description":"1. Abstract 本文主要研究 kernel 中的 idle 机制以及代码实现。 2. x86 idle state 来看一下 x86 的 idle state： C-state 描述的是 CPU 处于空闲时的不同睡眠状态，包括 POLL C1 C1E和C6，它们统称为 C-states。CPU 的每种睡眠状态都消耗不同的功耗，并且对应用程序性能...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Idle\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-16T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-12T08:59:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"weigao\\"}]}"],["meta",{"property":"og:url","content":"https://vueblog.weigao.cc/linux/kernel/idle.html"}],["meta",{"property":"og:site_name","content":"weigao"}],["meta",{"property":"og:title","content":"Idle"}],["meta",{"property":"og:description","content":"1. Abstract 本文主要研究 kernel 中的 idle 机制以及代码实现。 2. x86 idle state 来看一下 x86 的 idle state： C-state 描述的是 CPU 处于空闲时的不同睡眠状态，包括 POLL C1 C1E和C6，它们统称为 C-states。CPU 的每种睡眠状态都消耗不同的功耗，并且对应用程序性能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-12T08:59:22.000Z"}],["meta",{"property":"article:author","content":"weigao"}],["meta",{"property":"article:published_time","content":"2023-03-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-12T08:59:22.000Z"}]]},"git":{"createdTime":1678955724000,"updatedTime":1747040362000,"contributors":[{"name":"weigao chen","username":"","email":"weigao_1995@yeah.net","commits":3},{"name":"chenweigao","username":"chenweigao","email":"297859260@qq.com","commits":1,"url":"https://github.com/chenweigao"},{"name":"xiaocheng","username":"xiaocheng","email":"weigao.cwg","commits":1,"url":"https://github.com/xiaocheng"}]},"readingTime":{"minutes":21.09,"words":6327},"filePathRelative":"linux/kernel/idle.md","excerpt":"<h2>1. Abstract</h2>\\n<p>本文主要研究 kernel 中的 idle 机制以及代码实现。</p>\\n<h2>2. x86 idle state</h2>\\n<p>来看一下 x86 的 idle state：</p>\\n<p>C-state 描述的是 CPU 处于空闲时的不同睡眠状态，包括 POLL C1 C1E和C6，它们统称为 C-states。CPU 的每种睡眠状态都消耗不同的功耗，并且对应用程序性能的影响也不同。这些状态的睡眠深度排序为 C6 &gt; C1E &gt; C1 &gt; POLL。</p>\\n<p>POLL 状态表示 CPU 不睡眠，一直空跑或执行指令，这种状态下 CPU 性能最好，功耗也最大。</p>","autoDesc":true}');export{c as comp,g as data};
