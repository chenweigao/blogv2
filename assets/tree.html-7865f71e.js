import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as l,c,a as n,b as s,d as t,f as e}from"./app-22cda79c.js";const i={},u=e('<h2 id="preorder-traversal" tabindex="-1"><a class="header-anchor" href="#preorder-traversal" aria-hidden="true">#</a> Preorder Traversal</h2><h3 id="多叉树的前序遍历" tabindex="-1"><a class="header-anchor" href="#多叉树的前序遍历" aria-hidden="true">#</a> 多叉树的前序遍历</h3><p>多叉树的前序遍历，给定多叉树，用数组表示：<code>root = [1,null,3,2,4,null,5,6]</code>, 每个层级之间用 <code>null</code> 进行隔离，根据这个输出这棵树的前序遍历结果。</p><p>题目中提到了，<strong>递归</strong>的方法比较简单，希望我们用<strong>迭代</strong>的方法进行求解。</p>',4),r={href:"https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/",target:"_blank",rel:"noopener noreferrer"},d=e(`<p>需要遍历的多叉树数据结构定义如下：</p><div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> children<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span>children <span class="token operator">=</span> children
</code></pre></div><ol><li><p>递归法</p><p>递归法的实现如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res

    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">,</span> res<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>child<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们定义一个 <code>res</code> 用于存储最终结果，然后先遍历 <code>root</code>, 再遍历 <code>root</code> 所有的子节点，因为存储的时候按照从左到右的顺序存储，因此这种遍历是可以达到前序遍历的效果的。</p></li><li><p>迭代法</p><p>前序遍历的迭代，要求根-左-右的顺序返回各个节点，我们给出迭代的解法如下所示：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token comment"># 栈顶元素是左侧元素</span>
                stack<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们仔细研究一下，这个迭代中有几个关键点：</p><ol><li>使用了<strong>栈</strong></li><li>把 node 的 children 逆序入栈，保证了先出栈的元素一定是最左侧的</li></ol><p>多多理解，十分巧妙！</p></li></ol><h3 id="二叉树的前序遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的前序遍历" aria-hidden="true">#</a> 二叉树的前序遍历</h3><p>递归法:</p><p>@todo</p><p>迭代法:</p><p>@todo</p><h2 id="level-order-traversal" tabindex="-1"><a class="header-anchor" href="#level-order-traversal" aria-hidden="true">#</a> Level Order Traversal</h2><h3 id="二叉树的层次遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的层次遍历" aria-hidden="true">#</a> 二叉树的层次遍历</h3><h2 id="inorder-traversal" tabindex="-1"><a class="header-anchor" href="#inorder-traversal" aria-hidden="true">#</a> Inorder Traversal</h2><h2 id="trie-前缀树" tabindex="-1"><a class="header-anchor" href="#trie-前缀树" aria-hidden="true">#</a> Trie 前缀树</h2><p>@todo 实现前缀树</p>`,13),k={href:"https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/",target:"_blank",rel:"noopener noreferrer"},v=n("h2",{id:"bst",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#bst","aria-hidden":"true"},"#"),s(" BST")],-1),m={href:"https://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/",target:"_blank",rel:"noopener noreferrer"},b=n("ul",null,[n("li",null,"We can get all keys in sorted order by just doing Inorder Traversal of BST."),n("li",null,"Doing order statistics, finding closest lower and greater elements, doing range queries are easy to do with BSTs."),n("li",null,"BSTs are easy to implement compared to hashing, we can easily implement our own customized BST."),n("li",null,"..."),n("li",null,[s("Hash table supports following operations in Θ(1) time: "),n("strong",null,"search insert and delete"),s(", BST is O(logn) for these operation.")])],-1),h=n("h3",{id:"bst-中序遍历",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#bst-中序遍历","aria-hidden":"true"},"#"),s(" BST 中序遍历")],-1),f={href:"https://github.com/chenweigao/_code/blob/master/data_struct/BST_inorder.py",target:"_blank",rel:"noopener noreferrer"},y=e(`<p>Recursive</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>inorder<span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res

    <span class="token keyword">def</span> <span class="token function">inorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>inorder<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="lc653-两数之和-iv-输入-bst" tabindex="-1"><a class="header-anchor" href="#lc653-两数之和-iv-输入-bst" aria-hidden="true">#</a> LC653 两数之和 IV - 输入 BST</h4><blockquote><p>给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p></blockquote><p>这个题目需要用到二叉搜索树和两数之和解法的一些特性：</p><ol><li>二叉搜索树中序遍历出的结果是有序的（左根右）</li><li>两数之和问题可以使用双指针来求解，或者使用 hash map</li></ol><h5 id="解法1-dfs-hash-map" tabindex="-1"><a class="header-anchor" href="#解法1-dfs-hash-map" aria-hidden="true">#</a> 解法1：DFS + hash map</h5><p>这个解法的核心思路就是，把这个 BST 当作普通的二叉树处理，然后使用 hash map 记录元素出现的个数，比较直观的解法，其实现代码如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>dic <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">findTarget</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

        <span class="token keyword">if</span> k <span class="token operator">-</span> root<span class="token punctuation">.</span>val <span class="token keyword">in</span> self<span class="token punctuation">.</span>dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>

        self<span class="token punctuation">.</span>dic<span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>findTarget<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>findTarget<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="解法2-中序遍历-双指针" tabindex="-1"><a class="header-anchor" href="#解法2-中序遍历-双指针" aria-hidden="true">#</a> 解法2：中序遍历 + 双指针</h5><p>由于我们知道 BST 的中序遍历出来的结果是升序的，所以说我们可以把中序遍历的结果保存起来，然后用双指针去找，看有没有结果。</p><p>在此复习一下二叉树的中序遍历，中序遍历的解法可以看上文总结。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findTarget</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token comment"># 中序遍历 BST</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
        <span class="token comment"># 此时 res 已经是升序了，我们使用双指针</span>
        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token comment"># 这边 while l &lt; r 也可以</span>
        <span class="token keyword">while</span> l <span class="token operator">!=</span> r<span class="token punctuation">:</span>
            <span class="token keyword">if</span> res<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> k<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> res<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> k<span class="token punctuation">:</span>
                r <span class="token operator">-=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                l <span class="token operator">+=</span> <span class="token number">1</span>

        <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="解法3-迭代-双指针" tabindex="-1"><a class="header-anchor" href="#解法3-迭代-双指针" aria-hidden="true">#</a> 解法3：迭代 + 双指针</h5><p>这个解法不再需要额外的空间消耗，比较不错。</p><p>@todo</p><h3 id="删除二叉搜索树中的节点" tabindex="-1"><a class="header-anchor" href="#删除二叉搜索树中的节点" aria-hidden="true">#</a> 删除二叉搜索树中的节点</h3><h4 id="lc450-删除二叉搜索树中的节点" tabindex="-1"><a class="header-anchor" href="#lc450-删除二叉搜索树中的节点" aria-hidden="true">#</a> LC450 删除二叉搜索树中的节点</h4><p>这个解法一是我一年前（2021）的解法，如下所示，写的还是比较清晰的：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># Definition for a binary tree node.</span>
<span class="token comment"># class TreeNode:</span>
<span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="token comment">#         self.val = val</span>
<span class="token comment">#         self.left = left</span>
<span class="token comment">#         self.right = right</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">get_successor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;获取root的后继节点
        1. 定位到 root 右子树
        2. 寻找右子树中最靠左的节点
        &quot;&quot;&quot;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">while</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
        <span class="token keyword">return</span> root

    <span class="token keyword">def</span> <span class="token function">get_precursor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;获取root的前驱节点
        1. 定位到 root左子树
        2. 寻找左子树中最靠右的节点
        &quot;&quot;&quot;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
        <span class="token keyword">while</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">return</span> root

    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

        <span class="token keyword">if</span> key <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token comment"># 删除</span>
            <span class="token comment"># 待删除的接地那没有子节点</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                root <span class="token operator">=</span> <span class="token boolean">None</span>
            <span class="token comment"># 如果要删除的节点只有左节点</span>
            <span class="token keyword">elif</span> root<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            <span class="token comment"># 只有右节点同理</span>
            <span class="token keyword">elif</span> root<span class="token punctuation">.</span>right <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right

            <span class="token comment"># 如果左右节点都有，从左子树中找到最大的节点，或者右子树中找到最小的节点来替换自己</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># 找到后继节点</span>
                succeeded <span class="token operator">=</span> self<span class="token punctuation">.</span>get_successor<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root<span class="token punctuation">.</span>val <span class="token operator">=</span> succeeded<span class="token punctuation">.</span>val
                root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> succeeded<span class="token punctuation">.</span>val<span class="token punctuation">)</span>

        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> key<span class="token punctuation">:</span>
            <span class="token comment"># 比 key 大，找左边的</span>
            root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>

        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要分析一下，先看如下的函数，要寻找某个节点右子树中最左边的那个节点：</p><div class="language-python" data-ext="py"><pre class="language-python"><code>    <span class="token keyword">def</span> <span class="token function">get_successor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;获取root的后继节点
        1. 定位到 root 右子树
        2. 寻找右子树中最靠左的节点
        &quot;&quot;&quot;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">while</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
        <span class="token keyword">return</span> root
</code></pre></div><ol><li>定位到 root 的右子树（右节点）</li><li>右子树的最坐标节点找到，找到后返回</li></ol><p>这个思路十分巧妙，应当加以学习。</p><p>我们在主流程中（遇到 root == key, 并且左右子树都存在的情况），我们的方法是：</p><ol><li>首先找到 root 右子树的最左边的那个节点，这个节点将来就是用来替换 root 的，这么做的原因在于，替换掉以后，这个节点的左子树都比它小，右子树都比他大</li><li>我们找到以后把找到的最左边节点的值赋值给 root, 然后递归调用 root 的右子树，删除找到的最左边节点这个节点。在这里为什么递归会起作用呢？这是因为我们在递归到最左边子树的时候，这时候的这个节点必然是没有左子树的，所以符合我们上面讨论的只有右边节点这个递归条件，我们就可以解决了。</li></ol><p>来看看一年后的解法是怎么写的：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root

        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">:</span>
            <span class="token comment"># if not root.left and not root.right:</span>
            <span class="token comment">#     root = None</span>
            <span class="token comment"># elif not root.left and root.right:</span>
            <span class="token comment">#     root = root.right</span>
            <span class="token comment"># elif not root.right and root.left:</span>
            <span class="token comment">#     root = root.left</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left <span class="token keyword">or</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">else</span> root<span class="token punctuation">.</span>right
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                successor <span class="token operator">=</span> root<span class="token punctuation">.</span>right
                <span class="token keyword">while</span> successor<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    successor <span class="token operator">=</span> successor<span class="token punctuation">.</span>left
                root<span class="token punctuation">.</span>val <span class="token operator">=</span> successor<span class="token punctuation">.</span>val
                root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> successor<span class="token punctuation">.</span>val<span class="token punctuation">)</span>

        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> key<span class="token punctuation">:</span>
            root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>deleteNode<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>

        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意到我们简化了一长串的 <code>if-elif-else</code>, 只是做了逻辑上面的优化，令代码更加优雅。</p>`,29);function g(w,_){const a=p("ExternalLinkIcon");return l(),c("div",null,[u,n("p",null,[s("题目链接如下："),n("a",r,[s("LC589 N 叉树的前序遍历"),t(a)])]),d,n("p",null,[n("a",k,[s("https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/"),t(a)])]),v,n("p",null,[n("a",m,[s("Advantages of BST(Binary Search Tree) over Hash Table"),t(a)])]),b,h,n("p",null,[n("a",f,[s("解法参考代码"),t(a)]),s(":")]),y])}const N=o(i,[["render",g],["__file","tree.html.vue"]]);export{N as default};
