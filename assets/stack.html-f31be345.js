const e=JSON.parse('{"key":"v-160a850f","path":"/algorithm/data_struct/stack.html","title":"Stack","lang":"zh-CN","frontmatter":{"title":"Stack","date":"2019-09-04T00:00:00.000Z","description":"Abstract todo Stack Problem Valid Parentheses(括号匹配) 堆栈在处理递归问题时非常有用，对于括号匹配，是栈应用的经典案例： Initialize a stack S: 初始化栈 Process each bracket(括号) of the expression one at a time. If we encounter an opening bracket, then we check the element on the top of the stack. (遇到左括号则入栈) If the element at the top of the stack is an openning bracket of the same type, the we pop it off the stack and continue processing. (栈顶元素和外面相匹配，则出栈继续) Else this implies an invaild expression. In the end, if we are left with a stack still having elements, then this implies an invaild expression. (栈不空则表达式非法)","head":[["meta",{"property":"og:url","content":"https://vueblog.weigao.cc/algorithm/data_struct/stack.html"}],["meta",{"property":"og:site_name","content":"WW"}],["meta",{"property":"og:title","content":"Stack"}],["meta",{"property":"og:description","content":"Abstract todo Stack Problem Valid Parentheses(括号匹配) 堆栈在处理递归问题时非常有用，对于括号匹配，是栈应用的经典案例： Initialize a stack S: 初始化栈 Process each bracket(括号) of the expression one at a time. If we encounter an opening bracket, then we check the element on the top of the stack. (遇到左括号则入栈) If the element at the top of the stack is an openning bracket of the same type, the we pop it off the stack and continue processing. (栈顶元素和外面相匹配，则出栈继续) Else this implies an invaild expression. In the end, if we are left with a stack still having elements, then this implies an invaild expression. (栈不空则表达式非法)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Someone"}],["meta",{"property":"article:published_time","content":"2019-09-04T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Stack\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-09-04T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Someone\\",\\"url\\":\\"https://www.weigao.cc\\"}]}"]]},"headers":[{"level":2,"title":"Abstract","slug":"abstract","link":"#abstract","children":[]},{"level":2,"title":"Stack Problem","slug":"stack-problem","link":"#stack-problem","children":[{"level":3,"title":"Valid Parentheses(括号匹配)","slug":"valid-parentheses-括号匹配","link":"#valid-parentheses-括号匹配","children":[]},{"level":3,"title":"Validate Stack Sequence","slug":"validate-stack-sequence","link":"#validate-stack-sequence","children":[]},{"level":3,"title":"Next Greater Element","slug":"next-greater-element","link":"#next-greater-element","children":[]},{"level":3,"title":"用两个栈实现一个队列","slug":"用两个栈实现一个队列","link":"#用两个栈实现一个队列","children":[]},{"level":3,"title":"用两个队列实现一个栈","slug":"用两个队列实现一个栈","link":"#用两个队列实现一个栈","children":[]},{"level":3,"title":"括号匹配","slug":"括号匹配","link":"#括号匹配","children":[]},{"level":3,"title":"后缀表达式","slug":"后缀表达式","link":"#后缀表达式","children":[]}]}],"git":{},"readingTime":{"minutes":2.73,"words":818},"filePathRelative":"algorithm/data_struct/stack.md","localizedDate":"2019年9月4日","excerpt":"\\n<h2> Abstract</h2>\\n<p>todo</p>\\n<h2> Stack Problem</h2>\\n<h3> Valid Parentheses(括号匹配)</h3>\\n<p>堆栈在处理递归问题时非常有用，对于<strong>括号匹配</strong>，是栈应用的经典案例：</p>\\n<ol>\\n<li>\\n<p>Initialize a stack S: 初始化栈</p>\\n</li>\\n<li>\\n<p>Process each bracket(括号) of the expression one at a time.</p>\\n</li>\\n<li>\\n<p>If we encounter an opening bracket, then we check the element on the top of the stack. (遇到左括号则入栈)</p>\\n</li>\\n<li>\\n<p>If the element at the top of the stack is an openning bracket <strong>of the same type</strong>, the we <strong>pop</strong> it off the stack and continue processing. (栈顶元素和外面相匹配，则出栈继续)</p>\\n</li>\\n<li>\\n<p>Else this implies an invaild expression.</p>\\n</li>\\n<li>\\n<p>In the end, if we are left with a stack still having elements, then this implies an invaild expression. (栈不空则表达式非法)</p>\\n</li>\\n</ol>","autoDesc":true}');export{e as data};
